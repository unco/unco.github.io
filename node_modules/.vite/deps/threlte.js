import {
  ACESFilmicToneMapping,
  AmbientLight,
  AnimationClip,
  Audio,
  AudioListener,
  AudioLoader,
  BackSide,
  Bone,
  Box3,
  BoxGeometry,
  BufferAttribute,
  BufferGeometry,
  Camera,
  ClampToEdgeWrapping,
  Clock,
  Color,
  CompressedArrayTexture,
  CompressedTexture,
  CylinderGeometry,
  Data3DTexture,
  DataTexture,
  DirectionalLight,
  DoubleSide,
  Euler,
  EventDispatcher,
  FileLoader,
  Float32BufferAttribute,
  FloatType,
  Fog,
  FogExp2,
  FrontSide,
  Frustum,
  Group,
  HalfFloatType,
  HemisphereLight,
  ImageBitmapLoader,
  InstancedBufferAttribute,
  InstancedBufferGeometry,
  InstancedInterleavedBuffer,
  InstancedMesh,
  InterleavedBuffer,
  InterleavedBufferAttribute,
  Interpolant,
  InterpolateDiscrete,
  InterpolateLinear,
  Line,
  Line3,
  LineBasicMaterial,
  LineLoop,
  LineSegments,
  LinearEncoding,
  LinearFilter,
  LinearMipmapLinearFilter,
  LinearMipmapNearestFilter,
  LinearSRGBColorSpace,
  Loader,
  LoaderUtils,
  MOUSE,
  Material,
  MathUtils,
  Matrix3,
  Matrix4,
  Mesh,
  MeshBasicMaterial,
  MeshDepthMaterial,
  MeshDistanceMaterial,
  MeshPhysicalMaterial,
  MeshStandardMaterial,
  MirroredRepeatWrapping,
  NearestFilter,
  NearestMipmapLinearFilter,
  NearestMipmapNearestFilter,
  NoColorSpace,
  NoToneMapping,
  NumberKeyframeTrack,
  Object3D,
  OctahedronGeometry,
  OrthographicCamera,
  PCFSoftShadowMap,
  PerspectiveCamera,
  PlaneBufferGeometry,
  PlaneGeometry,
  PointLight,
  Points,
  PointsMaterial,
  PositionalAudio,
  PropertyBinding,
  Quaternion,
  QuaternionKeyframeTrack,
  RGBADepthPacking,
  RGBAFormat,
  RGBA_ASTC_4x4_Format,
  RGBA_BPTC_Format,
  RGBA_ETC2_EAC_Format,
  RGBA_PVRTC_4BPPV1_Format,
  RGBA_S3TC_DXT5_Format,
  RGB_ETC1_Format,
  RGB_ETC2_Format,
  RGB_PVRTC_4BPPV1_Format,
  RGB_S3TC_DXT1_Format,
  RGFormat,
  Raycaster,
  RedFormat,
  RepeatWrapping,
  SRGBColorSpace,
  Scene,
  ShaderChunk,
  ShaderLib,
  ShaderMaterial,
  Skeleton,
  SkinnedMesh,
  Sphere,
  SphereGeometry,
  Spherical,
  SpotLight,
  TOUCH,
  Texture,
  TextureLoader,
  TorusGeometry,
  TriangleFanDrawMode,
  TriangleStripDrawMode,
  TrianglesDrawMode,
  UniformsLib,
  UniformsUtils,
  UnsignedByteType,
  Vector2,
  Vector3,
  Vector4,
  VectorKeyframeTrack,
  WebGLRenderTarget,
  WebGLRenderer,
  WireframeGeometry,
  sRGBEncoding
} from "./chunk-Y7HYQMW7.js";
import {
  derived,
  readable,
  writable
} from "./chunk-6NUSVQJM.js";
import "./chunk-6A2TAOKG.js";
import {
  SvelteComponentDev,
  action_destroyer,
  add_flush_callback,
  add_location,
  append_styles,
  attr_dev,
  bind,
  binding_callbacks,
  bubble,
  check_outros,
  children,
  claim_component,
  claim_element,
  claim_space,
  component_subscribe,
  createEventDispatcher,
  create_component,
  create_slot,
  destroy_component,
  destroy_each,
  detach_dev,
  dispatch_dev,
  element,
  empty,
  getContext,
  get_all_dirty_from_scope,
  get_slot_changes,
  get_store_value,
  globals,
  group_outros,
  init,
  insert_hydration_dev,
  listen_dev,
  mount_component,
  noop,
  onDestroy,
  onMount,
  run_all,
  safe_not_equal,
  setContext,
  set_store_value,
  space,
  subscribe,
  tick,
  transition_in,
  transition_out,
  update_slot_base,
  validate_each_argument,
  validate_slots,
  validate_store
} from "./chunk-CKECMU6L.js";

// node_modules/three/examples/jsm/shaders/CopyShader.js
var CopyShader = {
  name: "CopyShader",
  uniforms: {
    "tDiffuse": { value: null },
    "opacity": { value: 1 }
  },
  vertexShader: (
    /* glsl */
    `

		varying vec2 vUv;

		void main() {

			vUv = uv;
			gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );

		}`
  ),
  fragmentShader: (
    /* glsl */
    `

		uniform float opacity;

		uniform sampler2D tDiffuse;

		varying vec2 vUv;

		void main() {

			gl_FragColor = texture2D( tDiffuse, vUv );
			gl_FragColor.a *= opacity;


		}`
  )
};

// node_modules/three/examples/jsm/postprocessing/Pass.js
var Pass = class {
  constructor() {
    this.isPass = true;
    this.enabled = true;
    this.needsSwap = true;
    this.clear = false;
    this.renderToScreen = false;
  }
  setSize() {
  }
  render() {
    console.error("THREE.Pass: .render() must be implemented in derived pass.");
  }
  dispose() {
  }
};
var _camera = new OrthographicCamera(-1, 1, 1, -1, 0, 1);
var _geometry = new BufferGeometry();
_geometry.setAttribute("position", new Float32BufferAttribute([-1, 3, 0, -1, -1, 0, 3, -1, 0], 3));
_geometry.setAttribute("uv", new Float32BufferAttribute([0, 2, 0, 0, 2, 0], 2));
var FullScreenQuad = class {
  constructor(material) {
    this._mesh = new Mesh(_geometry, material);
  }
  dispose() {
    this._mesh.geometry.dispose();
  }
  render(renderer) {
    renderer.render(this._mesh, _camera);
  }
  get material() {
    return this._mesh.material;
  }
  set material(value) {
    this._mesh.material = value;
  }
};

// node_modules/three/examples/jsm/postprocessing/ShaderPass.js
var ShaderPass = class extends Pass {
  constructor(shader, textureID) {
    super();
    this.textureID = textureID !== void 0 ? textureID : "tDiffuse";
    if (shader instanceof ShaderMaterial) {
      this.uniforms = shader.uniforms;
      this.material = shader;
    } else if (shader) {
      this.uniforms = UniformsUtils.clone(shader.uniforms);
      this.material = new ShaderMaterial({
        name: shader.name !== void 0 ? shader.name : "unspecified",
        defines: Object.assign({}, shader.defines),
        uniforms: this.uniforms,
        vertexShader: shader.vertexShader,
        fragmentShader: shader.fragmentShader
      });
    }
    this.fsQuad = new FullScreenQuad(this.material);
  }
  render(renderer, writeBuffer, readBuffer) {
    if (this.uniforms[this.textureID]) {
      this.uniforms[this.textureID].value = readBuffer.texture;
    }
    this.fsQuad.material = this.material;
    if (this.renderToScreen) {
      renderer.setRenderTarget(null);
      this.fsQuad.render(renderer);
    } else {
      renderer.setRenderTarget(writeBuffer);
      if (this.clear)
        renderer.clear(renderer.autoClearColor, renderer.autoClearDepth, renderer.autoClearStencil);
      this.fsQuad.render(renderer);
    }
  }
  dispose() {
    this.material.dispose();
    this.fsQuad.dispose();
  }
};

// node_modules/three/examples/jsm/postprocessing/MaskPass.js
var MaskPass = class extends Pass {
  constructor(scene, camera) {
    super();
    this.scene = scene;
    this.camera = camera;
    this.clear = true;
    this.needsSwap = false;
    this.inverse = false;
  }
  render(renderer, writeBuffer, readBuffer) {
    const context = renderer.getContext();
    const state = renderer.state;
    state.buffers.color.setMask(false);
    state.buffers.depth.setMask(false);
    state.buffers.color.setLocked(true);
    state.buffers.depth.setLocked(true);
    let writeValue, clearValue;
    if (this.inverse) {
      writeValue = 0;
      clearValue = 1;
    } else {
      writeValue = 1;
      clearValue = 0;
    }
    state.buffers.stencil.setTest(true);
    state.buffers.stencil.setOp(context.REPLACE, context.REPLACE, context.REPLACE);
    state.buffers.stencil.setFunc(context.ALWAYS, writeValue, 4294967295);
    state.buffers.stencil.setClear(clearValue);
    state.buffers.stencil.setLocked(true);
    renderer.setRenderTarget(readBuffer);
    if (this.clear)
      renderer.clear();
    renderer.render(this.scene, this.camera);
    renderer.setRenderTarget(writeBuffer);
    if (this.clear)
      renderer.clear();
    renderer.render(this.scene, this.camera);
    state.buffers.color.setLocked(false);
    state.buffers.depth.setLocked(false);
    state.buffers.stencil.setLocked(false);
    state.buffers.stencil.setFunc(context.EQUAL, 1, 4294967295);
    state.buffers.stencil.setOp(context.KEEP, context.KEEP, context.KEEP);
    state.buffers.stencil.setLocked(true);
  }
};
var ClearMaskPass = class extends Pass {
  constructor() {
    super();
    this.needsSwap = false;
  }
  render(renderer) {
    renderer.state.buffers.stencil.setLocked(false);
    renderer.state.buffers.stencil.setTest(false);
  }
};

// node_modules/three/examples/jsm/postprocessing/EffectComposer.js
var EffectComposer = class {
  constructor(renderer, renderTarget) {
    this.renderer = renderer;
    this._pixelRatio = renderer.getPixelRatio();
    if (renderTarget === void 0) {
      const size = renderer.getSize(new Vector2());
      this._width = size.width;
      this._height = size.height;
      renderTarget = new WebGLRenderTarget(this._width * this._pixelRatio, this._height * this._pixelRatio, { type: HalfFloatType });
      renderTarget.texture.name = "EffectComposer.rt1";
    } else {
      this._width = renderTarget.width;
      this._height = renderTarget.height;
    }
    this.renderTarget1 = renderTarget;
    this.renderTarget2 = renderTarget.clone();
    this.renderTarget2.texture.name = "EffectComposer.rt2";
    this.writeBuffer = this.renderTarget1;
    this.readBuffer = this.renderTarget2;
    this.renderToScreen = true;
    this.passes = [];
    this.copyPass = new ShaderPass(CopyShader);
    this.clock = new Clock();
  }
  swapBuffers() {
    const tmp = this.readBuffer;
    this.readBuffer = this.writeBuffer;
    this.writeBuffer = tmp;
  }
  addPass(pass) {
    this.passes.push(pass);
    pass.setSize(this._width * this._pixelRatio, this._height * this._pixelRatio);
  }
  insertPass(pass, index) {
    this.passes.splice(index, 0, pass);
    pass.setSize(this._width * this._pixelRatio, this._height * this._pixelRatio);
  }
  removePass(pass) {
    const index = this.passes.indexOf(pass);
    if (index !== -1) {
      this.passes.splice(index, 1);
    }
  }
  isLastEnabledPass(passIndex) {
    for (let i = passIndex + 1; i < this.passes.length; i++) {
      if (this.passes[i].enabled) {
        return false;
      }
    }
    return true;
  }
  render(deltaTime) {
    if (deltaTime === void 0) {
      deltaTime = this.clock.getDelta();
    }
    const currentRenderTarget = this.renderer.getRenderTarget();
    let maskActive = false;
    for (let i = 0, il = this.passes.length; i < il; i++) {
      const pass = this.passes[i];
      if (pass.enabled === false)
        continue;
      pass.renderToScreen = this.renderToScreen && this.isLastEnabledPass(i);
      pass.render(this.renderer, this.writeBuffer, this.readBuffer, deltaTime, maskActive);
      if (pass.needsSwap) {
        if (maskActive) {
          const context = this.renderer.getContext();
          const stencil = this.renderer.state.buffers.stencil;
          stencil.setFunc(context.NOTEQUAL, 1, 4294967295);
          this.copyPass.render(this.renderer, this.writeBuffer, this.readBuffer, deltaTime);
          stencil.setFunc(context.EQUAL, 1, 4294967295);
        }
        this.swapBuffers();
      }
      if (MaskPass !== void 0) {
        if (pass instanceof MaskPass) {
          maskActive = true;
        } else if (pass instanceof ClearMaskPass) {
          maskActive = false;
        }
      }
    }
    this.renderer.setRenderTarget(currentRenderTarget);
  }
  reset(renderTarget) {
    if (renderTarget === void 0) {
      const size = this.renderer.getSize(new Vector2());
      this._pixelRatio = this.renderer.getPixelRatio();
      this._width = size.width;
      this._height = size.height;
      renderTarget = this.renderTarget1.clone();
      renderTarget.setSize(this._width * this._pixelRatio, this._height * this._pixelRatio);
    }
    this.renderTarget1.dispose();
    this.renderTarget2.dispose();
    this.renderTarget1 = renderTarget;
    this.renderTarget2 = renderTarget.clone();
    this.writeBuffer = this.renderTarget1;
    this.readBuffer = this.renderTarget2;
  }
  setSize(width, height) {
    this._width = width;
    this._height = height;
    const effectiveWidth = this._width * this._pixelRatio;
    const effectiveHeight = this._height * this._pixelRatio;
    this.renderTarget1.setSize(effectiveWidth, effectiveHeight);
    this.renderTarget2.setSize(effectiveWidth, effectiveHeight);
    for (let i = 0; i < this.passes.length; i++) {
      this.passes[i].setSize(effectiveWidth, effectiveHeight);
    }
  }
  setPixelRatio(pixelRatio) {
    this._pixelRatio = pixelRatio;
    this.setSize(this._width, this._height);
  }
  dispose() {
    this.renderTarget1.dispose();
    this.renderTarget2.dispose();
    this.copyPass.dispose();
  }
};

// node_modules/three/examples/jsm/postprocessing/RenderPass.js
var RenderPass = class extends Pass {
  constructor(scene, camera, overrideMaterial, clearColor, clearAlpha) {
    super();
    this.scene = scene;
    this.camera = camera;
    this.overrideMaterial = overrideMaterial;
    this.clearColor = clearColor;
    this.clearAlpha = clearAlpha !== void 0 ? clearAlpha : 0;
    this.clear = true;
    this.clearDepth = false;
    this.needsSwap = false;
    this._oldClearColor = new Color();
  }
  render(renderer, writeBuffer, readBuffer) {
    const oldAutoClear = renderer.autoClear;
    renderer.autoClear = false;
    let oldClearAlpha, oldOverrideMaterial;
    if (this.overrideMaterial !== void 0) {
      oldOverrideMaterial = this.scene.overrideMaterial;
      this.scene.overrideMaterial = this.overrideMaterial;
    }
    if (this.clearColor) {
      renderer.getClearColor(this._oldClearColor);
      oldClearAlpha = renderer.getClearAlpha();
      renderer.setClearColor(this.clearColor, this.clearAlpha);
    }
    if (this.clearDepth) {
      renderer.clearDepth();
    }
    renderer.setRenderTarget(this.renderToScreen ? null : readBuffer);
    if (this.clear)
      renderer.clear(renderer.autoClearColor, renderer.autoClearDepth, renderer.autoClearStencil);
    renderer.render(this.scene, this.camera);
    if (this.clearColor) {
      renderer.setClearColor(this._oldClearColor, oldClearAlpha);
    }
    if (this.overrideMaterial !== void 0) {
      this.scene.overrideMaterial = oldOverrideMaterial;
    }
    renderer.autoClear = oldAutoClear;
  }
};

// node_modules/threlte/lib/renderer.js
var createRendererAndComposer = (ctx, canvas, rendererParameters) => {
  ctx.renderer = new WebGLRenderer({
    powerPreference: "high-performance",
    canvas,
    antialias: true,
    alpha: true,
    ...rendererParameters
  });
  ctx.composer = new EffectComposer(ctx.renderer);
  ctx.composer.addPass(new RenderPass(ctx.scene, get_store_value(ctx.camera)));
};
var setRendererColorOutput = (ctx, linear, flat) => {
  if (!ctx.renderer)
    return;
  if (linear) {
    ctx.renderer.outputEncoding = LinearEncoding;
  } else {
    ctx.renderer.outputEncoding = sRGBEncoding;
  }
  if (flat) {
    ctx.renderer.toneMapping = NoToneMapping;
  } else {
    ctx.renderer.toneMapping = ACESFilmicToneMapping;
  }
};
var setRendererAndComposerSize = (ctx, size, dpr) => {
  if (!ctx.renderer || !ctx.composer)
    return;
  ctx.renderer.setSize(size.width, size.height);
  ctx.renderer.setPixelRatio(dpr);
  ctx.composer.setSize(size.width, size.height);
  ctx.composer.setPixelRatio(dpr);
};
var setRendererShadows = (ctx, shadows, shadowMapType) => {
  if (!ctx.renderer)
    return;
  ctx.renderer.shadowMap.enabled = shadows;
  ctx.renderer.shadowMap.type = shadowMapType;
};

// node_modules/threlte/lib/getThrelteUserData.js
var getThrelteUserData = (object) => {
  return object.userData;
};

// node_modules/threlte/lib/interactivity.js
var setPointerFromEvent = (ctx, e) => {
  ctx.pointer.update((v2) => {
    if (!ctx.renderer)
      return v2;
    return v2.set(e.offsetX / ctx.renderer.domElement.clientWidth * 2 - 1, -(e.offsetY / ctx.renderer.domElement.clientHeight) * 2 + 1);
  });
};
var runRaycaster = (rootCtx, pointer, camera, objects) => {
  rootCtx.raycaster.setFromCamera(pointer, camera);
  return rootCtx.raycaster.intersectObjects(objects, false);
};
var targetChanged = (a, b) => {
  if (a.object.uuid !== b.object.uuid)
    return true;
  if (a.instanceId !== b.instanceId)
    return true;
  return false;
};
var useEventRaycast = (ctx, rootCtx, renderCtx) => {
  let camera;
  const unsubscribeCamera = ctx.camera.subscribe((value) => camera = value);
  onDestroy(unsubscribeCamera);
  let pointer;
  const unsubscribePointer = ctx.pointer.subscribe((value) => pointer = value);
  onDestroy(unsubscribePointer);
  const onEvent = (e) => {
    var _a, _b;
    e.preventDefault();
    ctx.pointerOverCanvas.set(true);
    renderCtx.pointerInvalidated = true;
    setPointerFromEvent(ctx, e);
    if (rootCtx.interactiveObjects.size === 0 || rootCtx.raycastableObjects.size === 0)
      return;
    const intersects = runRaycaster(rootCtx, pointer, camera, Array.from(rootCtx.raycastableObjects));
    if (intersects.length > 0 && rootCtx.interactiveObjects.has(intersects[0].object)) {
      (_b = (_a = getThrelteUserData(intersects[0].object)).eventDispatcher) == null ? void 0 : _b.call(_a, e.type, {
        ...intersects[0],
        event: e
      });
    }
  };
  return {
    onClick: onEvent,
    onContextMenu: onEvent,
    onPointerUp: onEvent,
    onPointerDown: onEvent,
    onPointerMove: onEvent
  };
};
var useFrameloopRaycast = (ctx, rootCtx) => {
  let pointerOverCanvas = get_store_value(ctx.pointerOverCanvas);
  const unsubscribePointerOverCanvas = ctx.pointerOverCanvas.subscribe((value) => pointerOverCanvas = value);
  onDestroy(unsubscribePointerOverCanvas);
  let camera;
  const unsubscribeCamera = ctx.camera.subscribe((value) => camera = value);
  onDestroy(unsubscribeCamera);
  let pointer;
  const unsubscribePointer = ctx.pointer.subscribe((value) => pointer = value);
  onDestroy(unsubscribePointer);
  const raycast = () => {
    var _a, _b, _c, _d, _e, _f, _g, _h;
    if (rootCtx.interactiveObjects.size === 0 || rootCtx.raycastableObjects.size === 0) {
      return;
    }
    const intersects = pointerOverCanvas ? runRaycaster(rootCtx, pointer, camera, Array.from(rootCtx.raycastableObjects)) : [];
    const intersection = intersects.length && rootCtx.interactiveObjects.has(intersects[0].object) ? intersects[0] : null;
    if (!intersection) {
      if (rootCtx.lastIntersection) {
        (_b = (_a = getThrelteUserData(rootCtx.lastIntersection.object)).eventDispatcher) == null ? void 0 : _b.call(_a, "pointerleave", rootCtx.lastIntersection);
      }
    } else {
      if (!rootCtx.lastIntersection) {
        (_d = (_c = getThrelteUserData(intersection.object)).eventDispatcher) == null ? void 0 : _d.call(_c, "pointerenter", intersection);
      } else if (rootCtx.lastIntersection && targetChanged(rootCtx.lastIntersection, intersection)) {
        (_f = (_e = getThrelteUserData(rootCtx.lastIntersection.object)).eventDispatcher) == null ? void 0 : _f.call(_e, "pointerleave", rootCtx.lastIntersection);
        (_h = (_g = getThrelteUserData(intersection.object)).eventDispatcher) == null ? void 0 : _h.call(_g, "pointerenter", intersection);
      }
    }
    rootCtx.lastIntersection = intersection;
  };
  return {
    raycast
  };
};

// node_modules/threlte/lib/browser.js
var browser = typeof window !== "undefined";

// node_modules/threlte/hooks/useRaf.js
var useRaf = (cb) => {
  if (!browser)
    return;
  let handle;
  const tick2 = () => {
    cb();
    handle = requestAnimationFrame(tick2);
  };
  tick2();
  onDestroy(() => {
    if (!handle)
      return;
    cancelAnimationFrame(handle);
  });
};

// node_modules/threlte/lib/frameloop.js
var runFrameloopCallbacks = (ctx, renderCtx) => {
  if (renderCtx.frameHandlers.size === 0)
    return;
  if (renderCtx.debugFrameloop) {
    let genericFrameHandlers = 0;
    renderCtx.frameHandlers.forEach((h) => {
      if (h.debugFrameloopMessage) {
        renderCtx.invalidations[h.debugFrameloopMessage] = h.debugFrameloopMessage in renderCtx.invalidations ? renderCtx.invalidations[h.debugFrameloopMessage] + 1 : 1;
      } else {
        ++genericFrameHandlers;
      }
    });
    if (genericFrameHandlers > 0)
      renderCtx.invalidations["onFrame"] = renderCtx.frameHandlers.size;
  }
  const anyHasOrder = Array.from(renderCtx.frameHandlers).reduce((acc, h) => h.order ? true : acc, false);
  const delta = ctx.clock.getDelta();
  if (anyHasOrder) {
    Array.from(renderCtx.frameHandlers).sort((a, b) => (a.order ?? 0) > (b.order ?? 0) ? 1 : -1).forEach((h) => h.fn(ctx, delta));
  } else {
    renderCtx.frameHandlers.forEach((h) => h.fn(ctx, delta));
  }
};
var debugFrame = (renderCtx) => {
  if (!renderCtx.debugFrameloop)
    return;
  renderCtx.frame += 1;
  console.log(`frame: ${renderCtx.frame}${Object.keys(renderCtx.invalidations).length > 0 ? ", requested by â†´" : ""}`);
  if (Object.keys(renderCtx.invalidations).length > 0)
    console.table(renderCtx.invalidations);
  renderCtx.invalidations = {};
};
var useFrameloop = (ctx, rootCtx, renderCtx) => {
  let camera = get_store_value(ctx.camera);
  const unsubscribeCamera = ctx.camera.subscribe((c) => camera = c);
  onDestroy(unsubscribeCamera);
  const { raycast } = useFrameloopRaycast(ctx, rootCtx);
  useRaf(() => {
    const shouldRender = renderCtx.frameloop === "always" || renderCtx.frameloop === "demand" && (renderCtx.frameInvalidated || renderCtx.frameHandlers.size > 0) || renderCtx.frameloop === "never" && renderCtx.advance;
    const shouldRaycast = shouldRender || renderCtx.pointerInvalidated;
    if (shouldRaycast) {
      raycast();
      renderCtx.pointerInvalidated = false;
    }
    if (!shouldRender)
      return;
    if (!camera || !ctx.composer || !ctx.renderer)
      return;
    runFrameloopCallbacks(ctx, renderCtx);
    if (ctx.composer.passes.length > 1) {
      ctx.composer.render();
    } else {
      ctx.renderer.render(ctx.scene, camera);
    }
    debugFrame(renderCtx);
    renderCtx.frameInvalidated = false;
    renderCtx.advance = false;
  });
};

// node_modules/threlte/lib/defaultCamera.js
var getDefaultCamera = () => {
  const defaultCamera = new PerspectiveCamera(75, 0, 0.1, 1e3);
  getThrelteUserData(defaultCamera).threlteDefaultCamera = true;
  defaultCamera.position.z = 5;
  defaultCamera.lookAt(0, 0, 0);
  return defaultCamera;
};
var setDefaultCameraAspectOnSizeChange = (ctx) => {
  const unsubscribe = ctx.size.subscribe((size) => {
    if (getThrelteUserData(get_store_value(ctx.camera)).threlteDefaultCamera) {
      ctx.camera.update((c) => {
        const cam = c;
        cam.aspect = size.width / size.height;
        cam.updateProjectionMatrix();
        ctx.invalidate("Default camera: aspect ratio changed");
        return cam;
      });
    }
  });
  onDestroy(unsubscribe);
};

// node_modules/threlte/lib/contexts.js
var createContexts = (linear, flat, dpr, userSize, parentSize, debugFrameloop, frameloop) => {
  const audioCtx = {
    audioListeners: /* @__PURE__ */ new Map(),
    addAudioListener: (listener, id) => {
      id = id ?? "default";
      if (audioCtx.audioListeners.has(id)) {
        console.warn(`An AudioListener with the id "${id}" has already been added, aborting.`);
        return;
      }
      audioCtx.audioListeners.set(id, listener);
    },
    removeAudioListener: (id) => {
      id = id ?? "default";
      if (!audioCtx.audioListeners.has(id)) {
        console.warn(`No AudioListener with the id "${id}" found, aborting.`);
        return;
      }
      audioCtx.audioListeners.delete(id);
    },
    getAudioListener: (id) => {
      id = id ?? "default";
      if (!audioCtx.audioListeners.has(id)) {
        console.warn(`No AudioListener with the id "${id}" found, aborting.`);
        return;
      }
      return audioCtx.audioListeners.get(id);
    }
  };
  const renderCtx = {
    debugFrameloop,
    frameloop,
    frame: 0,
    frameInvalidated: true,
    pointerInvalidated: true,
    invalidations: {},
    frameHandlers: /* @__PURE__ */ new Set(),
    advance: false
  };
  const ctx = {
    size: derived([userSize, parentSize], ([uSize, pSize]) => {
      return uSize ? uSize : pSize;
    }),
    pointer: writable(new Vector2()),
    pointerOverCanvas: writable(false),
    clock: new Clock(),
    camera: writable(getDefaultCamera()),
    scene: new Scene(),
    renderer: void 0,
    composer: void 0,
    invalidate: (debugFrameloopMessage) => {
      renderCtx.frameInvalidated = true;
      if (renderCtx.debugFrameloop && debugFrameloopMessage) {
        renderCtx.invalidations[debugFrameloopMessage] = renderCtx.invalidations[debugFrameloopMessage] ? renderCtx.invalidations[debugFrameloopMessage] + 1 : 1;
      }
    },
    advance: () => {
      renderCtx.advance = true;
    }
  };
  const rootCtx = {
    flat: writable(flat),
    linear: writable(linear),
    dpr: writable(dpr),
    setCamera: (camera) => {
      ctx.camera.set(camera);
      if (!ctx.composer)
        return;
      ctx.composer.passes.forEach((pass) => {
        if (pass instanceof RenderPass) {
          pass.camera = camera;
        }
      });
      ctx.invalidate("Canvas: setting camera");
    },
    raycastableObjects: /* @__PURE__ */ new Set(),
    interactiveObjects: /* @__PURE__ */ new Set(),
    raycaster: new Raycaster(),
    lastIntersection: null,
    addRaycastableObject: (object) => {
      rootCtx.raycastableObjects.add(object);
    },
    removeRaycastableObject: (object) => {
      rootCtx.raycastableObjects.delete(object);
    },
    addInteractiveObject: (object) => {
      rootCtx.interactiveObjects.add(object);
    },
    removeInteractiveObject: (object) => {
      rootCtx.interactiveObjects.delete(object);
    },
    addPass: (pass) => {
      if (!ctx.composer)
        return;
      ctx.composer.addPass(pass);
      ctx.invalidate("Canvas: adding pass");
    },
    removePass: (pass) => {
      if (!ctx.composer)
        return;
      ctx.composer.removePass(pass);
      ctx.invalidate("Canvas: removing pass");
    }
  };
  setContext("threlte", ctx);
  setContext("threlte-root", rootCtx);
  setContext("threlte-render-context", renderCtx);
  setContext("threlte-audio-context", audioCtx);
  const getCtx = () => ctx;
  const getRootCtx = () => rootCtx;
  const getRenderCtx = () => renderCtx;
  const getAudioCtx = () => audioCtx;
  return {
    ctx,
    rootCtx,
    renderCtx,
    audioCtx,
    getCtx,
    getRootCtx,
    getRenderCtx,
    getAudioCtx
  };
};

// node_modules/threlte/hooks/useParentSize.js
var useParentSize = () => {
  const parentSizeStore = writable({ width: 0, height: 0 });
  let parentSize = { width: 0, height: 0 };
  const unsubscribeParentSize = parentSizeStore.subscribe((s) => parentSize = s);
  onDestroy(unsubscribeParentSize);
  let el;
  const proxy = () => {
    const currentParentSize = parentSize;
    if (!el)
      return;
    if (!el.parentElement)
      return;
    const { clientWidth, clientHeight } = el.parentElement;
    if (clientWidth !== currentParentSize.width || clientHeight !== currentParentSize.height) {
      parentSizeStore.set({
        width: clientWidth,
        height: clientHeight
      });
    }
  };
  const parentSizeAction = (node) => {
    el = node;
    proxy();
    window.addEventListener("resize", proxy);
  };
  if (!browser) {
    return {
      parentSize: parentSizeStore,
      parentSizeAction
    };
  }
  onDestroy(() => {
    window.removeEventListener("resize", proxy);
  });
  return {
    parentSizeAction,
    parentSize: parentSizeStore
  };
};

// node_modules/threlte/Canvas.svelte
var file = "node_modules/threlte/Canvas.svelte";
function add_css(target) {
  append_styles(target, "svelte-15bl8wt", "canvas.svelte-15bl8wt{display:block}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiQ2FudmFzLnN2ZWx0ZSIsIm1hcHBpbmdzIjoiQUFtRkUscUJBQU8sQ0FDTCxPQUFPLENBQUUsS0FDWCIsIm5hbWVzIjpbXSwic291cmNlcyI6WyJDYW52YXMuc3ZlbHRlIl19 */");
}
function create_if_block(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[30].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[29],
    null
  );
  const block = {
    c: function create() {
      if (default_slot)
        default_slot.c();
    },
    l: function claim(nodes) {
      if (default_slot)
        default_slot.l(nodes);
    },
    m: function mount(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty[0] & /*$$scope*/
        536870912)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[29],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[29]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[29],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block.name,
    type: "if",
    source: "(78:2) {#if initialized}",
    ctx
  });
  return block;
}
function create_fragment(ctx) {
  let canvas_1;
  let parentSizeAction_action;
  let current;
  let mounted;
  let dispose;
  let if_block = (
    /*initialized*/
    ctx[1] && create_if_block(ctx)
  );
  const block = {
    c: function create() {
      canvas_1 = element("canvas");
      if (if_block)
        if_block.c();
      this.h();
    },
    l: function claim(nodes) {
      canvas_1 = claim_element(nodes, "CANVAS", { class: true });
      var canvas_1_nodes = children(canvas_1);
      if (if_block)
        if_block.l(canvas_1_nodes);
      canvas_1_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(canvas_1, "class", "svelte-15bl8wt");
      add_location(canvas_1, file, 66, 0, 2816);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, canvas_1, anchor);
      if (if_block)
        if_block.m(canvas_1, null);
      ctx[31](canvas_1);
      current = true;
      if (!mounted) {
        dispose = [
          action_destroyer(parentSizeAction_action = /*parentSizeAction*/
          ctx[2].call(null, canvas_1)),
          listen_dev(
            canvas_1,
            "click",
            /*onClick*/
            ctx[8],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            canvas_1,
            "contextmenu",
            /*onContextMenu*/
            ctx[9],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            canvas_1,
            "pointerup",
            /*onPointerUp*/
            ctx[12],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            canvas_1,
            "pointerdown",
            /*onPointerDown*/
            ctx[10],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            canvas_1,
            "pointermove",
            /*onPointerMove*/
            ctx[11],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            canvas_1,
            "pointerenter",
            /*pointerenter_handler*/
            ctx[32],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            canvas_1,
            "pointerleave",
            /*pointerleave_handler*/
            ctx[33],
            false,
            false,
            false,
            false
          )
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, dirty) {
      if (
        /*initialized*/
        ctx2[1]
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty[0] & /*initialized*/
          2) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(canvas_1, null);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(canvas_1);
      if (if_block)
        if_block.d();
      ctx[31](null);
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
var invalidationHandlers = /* @__PURE__ */ new Set();
var invalidateGlobally = (debugFrameloopMessage) => {
  invalidationHandlers.forEach((fn) => fn(debugFrameloopMessage));
};
function instance($$self, $$props, $$invalidate) {
  let $dprStore;
  let $derivedSize;
  let $flatStore;
  let $linearStore;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Canvas", slots, ["default"]);
  let { dpr = browser ? window.devicePixelRatio : 1 } = $$props;
  let { flat = false } = $$props;
  let { linear = false } = $$props;
  let { frameloop = "demand" } = $$props;
  let { debugFrameloop = false } = $$props;
  let { shadows = true } = $$props;
  let { shadowMapType = PCFSoftShadowMap } = $$props;
  let { size = void 0 } = $$props;
  let { rendererParameters = void 0 } = $$props;
  let canvas;
  let initialized = false;
  const userSize = writable(size);
  const { parentSize, parentSizeAction } = useParentSize();
  const contexts = createContexts(linear, flat, dpr, userSize, parentSize, debugFrameloop, frameloop);
  const { getCtx, getRootCtx, getRenderCtx, renderCtx } = contexts;
  const { ctx, rootCtx, audioCtx } = contexts;
  setDefaultCameraAspectOnSizeChange(ctx);
  invalidationHandlers.add(ctx.invalidate);
  onDestroy(() => {
    invalidationHandlers.delete(ctx.invalidate);
  });
  const { size: derivedSize, scene } = ctx;
  validate_store(derivedSize, "derivedSize");
  component_subscribe($$self, derivedSize, (value) => $$invalidate(26, $derivedSize = value));
  const { flat: flatStore, linear: linearStore, dpr: dprStore } = rootCtx;
  validate_store(flatStore, "flatStore");
  component_subscribe($$self, flatStore, (value) => $$invalidate(27, $flatStore = value));
  validate_store(linearStore, "linearStore");
  component_subscribe($$self, linearStore, (value) => $$invalidate(28, $linearStore = value));
  validate_store(dprStore, "dprStore");
  component_subscribe($$self, dprStore, (value) => $$invalidate(25, $dprStore = value));
  setContext("threlte-parent", writable(scene));
  onMount(() => {
    if (!canvas)
      return;
    createRendererAndComposer(ctx, canvas, rendererParameters);
    setRendererColorOutput(ctx, $linearStore, $flatStore);
    setRendererAndComposerSize(ctx, $derivedSize, $dprStore);
    setRendererShadows(ctx, shadows, shadowMapType);
    $$invalidate(1, initialized = true);
  });
  useFrameloop(ctx, rootCtx, renderCtx);
  const { onClick, onContextMenu, onPointerDown: onPointerDown2, onPointerMove: onPointerMove2, onPointerUp: onPointerUp2 } = useEventRaycast(ctx, rootCtx, renderCtx);
  const writable_props = [
    "dpr",
    "flat",
    "linear",
    "frameloop",
    "debugFrameloop",
    "shadows",
    "shadowMapType",
    "size",
    "rendererParameters"
  ];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<Canvas> was created with unknown prop '${key}'`);
  });
  function canvas_1_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      canvas = $$value;
      $$invalidate(0, canvas);
    });
  }
  const pointerenter_handler = () => getCtx().pointerOverCanvas.set(true);
  const pointerleave_handler = () => getCtx().pointerOverCanvas.set(false);
  $$self.$$set = ($$props2) => {
    if ("dpr" in $$props2)
      $$invalidate(13, dpr = $$props2.dpr);
    if ("flat" in $$props2)
      $$invalidate(14, flat = $$props2.flat);
    if ("linear" in $$props2)
      $$invalidate(15, linear = $$props2.linear);
    if ("frameloop" in $$props2)
      $$invalidate(16, frameloop = $$props2.frameloop);
    if ("debugFrameloop" in $$props2)
      $$invalidate(17, debugFrameloop = $$props2.debugFrameloop);
    if ("shadows" in $$props2)
      $$invalidate(18, shadows = $$props2.shadows);
    if ("shadowMapType" in $$props2)
      $$invalidate(19, shadowMapType = $$props2.shadowMapType);
    if ("size" in $$props2)
      $$invalidate(20, size = $$props2.size);
    if ("rendererParameters" in $$props2)
      $$invalidate(21, rendererParameters = $$props2.rendererParameters);
    if ("$$scope" in $$props2)
      $$invalidate(29, $$scope = $$props2.$$scope);
  };
  $$self.$capture_state = () => ({
    onDestroy,
    onMount,
    setContext,
    writable,
    PCFSoftShadowMap,
    useParentSize,
    browser,
    createContexts,
    setDefaultCameraAspectOnSizeChange,
    useFrameloop,
    useEventRaycast,
    createRendererAndComposer,
    setRendererAndComposerSize,
    setRendererColorOutput,
    setRendererShadows,
    invalidationHandlers,
    invalidateGlobally,
    dpr,
    flat,
    linear,
    frameloop,
    debugFrameloop,
    shadows,
    shadowMapType,
    size,
    rendererParameters,
    canvas,
    initialized,
    userSize,
    parentSize,
    parentSizeAction,
    contexts,
    getCtx,
    getRootCtx,
    getRenderCtx,
    renderCtx,
    ctx,
    rootCtx,
    audioCtx,
    derivedSize,
    scene,
    flatStore,
    linearStore,
    dprStore,
    onClick,
    onContextMenu,
    onPointerDown: onPointerDown2,
    onPointerMove: onPointerMove2,
    onPointerUp: onPointerUp2,
    $dprStore,
    $derivedSize,
    $flatStore,
    $linearStore
  });
  $$self.$inject_state = ($$props2) => {
    if ("dpr" in $$props2)
      $$invalidate(13, dpr = $$props2.dpr);
    if ("flat" in $$props2)
      $$invalidate(14, flat = $$props2.flat);
    if ("linear" in $$props2)
      $$invalidate(15, linear = $$props2.linear);
    if ("frameloop" in $$props2)
      $$invalidate(16, frameloop = $$props2.frameloop);
    if ("debugFrameloop" in $$props2)
      $$invalidate(17, debugFrameloop = $$props2.debugFrameloop);
    if ("shadows" in $$props2)
      $$invalidate(18, shadows = $$props2.shadows);
    if ("shadowMapType" in $$props2)
      $$invalidate(19, shadowMapType = $$props2.shadowMapType);
    if ("size" in $$props2)
      $$invalidate(20, size = $$props2.size);
    if ("rendererParameters" in $$props2)
      $$invalidate(21, rendererParameters = $$props2.rendererParameters);
    if ("canvas" in $$props2)
      $$invalidate(0, canvas = $$props2.canvas);
    if ("initialized" in $$props2)
      $$invalidate(1, initialized = $$props2.initialized);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty[0] & /*size*/
    1048576) {
      $:
        userSize.set(size);
    }
    if ($$self.$$.dirty[0] & /*linear*/
    32768) {
      $:
        set_store_value(linearStore, $linearStore = linear, $linearStore);
    }
    if ($$self.$$.dirty[0] & /*flat*/
    16384) {
      $:
        set_store_value(flatStore, $flatStore = flat, $flatStore);
    }
    if ($$self.$$.dirty[0] & /*dpr*/
    8192) {
      $:
        set_store_value(dprStore, $dprStore = dpr, $dprStore);
    }
    if ($$self.$$.dirty[0] & /*$linearStore, $flatStore*/
    402653184) {
      $:
        setRendererColorOutput(getCtx(), $linearStore, $flatStore);
    }
    if ($$self.$$.dirty[0] & /*$derivedSize, $dprStore*/
    100663296) {
      $:
        setRendererAndComposerSize(getCtx(), $derivedSize, $dprStore);
    }
    if ($$self.$$.dirty[0] & /*shadows, shadowMapType*/
    786432) {
      $:
        setRendererShadows(getCtx(), shadows, shadowMapType);
    }
  };
  return [
    canvas,
    initialized,
    parentSizeAction,
    getCtx,
    derivedSize,
    flatStore,
    linearStore,
    dprStore,
    onClick,
    onContextMenu,
    onPointerDown2,
    onPointerMove2,
    onPointerUp2,
    dpr,
    flat,
    linear,
    frameloop,
    debugFrameloop,
    shadows,
    shadowMapType,
    size,
    rendererParameters,
    ctx,
    rootCtx,
    audioCtx,
    $dprStore,
    $derivedSize,
    $flatStore,
    $linearStore,
    $$scope,
    slots,
    canvas_1_binding,
    pointerenter_handler,
    pointerleave_handler
  ];
}
var Canvas = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(
      this,
      options,
      instance,
      create_fragment,
      safe_not_equal,
      {
        dpr: 13,
        flat: 14,
        linear: 15,
        frameloop: 16,
        debugFrameloop: 17,
        shadows: 18,
        shadowMapType: 19,
        size: 20,
        rendererParameters: 21,
        ctx: 22,
        rootCtx: 23,
        audioCtx: 24
      },
      add_css,
      [-1, -1]
    );
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Canvas",
      options,
      id: create_fragment.name
    });
  }
  get dpr() {
    throw new Error("<Canvas>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set dpr(value) {
    throw new Error("<Canvas>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get flat() {
    throw new Error("<Canvas>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set flat(value) {
    throw new Error("<Canvas>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get linear() {
    throw new Error("<Canvas>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set linear(value) {
    throw new Error("<Canvas>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get frameloop() {
    throw new Error("<Canvas>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set frameloop(value) {
    throw new Error("<Canvas>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get debugFrameloop() {
    throw new Error("<Canvas>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set debugFrameloop(value) {
    throw new Error("<Canvas>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get shadows() {
    throw new Error("<Canvas>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set shadows(value) {
    throw new Error("<Canvas>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get shadowMapType() {
    throw new Error("<Canvas>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set shadowMapType(value) {
    throw new Error("<Canvas>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get size() {
    throw new Error("<Canvas>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set size(value) {
    throw new Error("<Canvas>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get rendererParameters() {
    throw new Error("<Canvas>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set rendererParameters(value) {
    throw new Error("<Canvas>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get ctx() {
    return this.$$.ctx[22];
  }
  set ctx(value) {
    throw new Error("<Canvas>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get rootCtx() {
    return this.$$.ctx[23];
  }
  set rootCtx(value) {
    throw new Error("<Canvas>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get audioCtx() {
    return this.$$.ctx[24];
  }
  set audioCtx(value) {
    throw new Error("<Canvas>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Canvas_default = Canvas;

// node_modules/threlte/hooks/useThrelte.js
var useThrelte = () => {
  return getContext("threlte");
};

// node_modules/threlte/hooks/useThrelteRoot.js
var useThrelteRoot = () => {
  return getContext("threlte-root");
};

// node_modules/threlte/lib/createObjectStore.js
var createObjectStore = (object) => {
  const objectStore = writable(object);
  let unwrappedObject = object;
  const unsubscribeObjectStore = objectStore.subscribe((o) => unwrappedObject = o);
  onDestroy(unsubscribeObjectStore);
  const set = (newObject) => {
    if (newObject.uuid === unwrappedObject.uuid)
      return;
    objectStore.set(newObject);
  };
  return {
    ...objectStore,
    set
  };
};

// node_modules/threlte/internal/HierarchicalObject.svelte
function create_fragment2(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[8].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[7],
    null
  );
  const block = {
    c: function create() {
      if (default_slot)
        default_slot.c();
    },
    l: function claim(nodes) {
      if (default_slot)
        default_slot.l(nodes);
    },
    m: function mount(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        128)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[7],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[7]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[7],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment2.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
var setParent = (objectStore) => {
  setContext("threlte-parent", objectStore);
};
var getParent = () => {
  return getContext("threlte-parent");
};
function instance2($$self, $$props, $$invalidate) {
  let $currentObject;
  let $currentParent;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("HierarchicalObject", slots, ["default"]);
  const currentParent = getParent();
  validate_store(currentParent, "currentParent");
  component_subscribe($$self, currentParent, (value) => $$invalidate(6, $currentParent = value));
  let previousParent = $currentParent;
  let { object } = $$props;
  const currentObject = writable(object);
  validate_store(currentObject, "currentObject");
  component_subscribe($$self, currentObject, (value) => $$invalidate(5, $currentObject = value));
  let previousObject = object;
  setParent(currentObject);
  const { invalidate } = useThrelte();
  $currentParent.add($currentObject);
  invalidate("HierarchicalObject: object added");
  onDestroy(() => {
    $currentParent.remove($currentObject);
    invalidate("HierarchicalObject: object removed");
  });
  $$self.$$.on_mount.push(function() {
    if (object === void 0 && !("object" in $$props || $$self.$$.bound[$$self.$$.props["object"]])) {
      console.warn("<HierarchicalObject> was created without expected prop 'object'");
    }
  });
  const writable_props = ["object"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<HierarchicalObject> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("object" in $$props2)
      $$invalidate(2, object = $$props2.object);
    if ("$$scope" in $$props2)
      $$invalidate(7, $$scope = $$props2.$$scope);
  };
  $$self.$capture_state = () => ({
    getContext,
    onDestroy,
    setContext,
    writable,
    useThrelte,
    setParent,
    getParent,
    currentParent,
    previousParent,
    object,
    currentObject,
    previousObject,
    invalidate,
    $currentObject,
    $currentParent
  });
  $$self.$inject_state = ($$props2) => {
    if ("previousParent" in $$props2)
      $$invalidate(3, previousParent = $$props2.previousParent);
    if ("object" in $$props2)
      $$invalidate(2, object = $$props2.object);
    if ("previousObject" in $$props2)
      $$invalidate(4, previousObject = $$props2.previousObject);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*object*/
    4) {
      $:
        set_store_value(currentObject, $currentObject = object, $currentObject);
    }
    if ($$self.$$.dirty & /*$currentObject, previousObject, $currentParent*/
    112) {
      $: {
        if ($currentObject !== previousObject) {
          if (previousObject) {
            $currentParent.remove(previousObject);
          }
          $currentParent.add($currentObject);
          invalidate(`HierarchicalObject: object changed`);
          $$invalidate(4, previousObject = $currentObject);
        }
      }
    }
    if ($$self.$$.dirty & /*$currentParent, previousParent, $currentObject*/
    104) {
      $: {
        if ($currentParent !== previousParent) {
          previousParent.remove($currentObject);
          $currentParent.add($currentObject);
          invalidate(`HierarchicalObject: parent changed`);
          $$invalidate(3, previousParent = $currentParent);
        }
      }
    }
  };
  return [
    currentParent,
    currentObject,
    object,
    previousParent,
    previousObject,
    $currentObject,
    $currentParent,
    $$scope,
    slots
  ];
}
var HierarchicalObject = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance2, create_fragment2, safe_not_equal, { object: 2 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "HierarchicalObject",
      options,
      id: create_fragment2.name
    });
  }
  get object() {
    throw new Error("<HierarchicalObject>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set object(value) {
    throw new Error("<HierarchicalObject>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var HierarchicalObject_default = HierarchicalObject;

// node_modules/threlte/internal/LayerableObject.svelte
function create_fragment3(ctx) {
  const block = {
    c: noop,
    l: noop,
    m: noop,
    p: noop,
    i: noop,
    o: noop,
    d: noop
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment3.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance3($$self, $$props, $$invalidate) {
  let $layers;
  let $objectStore;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("LayerableObject", slots, []);
  let { object } = $$props;
  const objectStore = createObjectStore(object);
  validate_store(objectStore, "objectStore");
  component_subscribe($$self, objectStore, (value) => $$invalidate(4, $objectStore = value));
  const layers = getContext("threlte-layers");
  validate_store(layers, "layers");
  component_subscribe($$self, layers, (value) => $$invalidate(3, $layers = value));
  const { invalidate } = useThrelte();
  $$self.$$.on_mount.push(function() {
    if (object === void 0 && !("object" in $$props || $$self.$$.bound[$$self.$$.props["object"]])) {
      console.warn("<LayerableObject> was created without expected prop 'object'");
    }
  });
  const writable_props = ["object"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<LayerableObject> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("object" in $$props2)
      $$invalidate(2, object = $$props2.object);
  };
  $$self.$capture_state = () => ({
    getContext,
    useThrelte,
    createObjectStore,
    object,
    objectStore,
    layers,
    invalidate,
    $layers,
    $objectStore
  });
  $$self.$inject_state = ($$props2) => {
    if ("object" in $$props2)
      $$invalidate(2, object = $$props2.object);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*object*/
    4) {
      $:
        objectStore.set(object);
    }
    if ($$self.$$.dirty & /*$layers, $objectStore*/
    24) {
      $: {
        if ($layers === "all") {
          $objectStore.layers.enableAll();
        } else if ($layers === "none") {
          $objectStore.layers.disableAll();
        } else if (Array.isArray($layers)) {
          for (let index = 0; index < 32; index += 1) {
            const layerIndex = index;
            const enabled = $layers.includes(layerIndex);
            if (enabled) {
              $objectStore.layers.enable(index);
            } else {
              $objectStore.layers.disable(index);
            }
          }
        } else if ($layers !== void 0) {
          $objectStore.layers.set($layers);
        }
        invalidate("LayerableObject");
      }
    }
  };
  return [objectStore, layers, object, $layers, $objectStore];
}
var LayerableObject = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance3, create_fragment3, safe_not_equal, { object: 2 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "LayerableObject",
      options,
      id: create_fragment3.name
    });
  }
  get object() {
    throw new Error("<LayerableObject>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set object(value) {
    throw new Error("<LayerableObject>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var LayerableObject_default = LayerableObject;

// node_modules/threlte/hooks/useFrame.js
var useFrame = (fn, options) => {
  if (!browser) {
    return {
      start: () => void 0,
      stop: () => void 0,
      started: readable(false)
    };
  }
  const renderCtx = getContext("threlte-render-context");
  const handler = {
    fn,
    order: options == null ? void 0 : options.order,
    debugFrameloopMessage: options == null ? void 0 : options.debugFrameloopMessage
  };
  const started = writable(false);
  const stop = () => {
    renderCtx.frameHandlers.delete(handler);
    started.set(false);
  };
  const start = () => {
    renderCtx.frameHandlers.add(handler);
    started.set(true);
  };
  if ((options == null ? void 0 : options.autostart) ?? true) {
    start();
  }
  onDestroy(() => {
    stop();
  });
  return {
    start,
    stop,
    started: {
      subscribe: started.subscribe
    }
  };
};

// node_modules/threlte/lib/useTicked.js
var useTicked = () => {
  const ticked = writable(false);
  const init2 = async () => {
    await tick();
    ticked.set(true);
  };
  init2();
  return ticked;
};

// node_modules/threlte/internal/TransformableObject.svelte
function create_fragment4(ctx) {
  const block = {
    c: noop,
    l: noop,
    m: noop,
    p: noop,
    i: noop,
    o: noop,
    d: noop
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment4.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance4($$self, $$props, $$invalidate) {
  let $objectStore;
  let $ticked;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("TransformableObject", slots, []);
  let { object } = $$props;
  let { position = void 0 } = $$props;
  let { scale = void 0 } = $$props;
  let { rotation = void 0 } = $$props;
  let { lookAt = void 0 } = $$props;
  const targetWorldPos = new Vector3();
  const dispatch = createEventDispatcher();
  const { invalidate } = useThrelte();
  const ticked = useTicked();
  validate_store(ticked, "ticked");
  component_subscribe($$self, ticked, (value) => $$invalidate(8, $ticked = value));
  const dispatchTransform = async () => {
    if (!$ticked)
      await tick();
    dispatch("transform");
  };
  const onTransform = async () => {
    invalidate("TransformableObject: transformed");
    await dispatchTransform();
  };
  getThrelteUserData(object).onTransform = onTransform;
  const { start: startLookingAt, stop: stopLookingAt } = useFrame(
    async () => {
      if (lookAt && !rotation && lookAt instanceof Object3D) {
        lookAt.getWorldPosition(targetWorldPos);
        object.lookAt(targetWorldPos);
        await dispatchTransform();
      }
    },
    {
      autostart: false,
      debugFrameloopMessage: "TransformableObject: tracking object"
    }
  );
  const objectStore = createObjectStore(object);
  validate_store(objectStore, "objectStore");
  component_subscribe($$self, objectStore, (value) => $$invalidate(7, $objectStore = value));
  $$self.$$.on_mount.push(function() {
    if (object === void 0 && !("object" in $$props || $$self.$$.bound[$$self.$$.props["object"]])) {
      console.warn("<TransformableObject> was created without expected prop 'object'");
    }
  });
  const writable_props = ["object", "position", "scale", "rotation", "lookAt"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<TransformableObject> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("object" in $$props2)
      $$invalidate(2, object = $$props2.object);
    if ("position" in $$props2)
      $$invalidate(3, position = $$props2.position);
    if ("scale" in $$props2)
      $$invalidate(4, scale = $$props2.scale);
    if ("rotation" in $$props2)
      $$invalidate(5, rotation = $$props2.rotation);
    if ("lookAt" in $$props2)
      $$invalidate(6, lookAt = $$props2.lookAt);
  };
  $$self.$capture_state = () => ({
    createEventDispatcher,
    tick,
    Object3D,
    Vector3,
    useFrame,
    useThrelte,
    createObjectStore,
    getThrelteUserData,
    useTicked,
    object,
    position,
    scale,
    rotation,
    lookAt,
    targetWorldPos,
    dispatch,
    invalidate,
    ticked,
    dispatchTransform,
    onTransform,
    startLookingAt,
    stopLookingAt,
    objectStore,
    $objectStore,
    $ticked
  });
  $$self.$inject_state = ($$props2) => {
    if ("object" in $$props2)
      $$invalidate(2, object = $$props2.object);
    if ("position" in $$props2)
      $$invalidate(3, position = $$props2.position);
    if ("scale" in $$props2)
      $$invalidate(4, scale = $$props2.scale);
    if ("rotation" in $$props2)
      $$invalidate(5, rotation = $$props2.rotation);
    if ("lookAt" in $$props2)
      $$invalidate(6, lookAt = $$props2.lookAt);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*object*/
    4) {
      $:
        objectStore.set(object);
    }
    if ($$self.$$.dirty & /*position, $objectStore, lookAt, rotation*/
    232) {
      $: {
        if (position) {
          $objectStore.position.set(position.x ?? 0, position.y ?? 0, position.z ?? 0);
          onTransform();
        }
        if (lookAt && !rotation) {
          if (lookAt instanceof Object3D) {
            startLookingAt();
          } else {
            stopLookingAt();
            $objectStore.lookAt(lookAt.x ?? 0, lookAt.y ?? 0, lookAt.z ?? 0);
            onTransform();
          }
        }
        if (!lookAt) {
          stopLookingAt();
        }
      }
    }
    if ($$self.$$.dirty & /*scale, $objectStore*/
    144) {
      $: {
        if (scale) {
          if (typeof scale === "number") {
            $objectStore.scale.set(scale, scale, scale);
          } else {
            $objectStore.scale.set(scale.x ?? 1, scale.y ?? 1, scale.z ?? 1);
          }
          onTransform();
        }
      }
    }
    if ($$self.$$.dirty & /*rotation, $objectStore*/
    160) {
      $: {
        if (rotation) {
          $objectStore.rotation.set(rotation.x ?? 0, rotation.y ?? 0, rotation.z ?? 0, rotation.order ?? "XYZ");
          onTransform();
        }
      }
    }
  };
  return [ticked, objectStore, object, position, scale, rotation, lookAt, $objectStore];
}
var TransformableObject = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance4, create_fragment4, safe_not_equal, {
      object: 2,
      position: 3,
      scale: 4,
      rotation: 5,
      lookAt: 6
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "TransformableObject",
      options,
      id: create_fragment4.name
    });
  }
  get object() {
    throw new Error("<TransformableObject>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set object(value) {
    throw new Error("<TransformableObject>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get position() {
    throw new Error("<TransformableObject>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set position(value) {
    throw new Error("<TransformableObject>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get scale() {
    throw new Error("<TransformableObject>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set scale(value) {
    throw new Error("<TransformableObject>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get rotation() {
    throw new Error("<TransformableObject>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set rotation(value) {
    throw new Error("<TransformableObject>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get lookAt() {
    throw new Error("<TransformableObject>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set lookAt(value) {
    throw new Error("<TransformableObject>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var TransformableObject_default = TransformableObject;

// node_modules/threlte/internal/ViewportAwareObject.svelte
function create_fragment5(ctx) {
  const block = {
    c: noop,
    l: noop,
    m: noop,
    p: noop,
    i: noop,
    o: noop,
    d: noop
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment5.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance5($$self, $$props, $$invalidate) {
  let $started;
  let $ticked;
  let $camera;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("ViewportAwareObject", slots, []);
  let { object } = $$props;
  let { viewportAware = false } = $$props;
  const dispatch = createEventDispatcher();
  const { camera, invalidate } = useThrelte();
  validate_store(camera, "camera");
  component_subscribe($$self, camera, (value) => $$invalidate(8, $camera = value));
  const frustum = new Frustum();
  const projScreenMatrix = new Matrix4();
  const objectIsMesh = (objOrMesh) => {
    return objOrMesh.type === "Mesh";
  };
  const v3World = new Vector3();
  const checkInViewport = () => {
    if (!$camera)
      return true;
    projScreenMatrix.multiplyMatrices($camera.projectionMatrix, $camera.matrixWorldInverse);
    frustum.setFromProjectionMatrix(projScreenMatrix);
    if (objectIsMesh(object)) {
      return frustum.intersectsObject(object);
    } else {
      object.getWorldPosition(v3World);
      return frustum.containsPoint(v3World);
    }
  };
  const ticked = useTicked();
  validate_store(ticked, "ticked");
  component_subscribe($$self, ticked, (value) => $$invalidate(7, $ticked = value));
  let { inViewport = checkInViewport() } = $$props;
  const dispatchEvent = async (isInViewport) => {
    if (isInViewport) {
      if (!$ticked)
        await tick();
      dispatch("viewportenter", object);
    } else {
      if (!$ticked)
        await tick();
      dispatch("viewportleave", object);
    }
  };
  const { start, stop, started } = useFrame(
    () => {
      const v = checkInViewport();
      if (inViewport === void 0) {
        $$invalidate(3, inViewport = checkInViewport());
        dispatchEvent(inViewport);
      } else if (v !== inViewport) {
        dispatchEvent(v);
        $$invalidate(3, inViewport = v);
      }
    },
    {
      autostart: viewportAware,
      debugFrameloopMessage: "ViewportAwareObject: tracking viewport visibility"
    }
  );
  validate_store(started, "started");
  component_subscribe($$self, started, (value) => $$invalidate(6, $started = value));
  invalidate("ViewportAwareObject");
  $$self.$$.on_mount.push(function() {
    if (object === void 0 && !("object" in $$props || $$self.$$.bound[$$self.$$.props["object"]])) {
      console.warn("<ViewportAwareObject> was created without expected prop 'object'");
    }
  });
  const writable_props = ["object", "viewportAware", "inViewport"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<ViewportAwareObject> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("object" in $$props2)
      $$invalidate(4, object = $$props2.object);
    if ("viewportAware" in $$props2)
      $$invalidate(5, viewportAware = $$props2.viewportAware);
    if ("inViewport" in $$props2)
      $$invalidate(3, inViewport = $$props2.inViewport);
  };
  $$self.$capture_state = () => ({
    useTicked,
    createEventDispatcher,
    tick,
    Frustum,
    Matrix4,
    Mesh,
    Object3D,
    Vector3,
    useFrame,
    useThrelte,
    object,
    viewportAware,
    dispatch,
    camera,
    invalidate,
    frustum,
    projScreenMatrix,
    objectIsMesh,
    v3World,
    checkInViewport,
    ticked,
    inViewport,
    dispatchEvent,
    start,
    stop,
    started,
    $started,
    $ticked,
    $camera
  });
  $$self.$inject_state = ($$props2) => {
    if ("object" in $$props2)
      $$invalidate(4, object = $$props2.object);
    if ("viewportAware" in $$props2)
      $$invalidate(5, viewportAware = $$props2.viewportAware);
    if ("inViewport" in $$props2)
      $$invalidate(3, inViewport = $$props2.inViewport);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*viewportAware, $started*/
    96) {
      $:
        if (viewportAware && !$started) {
          start();
        } else if (!viewportAware && $started) {
          stop();
        }
    }
  };
  return [camera, ticked, started, inViewport, object, viewportAware, $started];
}
var ViewportAwareObject = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance5, create_fragment5, safe_not_equal, {
      object: 4,
      viewportAware: 5,
      inViewport: 3
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "ViewportAwareObject",
      options,
      id: create_fragment5.name
    });
  }
  get object() {
    throw new Error("<ViewportAwareObject>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set object(value) {
    throw new Error("<ViewportAwareObject>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get viewportAware() {
    throw new Error("<ViewportAwareObject>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set viewportAware(value) {
    throw new Error("<ViewportAwareObject>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get inViewport() {
    throw new Error("<ViewportAwareObject>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set inViewport(value) {
    throw new Error("<ViewportAwareObject>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var ViewportAwareObject_default = ViewportAwareObject;

// node_modules/threlte/instances/Object3DInstance.svelte
function create_default_slot(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[12].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[16],
    null
  );
  const block = {
    c: function create() {
      if (default_slot)
        default_slot.c();
    },
    l: function claim(nodes) {
      if (default_slot)
        default_slot.l(nodes);
    },
    m: function mount(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        65536)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[16],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[16]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[16],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot.name,
    type: "slot",
    source: "(39:0) <HierarchicalObject {object}>",
    ctx
  });
  return block;
}
function create_fragment6(ctx) {
  let layerableobject;
  let t0;
  let transformableobject;
  let t1;
  let hierarchicalobject;
  let t2;
  let viewportawareobject;
  let updating_inViewport;
  let current;
  layerableobject = new LayerableObject_default({
    props: { object: (
      /*object*/
      ctx[1]
    ) },
    $$inline: true
  });
  transformableobject = new TransformableObject_default({
    props: {
      object: (
        /*object*/
        ctx[1]
      ),
      position: (
        /*position*/
        ctx[2]
      ),
      rotation: (
        /*rotation*/
        ctx[4]
      ),
      scale: (
        /*scale*/
        ctx[3]
      ),
      lookAt: (
        /*lookAt*/
        ctx[5]
      )
    },
    $$inline: true
  });
  hierarchicalobject = new HierarchicalObject_default({
    props: {
      object: (
        /*object*/
        ctx[1]
      ),
      $$slots: { default: [create_default_slot] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  function viewportawareobject_inViewport_binding(value) {
    ctx[13](value);
  }
  let viewportawareobject_props = {
    object: (
      /*object*/
      ctx[1]
    ),
    viewportAware: (
      /*viewportAware*/
      ctx[6]
    )
  };
  if (
    /*inViewport*/
    ctx[0] !== void 0
  ) {
    viewportawareobject_props.inViewport = /*inViewport*/
    ctx[0];
  }
  viewportawareobject = new ViewportAwareObject_default({
    props: viewportawareobject_props,
    $$inline: true
  });
  binding_callbacks.push(() => bind(viewportawareobject, "inViewport", viewportawareobject_inViewport_binding));
  viewportawareobject.$on(
    "viewportenter",
    /*viewportenter_handler*/
    ctx[14]
  );
  viewportawareobject.$on(
    "viewportleave",
    /*viewportleave_handler*/
    ctx[15]
  );
  const block = {
    c: function create() {
      create_component(layerableobject.$$.fragment);
      t0 = space();
      create_component(transformableobject.$$.fragment);
      t1 = space();
      create_component(hierarchicalobject.$$.fragment);
      t2 = space();
      create_component(viewportawareobject.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(layerableobject.$$.fragment, nodes);
      t0 = claim_space(nodes);
      claim_component(transformableobject.$$.fragment, nodes);
      t1 = claim_space(nodes);
      claim_component(hierarchicalobject.$$.fragment, nodes);
      t2 = claim_space(nodes);
      claim_component(viewportawareobject.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(layerableobject, target, anchor);
      insert_hydration_dev(target, t0, anchor);
      mount_component(transformableobject, target, anchor);
      insert_hydration_dev(target, t1, anchor);
      mount_component(hierarchicalobject, target, anchor);
      insert_hydration_dev(target, t2, anchor);
      mount_component(viewportawareobject, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const layerableobject_changes = {};
      if (dirty & /*object*/
      2)
        layerableobject_changes.object = /*object*/
        ctx2[1];
      layerableobject.$set(layerableobject_changes);
      const transformableobject_changes = {};
      if (dirty & /*object*/
      2)
        transformableobject_changes.object = /*object*/
        ctx2[1];
      if (dirty & /*position*/
      4)
        transformableobject_changes.position = /*position*/
        ctx2[2];
      if (dirty & /*rotation*/
      16)
        transformableobject_changes.rotation = /*rotation*/
        ctx2[4];
      if (dirty & /*scale*/
      8)
        transformableobject_changes.scale = /*scale*/
        ctx2[3];
      if (dirty & /*lookAt*/
      32)
        transformableobject_changes.lookAt = /*lookAt*/
        ctx2[5];
      transformableobject.$set(transformableobject_changes);
      const hierarchicalobject_changes = {};
      if (dirty & /*object*/
      2)
        hierarchicalobject_changes.object = /*object*/
        ctx2[1];
      if (dirty & /*$$scope*/
      65536) {
        hierarchicalobject_changes.$$scope = { dirty, ctx: ctx2 };
      }
      hierarchicalobject.$set(hierarchicalobject_changes);
      const viewportawareobject_changes = {};
      if (dirty & /*object*/
      2)
        viewportawareobject_changes.object = /*object*/
        ctx2[1];
      if (dirty & /*viewportAware*/
      64)
        viewportawareobject_changes.viewportAware = /*viewportAware*/
        ctx2[6];
      if (!updating_inViewport && dirty & /*inViewport*/
      1) {
        updating_inViewport = true;
        viewportawareobject_changes.inViewport = /*inViewport*/
        ctx2[0];
        add_flush_callback(() => updating_inViewport = false);
      }
      viewportawareobject.$set(viewportawareobject_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(layerableobject.$$.fragment, local);
      transition_in(transformableobject.$$.fragment, local);
      transition_in(hierarchicalobject.$$.fragment, local);
      transition_in(viewportawareobject.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(layerableobject.$$.fragment, local);
      transition_out(transformableobject.$$.fragment, local);
      transition_out(hierarchicalobject.$$.fragment, local);
      transition_out(viewportawareobject.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(layerableobject, detaching);
      if (detaching)
        detach_dev(t0);
      destroy_component(transformableobject, detaching);
      if (detaching)
        detach_dev(t1);
      destroy_component(hierarchicalobject, detaching);
      if (detaching)
        detach_dev(t2);
      destroy_component(viewportawareobject, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment6.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance6($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Object3DInstance", slots, ["default"]);
  let { object } = $$props;
  let { position = void 0 } = $$props;
  let { scale = void 0 } = $$props;
  let { rotation = void 0 } = $$props;
  let { lookAt = void 0 } = $$props;
  let { viewportAware = false } = $$props;
  let { inViewport = false } = $$props;
  let { castShadow = void 0 } = $$props;
  let { receiveShadow = void 0 } = $$props;
  let { frustumCulled = void 0 } = $$props;
  let { renderOrder = void 0 } = $$props;
  let { visible = void 0 } = $$props;
  const { invalidate } = useThrelte();
  const getObject = () => object;
  $$self.$$.on_mount.push(function() {
    if (object === void 0 && !("object" in $$props || $$self.$$.bound[$$self.$$.props["object"]])) {
      console.warn("<Object3DInstance> was created without expected prop 'object'");
    }
  });
  const writable_props = [
    "object",
    "position",
    "scale",
    "rotation",
    "lookAt",
    "viewportAware",
    "inViewport",
    "castShadow",
    "receiveShadow",
    "frustumCulled",
    "renderOrder",
    "visible"
  ];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<Object3DInstance> was created with unknown prop '${key}'`);
  });
  function viewportawareobject_inViewport_binding(value) {
    inViewport = value;
    $$invalidate(0, inViewport);
  }
  function viewportenter_handler(event) {
    bubble.call(this, $$self, event);
  }
  function viewportleave_handler(event) {
    bubble.call(this, $$self, event);
  }
  $$self.$$set = ($$props2) => {
    if ("object" in $$props2)
      $$invalidate(1, object = $$props2.object);
    if ("position" in $$props2)
      $$invalidate(2, position = $$props2.position);
    if ("scale" in $$props2)
      $$invalidate(3, scale = $$props2.scale);
    if ("rotation" in $$props2)
      $$invalidate(4, rotation = $$props2.rotation);
    if ("lookAt" in $$props2)
      $$invalidate(5, lookAt = $$props2.lookAt);
    if ("viewportAware" in $$props2)
      $$invalidate(6, viewportAware = $$props2.viewportAware);
    if ("inViewport" in $$props2)
      $$invalidate(0, inViewport = $$props2.inViewport);
    if ("castShadow" in $$props2)
      $$invalidate(7, castShadow = $$props2.castShadow);
    if ("receiveShadow" in $$props2)
      $$invalidate(8, receiveShadow = $$props2.receiveShadow);
    if ("frustumCulled" in $$props2)
      $$invalidate(9, frustumCulled = $$props2.frustumCulled);
    if ("renderOrder" in $$props2)
      $$invalidate(10, renderOrder = $$props2.renderOrder);
    if ("visible" in $$props2)
      $$invalidate(11, visible = $$props2.visible);
    if ("$$scope" in $$props2)
      $$invalidate(16, $$scope = $$props2.$$scope);
  };
  $$self.$capture_state = () => ({
    useThrelte,
    HierarchicalObject: HierarchicalObject_default,
    LayerableObject: LayerableObject_default,
    TransformableObject: TransformableObject_default,
    ViewportAwareObject: ViewportAwareObject_default,
    object,
    position,
    scale,
    rotation,
    lookAt,
    viewportAware,
    inViewport,
    castShadow,
    receiveShadow,
    frustumCulled,
    renderOrder,
    visible,
    invalidate,
    getObject
  });
  $$self.$inject_state = ($$props2) => {
    if ("object" in $$props2)
      $$invalidate(1, object = $$props2.object);
    if ("position" in $$props2)
      $$invalidate(2, position = $$props2.position);
    if ("scale" in $$props2)
      $$invalidate(3, scale = $$props2.scale);
    if ("rotation" in $$props2)
      $$invalidate(4, rotation = $$props2.rotation);
    if ("lookAt" in $$props2)
      $$invalidate(5, lookAt = $$props2.lookAt);
    if ("viewportAware" in $$props2)
      $$invalidate(6, viewportAware = $$props2.viewportAware);
    if ("inViewport" in $$props2)
      $$invalidate(0, inViewport = $$props2.inViewport);
    if ("castShadow" in $$props2)
      $$invalidate(7, castShadow = $$props2.castShadow);
    if ("receiveShadow" in $$props2)
      $$invalidate(8, receiveShadow = $$props2.receiveShadow);
    if ("frustumCulled" in $$props2)
      $$invalidate(9, frustumCulled = $$props2.frustumCulled);
    if ("renderOrder" in $$props2)
      $$invalidate(10, renderOrder = $$props2.renderOrder);
    if ("visible" in $$props2)
      $$invalidate(11, visible = $$props2.visible);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*visible, castShadow, receiveShadow, frustumCulled, renderOrder*/
    3968) {
      $: {
        if (visible !== void 0)
          getObject().visible = visible;
        if (castShadow !== void 0)
          getObject().castShadow = castShadow;
        if (receiveShadow !== void 0)
          getObject().receiveShadow = receiveShadow;
        if (frustumCulled !== void 0)
          getObject().frustumCulled = frustumCulled;
        if (renderOrder !== void 0)
          getObject().renderOrder = renderOrder;
        invalidate("Object3DInstance: props changed");
      }
    }
  };
  return [
    inViewport,
    object,
    position,
    scale,
    rotation,
    lookAt,
    viewportAware,
    castShadow,
    receiveShadow,
    frustumCulled,
    renderOrder,
    visible,
    slots,
    viewportawareobject_inViewport_binding,
    viewportenter_handler,
    viewportleave_handler,
    $$scope
  ];
}
var Object3DInstance = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance6, create_fragment6, safe_not_equal, {
      object: 1,
      position: 2,
      scale: 3,
      rotation: 4,
      lookAt: 5,
      viewportAware: 6,
      inViewport: 0,
      castShadow: 7,
      receiveShadow: 8,
      frustumCulled: 9,
      renderOrder: 10,
      visible: 11
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Object3DInstance",
      options,
      id: create_fragment6.name
    });
  }
  get object() {
    throw new Error("<Object3DInstance>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set object(value) {
    throw new Error("<Object3DInstance>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get position() {
    throw new Error("<Object3DInstance>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set position(value) {
    throw new Error("<Object3DInstance>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get scale() {
    throw new Error("<Object3DInstance>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set scale(value) {
    throw new Error("<Object3DInstance>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get rotation() {
    throw new Error("<Object3DInstance>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set rotation(value) {
    throw new Error("<Object3DInstance>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get lookAt() {
    throw new Error("<Object3DInstance>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set lookAt(value) {
    throw new Error("<Object3DInstance>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get viewportAware() {
    throw new Error("<Object3DInstance>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set viewportAware(value) {
    throw new Error("<Object3DInstance>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get inViewport() {
    throw new Error("<Object3DInstance>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set inViewport(value) {
    throw new Error("<Object3DInstance>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get castShadow() {
    throw new Error("<Object3DInstance>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set castShadow(value) {
    throw new Error("<Object3DInstance>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get receiveShadow() {
    throw new Error("<Object3DInstance>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set receiveShadow(value) {
    throw new Error("<Object3DInstance>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get frustumCulled() {
    throw new Error("<Object3DInstance>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set frustumCulled(value) {
    throw new Error("<Object3DInstance>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get renderOrder() {
    throw new Error("<Object3DInstance>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set renderOrder(value) {
    throw new Error("<Object3DInstance>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get visible() {
    throw new Error("<Object3DInstance>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set visible(value) {
    throw new Error("<Object3DInstance>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Object3DInstance_default = Object3DInstance;

// node_modules/threlte/instances/CameraInstance.svelte
function create_default_slot2(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[15].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[19],
    null
  );
  const block = {
    c: function create() {
      if (default_slot)
        default_slot.c();
    },
    l: function claim(nodes) {
      if (default_slot)
        default_slot.l(nodes);
    },
    m: function mount(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        524288)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[19],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[19]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[19],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot2.name,
    type: "slot",
    source: "(25:0) <Object3DInstance   object={camera}   {lookAt}   {castShadow}   {receiveShadow}   {frustumCulled}   {renderOrder}   {position}   {scale}   {rotation}   {viewportAware}   {visible}   on:viewportenter   on:viewportleave   bind:inViewport >",
    ctx
  });
  return block;
}
function create_fragment7(ctx) {
  let object3dinstance;
  let updating_inViewport;
  let current;
  function object3dinstance_inViewport_binding(value) {
    ctx[16](value);
  }
  let object3dinstance_props = {
    object: (
      /*camera*/
      ctx[1]
    ),
    lookAt: (
      /*lookAt*/
      ctx[5]
    ),
    castShadow: (
      /*castShadow*/
      ctx[7]
    ),
    receiveShadow: (
      /*receiveShadow*/
      ctx[8]
    ),
    frustumCulled: (
      /*frustumCulled*/
      ctx[9]
    ),
    renderOrder: (
      /*renderOrder*/
      ctx[10]
    ),
    position: (
      /*position*/
      ctx[2]
    ),
    scale: (
      /*scale*/
      ctx[3]
    ),
    rotation: (
      /*rotation*/
      ctx[4]
    ),
    viewportAware: (
      /*viewportAware*/
      ctx[6]
    ),
    visible: (
      /*visible*/
      ctx[11]
    ),
    $$slots: { default: [create_default_slot2] },
    $$scope: { ctx }
  };
  if (
    /*inViewport*/
    ctx[0] !== void 0
  ) {
    object3dinstance_props.inViewport = /*inViewport*/
    ctx[0];
  }
  object3dinstance = new Object3DInstance_default({
    props: object3dinstance_props,
    $$inline: true
  });
  binding_callbacks.push(() => bind(object3dinstance, "inViewport", object3dinstance_inViewport_binding));
  object3dinstance.$on(
    "viewportenter",
    /*viewportenter_handler*/
    ctx[17]
  );
  object3dinstance.$on(
    "viewportleave",
    /*viewportleave_handler*/
    ctx[18]
  );
  const block = {
    c: function create() {
      create_component(object3dinstance.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(object3dinstance.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(object3dinstance, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const object3dinstance_changes = {};
      if (dirty & /*camera*/
      2)
        object3dinstance_changes.object = /*camera*/
        ctx2[1];
      if (dirty & /*lookAt*/
      32)
        object3dinstance_changes.lookAt = /*lookAt*/
        ctx2[5];
      if (dirty & /*castShadow*/
      128)
        object3dinstance_changes.castShadow = /*castShadow*/
        ctx2[7];
      if (dirty & /*receiveShadow*/
      256)
        object3dinstance_changes.receiveShadow = /*receiveShadow*/
        ctx2[8];
      if (dirty & /*frustumCulled*/
      512)
        object3dinstance_changes.frustumCulled = /*frustumCulled*/
        ctx2[9];
      if (dirty & /*renderOrder*/
      1024)
        object3dinstance_changes.renderOrder = /*renderOrder*/
        ctx2[10];
      if (dirty & /*position*/
      4)
        object3dinstance_changes.position = /*position*/
        ctx2[2];
      if (dirty & /*scale*/
      8)
        object3dinstance_changes.scale = /*scale*/
        ctx2[3];
      if (dirty & /*rotation*/
      16)
        object3dinstance_changes.rotation = /*rotation*/
        ctx2[4];
      if (dirty & /*viewportAware*/
      64)
        object3dinstance_changes.viewportAware = /*viewportAware*/
        ctx2[6];
      if (dirty & /*visible*/
      2048)
        object3dinstance_changes.visible = /*visible*/
        ctx2[11];
      if (dirty & /*$$scope*/
      524288) {
        object3dinstance_changes.$$scope = { dirty, ctx: ctx2 };
      }
      if (!updating_inViewport && dirty & /*inViewport*/
      1) {
        updating_inViewport = true;
        object3dinstance_changes.inViewport = /*inViewport*/
        ctx2[0];
        add_flush_callback(() => updating_inViewport = false);
      }
      object3dinstance.$set(object3dinstance_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(object3dinstance.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(object3dinstance.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(object3dinstance, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment7.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance7($$self, $$props, $$invalidate) {
  let $cam;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("CameraInstance", slots, ["default"]);
  let { camera } = $$props;
  let { position = void 0 } = $$props;
  let { scale = void 0 } = $$props;
  let { rotation = void 0 } = $$props;
  let { lookAt = void 0 } = $$props;
  let { viewportAware = false } = $$props;
  let { inViewport = false } = $$props;
  let { castShadow = void 0 } = $$props;
  let { receiveShadow = void 0 } = $$props;
  let { frustumCulled = void 0 } = $$props;
  let { renderOrder = void 0 } = $$props;
  let { visible = void 0 } = $$props;
  let { useCamera = false } = $$props;
  const cam = createObjectStore(camera);
  validate_store(cam, "cam");
  component_subscribe($$self, cam, (value) => $$invalidate(14, $cam = value));
  const { setCamera } = useThrelteRoot();
  $$self.$$.on_mount.push(function() {
    if (camera === void 0 && !("camera" in $$props || $$self.$$.bound[$$self.$$.props["camera"]])) {
      console.warn("<CameraInstance> was created without expected prop 'camera'");
    }
  });
  const writable_props = [
    "camera",
    "position",
    "scale",
    "rotation",
    "lookAt",
    "viewportAware",
    "inViewport",
    "castShadow",
    "receiveShadow",
    "frustumCulled",
    "renderOrder",
    "visible",
    "useCamera"
  ];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<CameraInstance> was created with unknown prop '${key}'`);
  });
  function object3dinstance_inViewport_binding(value) {
    inViewport = value;
    $$invalidate(0, inViewport);
  }
  function viewportenter_handler(event) {
    bubble.call(this, $$self, event);
  }
  function viewportleave_handler(event) {
    bubble.call(this, $$self, event);
  }
  $$self.$$set = ($$props2) => {
    if ("camera" in $$props2)
      $$invalidate(1, camera = $$props2.camera);
    if ("position" in $$props2)
      $$invalidate(2, position = $$props2.position);
    if ("scale" in $$props2)
      $$invalidate(3, scale = $$props2.scale);
    if ("rotation" in $$props2)
      $$invalidate(4, rotation = $$props2.rotation);
    if ("lookAt" in $$props2)
      $$invalidate(5, lookAt = $$props2.lookAt);
    if ("viewportAware" in $$props2)
      $$invalidate(6, viewportAware = $$props2.viewportAware);
    if ("inViewport" in $$props2)
      $$invalidate(0, inViewport = $$props2.inViewport);
    if ("castShadow" in $$props2)
      $$invalidate(7, castShadow = $$props2.castShadow);
    if ("receiveShadow" in $$props2)
      $$invalidate(8, receiveShadow = $$props2.receiveShadow);
    if ("frustumCulled" in $$props2)
      $$invalidate(9, frustumCulled = $$props2.frustumCulled);
    if ("renderOrder" in $$props2)
      $$invalidate(10, renderOrder = $$props2.renderOrder);
    if ("visible" in $$props2)
      $$invalidate(11, visible = $$props2.visible);
    if ("useCamera" in $$props2)
      $$invalidate(13, useCamera = $$props2.useCamera);
    if ("$$scope" in $$props2)
      $$invalidate(19, $$scope = $$props2.$$scope);
  };
  $$self.$capture_state = () => ({
    useThrelteRoot,
    createObjectStore,
    Object3DInstance: Object3DInstance_default,
    camera,
    position,
    scale,
    rotation,
    lookAt,
    viewportAware,
    inViewport,
    castShadow,
    receiveShadow,
    frustumCulled,
    renderOrder,
    visible,
    useCamera,
    cam,
    setCamera,
    $cam
  });
  $$self.$inject_state = ($$props2) => {
    if ("camera" in $$props2)
      $$invalidate(1, camera = $$props2.camera);
    if ("position" in $$props2)
      $$invalidate(2, position = $$props2.position);
    if ("scale" in $$props2)
      $$invalidate(3, scale = $$props2.scale);
    if ("rotation" in $$props2)
      $$invalidate(4, rotation = $$props2.rotation);
    if ("lookAt" in $$props2)
      $$invalidate(5, lookAt = $$props2.lookAt);
    if ("viewportAware" in $$props2)
      $$invalidate(6, viewportAware = $$props2.viewportAware);
    if ("inViewport" in $$props2)
      $$invalidate(0, inViewport = $$props2.inViewport);
    if ("castShadow" in $$props2)
      $$invalidate(7, castShadow = $$props2.castShadow);
    if ("receiveShadow" in $$props2)
      $$invalidate(8, receiveShadow = $$props2.receiveShadow);
    if ("frustumCulled" in $$props2)
      $$invalidate(9, frustumCulled = $$props2.frustumCulled);
    if ("renderOrder" in $$props2)
      $$invalidate(10, renderOrder = $$props2.renderOrder);
    if ("visible" in $$props2)
      $$invalidate(11, visible = $$props2.visible);
    if ("useCamera" in $$props2)
      $$invalidate(13, useCamera = $$props2.useCamera);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*camera*/
    2) {
      $:
        cam.set(camera);
    }
    if ($$self.$$.dirty & /*useCamera, $cam*/
    24576) {
      $:
        if (useCamera) {
          setCamera($cam);
        }
    }
  };
  return [
    inViewport,
    camera,
    position,
    scale,
    rotation,
    lookAt,
    viewportAware,
    castShadow,
    receiveShadow,
    frustumCulled,
    renderOrder,
    visible,
    cam,
    useCamera,
    $cam,
    slots,
    object3dinstance_inViewport_binding,
    viewportenter_handler,
    viewportleave_handler,
    $$scope
  ];
}
var CameraInstance = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance7, create_fragment7, safe_not_equal, {
      camera: 1,
      position: 2,
      scale: 3,
      rotation: 4,
      lookAt: 5,
      viewportAware: 6,
      inViewport: 0,
      castShadow: 7,
      receiveShadow: 8,
      frustumCulled: 9,
      renderOrder: 10,
      visible: 11,
      useCamera: 13
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "CameraInstance",
      options,
      id: create_fragment7.name
    });
  }
  get camera() {
    throw new Error("<CameraInstance>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set camera(value) {
    throw new Error("<CameraInstance>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get position() {
    throw new Error("<CameraInstance>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set position(value) {
    throw new Error("<CameraInstance>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get scale() {
    throw new Error("<CameraInstance>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set scale(value) {
    throw new Error("<CameraInstance>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get rotation() {
    throw new Error("<CameraInstance>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set rotation(value) {
    throw new Error("<CameraInstance>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get lookAt() {
    throw new Error("<CameraInstance>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set lookAt(value) {
    throw new Error("<CameraInstance>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get viewportAware() {
    throw new Error("<CameraInstance>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set viewportAware(value) {
    throw new Error("<CameraInstance>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get inViewport() {
    throw new Error("<CameraInstance>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set inViewport(value) {
    throw new Error("<CameraInstance>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get castShadow() {
    throw new Error("<CameraInstance>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set castShadow(value) {
    throw new Error("<CameraInstance>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get receiveShadow() {
    throw new Error("<CameraInstance>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set receiveShadow(value) {
    throw new Error("<CameraInstance>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get frustumCulled() {
    throw new Error("<CameraInstance>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set frustumCulled(value) {
    throw new Error("<CameraInstance>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get renderOrder() {
    throw new Error("<CameraInstance>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set renderOrder(value) {
    throw new Error("<CameraInstance>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get visible() {
    throw new Error("<CameraInstance>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set visible(value) {
    throw new Error("<CameraInstance>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get useCamera() {
    throw new Error("<CameraInstance>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set useCamera(value) {
    throw new Error("<CameraInstance>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var CameraInstance_default = CameraInstance;

// node_modules/threlte/cameras/OrthographicCamera.svelte
function create_default_slot3(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[18].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[22],
    null
  );
  const block = {
    c: function create() {
      if (default_slot)
        default_slot.c();
    },
    l: function claim(nodes) {
      if (default_slot)
        default_slot.l(nodes);
    },
    m: function mount(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        4194304)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[22],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[22]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[22],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot3.name,
    type: "slot",
    source: "(47:0) <CameraInstance   {camera}   {position}   {scale}   {rotation}   {castShadow}   {receiveShadow}   {frustumCulled}   {renderOrder}   {visible}   {viewportAware}   bind:inViewport   on:viewportenter   on:viewportleave   {lookAt}   {useCamera} >",
    ctx
  });
  return block;
}
function create_fragment8(ctx) {
  let camerainstance;
  let updating_inViewport;
  let current;
  function camerainstance_inViewport_binding(value) {
    ctx[19](value);
  }
  let camerainstance_props = {
    camera: (
      /*camera*/
      ctx[0]
    ),
    position: (
      /*position*/
      ctx[2]
    ),
    scale: (
      /*scale*/
      ctx[3]
    ),
    rotation: (
      /*rotation*/
      ctx[4]
    ),
    castShadow: (
      /*castShadow*/
      ctx[7]
    ),
    receiveShadow: (
      /*receiveShadow*/
      ctx[8]
    ),
    frustumCulled: (
      /*frustumCulled*/
      ctx[9]
    ),
    renderOrder: (
      /*renderOrder*/
      ctx[10]
    ),
    visible: (
      /*visible*/
      ctx[11]
    ),
    viewportAware: (
      /*viewportAware*/
      ctx[6]
    ),
    lookAt: (
      /*lookAt*/
      ctx[5]
    ),
    useCamera: (
      /*useCamera*/
      ctx[12]
    ),
    $$slots: { default: [create_default_slot3] },
    $$scope: { ctx }
  };
  if (
    /*inViewport*/
    ctx[1] !== void 0
  ) {
    camerainstance_props.inViewport = /*inViewport*/
    ctx[1];
  }
  camerainstance = new CameraInstance_default({
    props: camerainstance_props,
    $$inline: true
  });
  binding_callbacks.push(() => bind(camerainstance, "inViewport", camerainstance_inViewport_binding));
  camerainstance.$on(
    "viewportenter",
    /*viewportenter_handler*/
    ctx[20]
  );
  camerainstance.$on(
    "viewportleave",
    /*viewportleave_handler*/
    ctx[21]
  );
  const block = {
    c: function create() {
      create_component(camerainstance.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(camerainstance.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(camerainstance, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const camerainstance_changes = {};
      if (dirty & /*camera*/
      1)
        camerainstance_changes.camera = /*camera*/
        ctx2[0];
      if (dirty & /*position*/
      4)
        camerainstance_changes.position = /*position*/
        ctx2[2];
      if (dirty & /*scale*/
      8)
        camerainstance_changes.scale = /*scale*/
        ctx2[3];
      if (dirty & /*rotation*/
      16)
        camerainstance_changes.rotation = /*rotation*/
        ctx2[4];
      if (dirty & /*castShadow*/
      128)
        camerainstance_changes.castShadow = /*castShadow*/
        ctx2[7];
      if (dirty & /*receiveShadow*/
      256)
        camerainstance_changes.receiveShadow = /*receiveShadow*/
        ctx2[8];
      if (dirty & /*frustumCulled*/
      512)
        camerainstance_changes.frustumCulled = /*frustumCulled*/
        ctx2[9];
      if (dirty & /*renderOrder*/
      1024)
        camerainstance_changes.renderOrder = /*renderOrder*/
        ctx2[10];
      if (dirty & /*visible*/
      2048)
        camerainstance_changes.visible = /*visible*/
        ctx2[11];
      if (dirty & /*viewportAware*/
      64)
        camerainstance_changes.viewportAware = /*viewportAware*/
        ctx2[6];
      if (dirty & /*lookAt*/
      32)
        camerainstance_changes.lookAt = /*lookAt*/
        ctx2[5];
      if (dirty & /*useCamera*/
      4096)
        camerainstance_changes.useCamera = /*useCamera*/
        ctx2[12];
      if (dirty & /*$$scope*/
      4194304) {
        camerainstance_changes.$$scope = { dirty, ctx: ctx2 };
      }
      if (!updating_inViewport && dirty & /*inViewport*/
      2) {
        updating_inViewport = true;
        camerainstance_changes.inViewport = /*inViewport*/
        ctx2[1];
        add_flush_callback(() => updating_inViewport = false);
      }
      camerainstance.$set(camerainstance_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(camerainstance.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(camerainstance.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(camerainstance, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment8.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance8($$self, $$props, $$invalidate) {
  let $size;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("OrthographicCamera", slots, ["default"]);
  let { position = void 0 } = $$props;
  let { scale = void 0 } = $$props;
  let { rotation = void 0 } = $$props;
  let { lookAt = void 0 } = $$props;
  let { viewportAware = false } = $$props;
  let { inViewport = false } = $$props;
  let { castShadow = void 0 } = $$props;
  let { receiveShadow = void 0 } = $$props;
  let { frustumCulled = void 0 } = $$props;
  let { renderOrder = void 0 } = $$props;
  let { visible = void 0 } = $$props;
  let { useCamera = true } = $$props;
  let { near = void 0 } = $$props;
  let { far = void 0 } = $$props;
  let { zoom = void 0 } = $$props;
  const { size, invalidate } = useThrelte();
  validate_store(size, "size");
  component_subscribe($$self, size, (value) => $$invalidate(17, $size = value));
  const { setCamera } = useThrelteRoot();
  const camera = new OrthographicCamera($size.width / -2, $size.width / 2, $size.height / 2, $size.height / -2, near, far);
  const writable_props = [
    "position",
    "scale",
    "rotation",
    "lookAt",
    "viewportAware",
    "inViewport",
    "castShadow",
    "receiveShadow",
    "frustumCulled",
    "renderOrder",
    "visible",
    "useCamera",
    "near",
    "far",
    "zoom"
  ];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<OrthographicCamera> was created with unknown prop '${key}'`);
  });
  function camerainstance_inViewport_binding(value) {
    inViewport = value;
    $$invalidate(1, inViewport);
  }
  function viewportenter_handler(event) {
    bubble.call(this, $$self, event);
  }
  function viewportleave_handler(event) {
    bubble.call(this, $$self, event);
  }
  $$self.$$set = ($$props2) => {
    if ("position" in $$props2)
      $$invalidate(2, position = $$props2.position);
    if ("scale" in $$props2)
      $$invalidate(3, scale = $$props2.scale);
    if ("rotation" in $$props2)
      $$invalidate(4, rotation = $$props2.rotation);
    if ("lookAt" in $$props2)
      $$invalidate(5, lookAt = $$props2.lookAt);
    if ("viewportAware" in $$props2)
      $$invalidate(6, viewportAware = $$props2.viewportAware);
    if ("inViewport" in $$props2)
      $$invalidate(1, inViewport = $$props2.inViewport);
    if ("castShadow" in $$props2)
      $$invalidate(7, castShadow = $$props2.castShadow);
    if ("receiveShadow" in $$props2)
      $$invalidate(8, receiveShadow = $$props2.receiveShadow);
    if ("frustumCulled" in $$props2)
      $$invalidate(9, frustumCulled = $$props2.frustumCulled);
    if ("renderOrder" in $$props2)
      $$invalidate(10, renderOrder = $$props2.renderOrder);
    if ("visible" in $$props2)
      $$invalidate(11, visible = $$props2.visible);
    if ("useCamera" in $$props2)
      $$invalidate(12, useCamera = $$props2.useCamera);
    if ("near" in $$props2)
      $$invalidate(14, near = $$props2.near);
    if ("far" in $$props2)
      $$invalidate(15, far = $$props2.far);
    if ("zoom" in $$props2)
      $$invalidate(16, zoom = $$props2.zoom);
    if ("$$scope" in $$props2)
      $$invalidate(22, $$scope = $$props2.$$scope);
  };
  $$self.$capture_state = () => ({
    ThreeOrthographicCamera: OrthographicCamera,
    useThrelte,
    useThrelteRoot,
    CameraInstance: CameraInstance_default,
    position,
    scale,
    rotation,
    lookAt,
    viewportAware,
    inViewport,
    castShadow,
    receiveShadow,
    frustumCulled,
    renderOrder,
    visible,
    useCamera,
    near,
    far,
    zoom,
    size,
    invalidate,
    setCamera,
    camera,
    $size
  });
  $$self.$inject_state = ($$props2) => {
    if ("position" in $$props2)
      $$invalidate(2, position = $$props2.position);
    if ("scale" in $$props2)
      $$invalidate(3, scale = $$props2.scale);
    if ("rotation" in $$props2)
      $$invalidate(4, rotation = $$props2.rotation);
    if ("lookAt" in $$props2)
      $$invalidate(5, lookAt = $$props2.lookAt);
    if ("viewportAware" in $$props2)
      $$invalidate(6, viewportAware = $$props2.viewportAware);
    if ("inViewport" in $$props2)
      $$invalidate(1, inViewport = $$props2.inViewport);
    if ("castShadow" in $$props2)
      $$invalidate(7, castShadow = $$props2.castShadow);
    if ("receiveShadow" in $$props2)
      $$invalidate(8, receiveShadow = $$props2.receiveShadow);
    if ("frustumCulled" in $$props2)
      $$invalidate(9, frustumCulled = $$props2.frustumCulled);
    if ("renderOrder" in $$props2)
      $$invalidate(10, renderOrder = $$props2.renderOrder);
    if ("visible" in $$props2)
      $$invalidate(11, visible = $$props2.visible);
    if ("useCamera" in $$props2)
      $$invalidate(12, useCamera = $$props2.useCamera);
    if ("near" in $$props2)
      $$invalidate(14, near = $$props2.near);
    if ("far" in $$props2)
      $$invalidate(15, far = $$props2.far);
    if ("zoom" in $$props2)
      $$invalidate(16, zoom = $$props2.zoom);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*$size, camera*/
    131073) {
      $: {
        $$invalidate(0, camera.left = $size.width / -2, camera);
        $$invalidate(0, camera.right = $size.width / 2, camera);
        $$invalidate(0, camera.top = $size.height / 2, camera);
        $$invalidate(0, camera.bottom = $size.height / -2, camera);
        camera.updateProjectionMatrix();
        invalidate("OrthographicCamera: onResize");
      }
    }
    if ($$self.$$.dirty & /*near, far, zoom, camera*/
    114689) {
      $: {
        if (near !== void 0)
          $$invalidate(0, camera.near = near, camera);
        if (far !== void 0)
          $$invalidate(0, camera.far = far, camera);
        if (zoom !== void 0)
          $$invalidate(0, camera.zoom = zoom, camera);
        camera.updateProjectionMatrix();
        invalidate("OrthographicCamera: props changed");
      }
    }
    if ($$self.$$.dirty & /*useCamera, camera*/
    4097) {
      $:
        if (useCamera)
          setCamera(camera);
    }
  };
  return [
    camera,
    inViewport,
    position,
    scale,
    rotation,
    lookAt,
    viewportAware,
    castShadow,
    receiveShadow,
    frustumCulled,
    renderOrder,
    visible,
    useCamera,
    size,
    near,
    far,
    zoom,
    $size,
    slots,
    camerainstance_inViewport_binding,
    viewportenter_handler,
    viewportleave_handler,
    $$scope
  ];
}
var OrthographicCamera2 = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance8, create_fragment8, safe_not_equal, {
      position: 2,
      scale: 3,
      rotation: 4,
      lookAt: 5,
      viewportAware: 6,
      inViewport: 1,
      castShadow: 7,
      receiveShadow: 8,
      frustumCulled: 9,
      renderOrder: 10,
      visible: 11,
      useCamera: 12,
      near: 14,
      far: 15,
      zoom: 16,
      camera: 0
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "OrthographicCamera",
      options,
      id: create_fragment8.name
    });
  }
  get position() {
    throw new Error("<OrthographicCamera>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set position(value) {
    throw new Error("<OrthographicCamera>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get scale() {
    throw new Error("<OrthographicCamera>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set scale(value) {
    throw new Error("<OrthographicCamera>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get rotation() {
    throw new Error("<OrthographicCamera>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set rotation(value) {
    throw new Error("<OrthographicCamera>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get lookAt() {
    throw new Error("<OrthographicCamera>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set lookAt(value) {
    throw new Error("<OrthographicCamera>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get viewportAware() {
    throw new Error("<OrthographicCamera>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set viewportAware(value) {
    throw new Error("<OrthographicCamera>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get inViewport() {
    throw new Error("<OrthographicCamera>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set inViewport(value) {
    throw new Error("<OrthographicCamera>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get castShadow() {
    throw new Error("<OrthographicCamera>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set castShadow(value) {
    throw new Error("<OrthographicCamera>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get receiveShadow() {
    throw new Error("<OrthographicCamera>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set receiveShadow(value) {
    throw new Error("<OrthographicCamera>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get frustumCulled() {
    throw new Error("<OrthographicCamera>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set frustumCulled(value) {
    throw new Error("<OrthographicCamera>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get renderOrder() {
    throw new Error("<OrthographicCamera>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set renderOrder(value) {
    throw new Error("<OrthographicCamera>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get visible() {
    throw new Error("<OrthographicCamera>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set visible(value) {
    throw new Error("<OrthographicCamera>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get useCamera() {
    throw new Error("<OrthographicCamera>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set useCamera(value) {
    throw new Error("<OrthographicCamera>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get near() {
    throw new Error("<OrthographicCamera>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set near(value) {
    throw new Error("<OrthographicCamera>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get far() {
    throw new Error("<OrthographicCamera>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set far(value) {
    throw new Error("<OrthographicCamera>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get zoom() {
    throw new Error("<OrthographicCamera>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set zoom(value) {
    throw new Error("<OrthographicCamera>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get camera() {
    return this.$$.ctx[0];
  }
  set camera(value) {
    throw new Error("<OrthographicCamera>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var OrthographicCamera_default = OrthographicCamera2;

// node_modules/threlte/cameras/PerspectiveCamera.svelte
function create_default_slot4(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[18].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[22],
    null
  );
  const block = {
    c: function create() {
      if (default_slot)
        default_slot.c();
    },
    l: function claim(nodes) {
      if (default_slot)
        default_slot.l(nodes);
    },
    m: function mount(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        4194304)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[22],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[22]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[22],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot4.name,
    type: "slot",
    source: "(40:0) <CameraInstance   {camera}   {position}   {scale}   {rotation}   {castShadow}   {receiveShadow}   {frustumCulled}   {renderOrder}   {visible}   {viewportAware}   bind:inViewport   on:viewportenter   on:viewportleave   {lookAt}   {useCamera} >",
    ctx
  });
  return block;
}
function create_fragment9(ctx) {
  let camerainstance;
  let updating_inViewport;
  let current;
  function camerainstance_inViewport_binding(value) {
    ctx[19](value);
  }
  let camerainstance_props = {
    camera: (
      /*camera*/
      ctx[0]
    ),
    position: (
      /*position*/
      ctx[2]
    ),
    scale: (
      /*scale*/
      ctx[3]
    ),
    rotation: (
      /*rotation*/
      ctx[4]
    ),
    castShadow: (
      /*castShadow*/
      ctx[6]
    ),
    receiveShadow: (
      /*receiveShadow*/
      ctx[7]
    ),
    frustumCulled: (
      /*frustumCulled*/
      ctx[8]
    ),
    renderOrder: (
      /*renderOrder*/
      ctx[9]
    ),
    visible: (
      /*visible*/
      ctx[10]
    ),
    viewportAware: (
      /*viewportAware*/
      ctx[11]
    ),
    lookAt: (
      /*lookAt*/
      ctx[5]
    ),
    useCamera: (
      /*useCamera*/
      ctx[12]
    ),
    $$slots: { default: [create_default_slot4] },
    $$scope: { ctx }
  };
  if (
    /*inViewport*/
    ctx[1] !== void 0
  ) {
    camerainstance_props.inViewport = /*inViewport*/
    ctx[1];
  }
  camerainstance = new CameraInstance_default({
    props: camerainstance_props,
    $$inline: true
  });
  binding_callbacks.push(() => bind(camerainstance, "inViewport", camerainstance_inViewport_binding));
  camerainstance.$on(
    "viewportenter",
    /*viewportenter_handler*/
    ctx[20]
  );
  camerainstance.$on(
    "viewportleave",
    /*viewportleave_handler*/
    ctx[21]
  );
  const block = {
    c: function create() {
      create_component(camerainstance.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(camerainstance.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(camerainstance, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const camerainstance_changes = {};
      if (dirty & /*camera*/
      1)
        camerainstance_changes.camera = /*camera*/
        ctx2[0];
      if (dirty & /*position*/
      4)
        camerainstance_changes.position = /*position*/
        ctx2[2];
      if (dirty & /*scale*/
      8)
        camerainstance_changes.scale = /*scale*/
        ctx2[3];
      if (dirty & /*rotation*/
      16)
        camerainstance_changes.rotation = /*rotation*/
        ctx2[4];
      if (dirty & /*castShadow*/
      64)
        camerainstance_changes.castShadow = /*castShadow*/
        ctx2[6];
      if (dirty & /*receiveShadow*/
      128)
        camerainstance_changes.receiveShadow = /*receiveShadow*/
        ctx2[7];
      if (dirty & /*frustumCulled*/
      256)
        camerainstance_changes.frustumCulled = /*frustumCulled*/
        ctx2[8];
      if (dirty & /*renderOrder*/
      512)
        camerainstance_changes.renderOrder = /*renderOrder*/
        ctx2[9];
      if (dirty & /*visible*/
      1024)
        camerainstance_changes.visible = /*visible*/
        ctx2[10];
      if (dirty & /*viewportAware*/
      2048)
        camerainstance_changes.viewportAware = /*viewportAware*/
        ctx2[11];
      if (dirty & /*lookAt*/
      32)
        camerainstance_changes.lookAt = /*lookAt*/
        ctx2[5];
      if (dirty & /*useCamera*/
      4096)
        camerainstance_changes.useCamera = /*useCamera*/
        ctx2[12];
      if (dirty & /*$$scope*/
      4194304) {
        camerainstance_changes.$$scope = { dirty, ctx: ctx2 };
      }
      if (!updating_inViewport && dirty & /*inViewport*/
      2) {
        updating_inViewport = true;
        camerainstance_changes.inViewport = /*inViewport*/
        ctx2[1];
        add_flush_callback(() => updating_inViewport = false);
      }
      camerainstance.$set(camerainstance_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(camerainstance.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(camerainstance.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(camerainstance, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment9.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance9($$self, $$props, $$invalidate) {
  let $size;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("PerspectiveCamera", slots, ["default"]);
  let { position = void 0 } = $$props;
  let { scale = void 0 } = $$props;
  let { rotation = void 0 } = $$props;
  let { lookAt = void 0 } = $$props;
  let { castShadow = void 0 } = $$props;
  let { receiveShadow = void 0 } = $$props;
  let { frustumCulled = void 0 } = $$props;
  let { renderOrder = void 0 } = $$props;
  let { visible = void 0 } = $$props;
  let { viewportAware = false } = $$props;
  let { inViewport = false } = $$props;
  let { useCamera = true } = $$props;
  let { near = void 0 } = $$props;
  let { far = void 0 } = $$props;
  let { fov = void 0 } = $$props;
  const { size, invalidate } = useThrelte();
  validate_store(size, "size");
  component_subscribe($$self, size, (value) => $$invalidate(17, $size = value));
  const camera = new PerspectiveCamera(fov, $size.width / $size.height, near, far);
  const writable_props = [
    "position",
    "scale",
    "rotation",
    "lookAt",
    "castShadow",
    "receiveShadow",
    "frustumCulled",
    "renderOrder",
    "visible",
    "viewportAware",
    "inViewport",
    "useCamera",
    "near",
    "far",
    "fov"
  ];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<PerspectiveCamera> was created with unknown prop '${key}'`);
  });
  function camerainstance_inViewport_binding(value) {
    inViewport = value;
    $$invalidate(1, inViewport);
  }
  function viewportenter_handler(event) {
    bubble.call(this, $$self, event);
  }
  function viewportleave_handler(event) {
    bubble.call(this, $$self, event);
  }
  $$self.$$set = ($$props2) => {
    if ("position" in $$props2)
      $$invalidate(2, position = $$props2.position);
    if ("scale" in $$props2)
      $$invalidate(3, scale = $$props2.scale);
    if ("rotation" in $$props2)
      $$invalidate(4, rotation = $$props2.rotation);
    if ("lookAt" in $$props2)
      $$invalidate(5, lookAt = $$props2.lookAt);
    if ("castShadow" in $$props2)
      $$invalidate(6, castShadow = $$props2.castShadow);
    if ("receiveShadow" in $$props2)
      $$invalidate(7, receiveShadow = $$props2.receiveShadow);
    if ("frustumCulled" in $$props2)
      $$invalidate(8, frustumCulled = $$props2.frustumCulled);
    if ("renderOrder" in $$props2)
      $$invalidate(9, renderOrder = $$props2.renderOrder);
    if ("visible" in $$props2)
      $$invalidate(10, visible = $$props2.visible);
    if ("viewportAware" in $$props2)
      $$invalidate(11, viewportAware = $$props2.viewportAware);
    if ("inViewport" in $$props2)
      $$invalidate(1, inViewport = $$props2.inViewport);
    if ("useCamera" in $$props2)
      $$invalidate(12, useCamera = $$props2.useCamera);
    if ("near" in $$props2)
      $$invalidate(14, near = $$props2.near);
    if ("far" in $$props2)
      $$invalidate(15, far = $$props2.far);
    if ("fov" in $$props2)
      $$invalidate(16, fov = $$props2.fov);
    if ("$$scope" in $$props2)
      $$invalidate(22, $$scope = $$props2.$$scope);
  };
  $$self.$capture_state = () => ({
    ThreePerspectiveCamera: PerspectiveCamera,
    useThrelte,
    CameraInstance: CameraInstance_default,
    position,
    scale,
    rotation,
    lookAt,
    castShadow,
    receiveShadow,
    frustumCulled,
    renderOrder,
    visible,
    viewportAware,
    inViewport,
    useCamera,
    near,
    far,
    fov,
    size,
    invalidate,
    camera,
    $size
  });
  $$self.$inject_state = ($$props2) => {
    if ("position" in $$props2)
      $$invalidate(2, position = $$props2.position);
    if ("scale" in $$props2)
      $$invalidate(3, scale = $$props2.scale);
    if ("rotation" in $$props2)
      $$invalidate(4, rotation = $$props2.rotation);
    if ("lookAt" in $$props2)
      $$invalidate(5, lookAt = $$props2.lookAt);
    if ("castShadow" in $$props2)
      $$invalidate(6, castShadow = $$props2.castShadow);
    if ("receiveShadow" in $$props2)
      $$invalidate(7, receiveShadow = $$props2.receiveShadow);
    if ("frustumCulled" in $$props2)
      $$invalidate(8, frustumCulled = $$props2.frustumCulled);
    if ("renderOrder" in $$props2)
      $$invalidate(9, renderOrder = $$props2.renderOrder);
    if ("visible" in $$props2)
      $$invalidate(10, visible = $$props2.visible);
    if ("viewportAware" in $$props2)
      $$invalidate(11, viewportAware = $$props2.viewportAware);
    if ("inViewport" in $$props2)
      $$invalidate(1, inViewport = $$props2.inViewport);
    if ("useCamera" in $$props2)
      $$invalidate(12, useCamera = $$props2.useCamera);
    if ("near" in $$props2)
      $$invalidate(14, near = $$props2.near);
    if ("far" in $$props2)
      $$invalidate(15, far = $$props2.far);
    if ("fov" in $$props2)
      $$invalidate(16, fov = $$props2.fov);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*$size, camera*/
    131073) {
      $: {
        $$invalidate(0, camera.aspect = $size.width / $size.height, camera);
        camera.updateProjectionMatrix();
        invalidate("PerspectiveCamera: aspect changed");
      }
    }
    if ($$self.$$.dirty & /*near, far, fov, camera*/
    114689) {
      $: {
        if (near !== void 0)
          $$invalidate(0, camera.near = near, camera);
        if (far !== void 0)
          $$invalidate(0, camera.far = far, camera);
        if (fov !== void 0)
          $$invalidate(0, camera.fov = fov, camera);
        camera.updateProjectionMatrix();
        invalidate("PerspectiveCamera: props changed");
      }
    }
  };
  return [
    camera,
    inViewport,
    position,
    scale,
    rotation,
    lookAt,
    castShadow,
    receiveShadow,
    frustumCulled,
    renderOrder,
    visible,
    viewportAware,
    useCamera,
    size,
    near,
    far,
    fov,
    $size,
    slots,
    camerainstance_inViewport_binding,
    viewportenter_handler,
    viewportleave_handler,
    $$scope
  ];
}
var PerspectiveCamera2 = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance9, create_fragment9, safe_not_equal, {
      position: 2,
      scale: 3,
      rotation: 4,
      lookAt: 5,
      castShadow: 6,
      receiveShadow: 7,
      frustumCulled: 8,
      renderOrder: 9,
      visible: 10,
      viewportAware: 11,
      inViewport: 1,
      useCamera: 12,
      near: 14,
      far: 15,
      fov: 16,
      camera: 0
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "PerspectiveCamera",
      options,
      id: create_fragment9.name
    });
  }
  get position() {
    throw new Error("<PerspectiveCamera>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set position(value) {
    throw new Error("<PerspectiveCamera>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get scale() {
    throw new Error("<PerspectiveCamera>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set scale(value) {
    throw new Error("<PerspectiveCamera>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get rotation() {
    throw new Error("<PerspectiveCamera>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set rotation(value) {
    throw new Error("<PerspectiveCamera>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get lookAt() {
    throw new Error("<PerspectiveCamera>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set lookAt(value) {
    throw new Error("<PerspectiveCamera>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get castShadow() {
    throw new Error("<PerspectiveCamera>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set castShadow(value) {
    throw new Error("<PerspectiveCamera>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get receiveShadow() {
    throw new Error("<PerspectiveCamera>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set receiveShadow(value) {
    throw new Error("<PerspectiveCamera>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get frustumCulled() {
    throw new Error("<PerspectiveCamera>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set frustumCulled(value) {
    throw new Error("<PerspectiveCamera>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get renderOrder() {
    throw new Error("<PerspectiveCamera>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set renderOrder(value) {
    throw new Error("<PerspectiveCamera>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get visible() {
    throw new Error("<PerspectiveCamera>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set visible(value) {
    throw new Error("<PerspectiveCamera>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get viewportAware() {
    throw new Error("<PerspectiveCamera>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set viewportAware(value) {
    throw new Error("<PerspectiveCamera>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get inViewport() {
    throw new Error("<PerspectiveCamera>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set inViewport(value) {
    throw new Error("<PerspectiveCamera>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get useCamera() {
    throw new Error("<PerspectiveCamera>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set useCamera(value) {
    throw new Error("<PerspectiveCamera>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get near() {
    throw new Error("<PerspectiveCamera>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set near(value) {
    throw new Error("<PerspectiveCamera>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get far() {
    throw new Error("<PerspectiveCamera>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set far(value) {
    throw new Error("<PerspectiveCamera>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get fov() {
    throw new Error("<PerspectiveCamera>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set fov(value) {
    throw new Error("<PerspectiveCamera>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get camera() {
    return this.$$.ctx[0];
  }
  set camera(value) {
    throw new Error("<PerspectiveCamera>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var PerspectiveCamera_default = PerspectiveCamera2;

// node_modules/threlte/hooks/useThrelteAudio.js
var useThrelteAudio = () => {
  return getContext("threlte-audio-context");
};

// node_modules/threlte/audio/AudioListener.svelte
function create_default_slot5(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[16].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[20],
    null
  );
  const block = {
    c: function create() {
      if (default_slot)
        default_slot.c();
    },
    l: function claim(nodes) {
      if (default_slot)
        default_slot.l(nodes);
    },
    m: function mount(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        1048576)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[20],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[20]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[20],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot5.name,
    type: "slot",
    source: "(30:0) <Object3DInstance   object={listener}   {position}   {scale}   {rotation}   {lookAt}   {frustumCulled}   {renderOrder}   {visible}   {castShadow}   {receiveShadow}   {viewportAware}   bind:inViewport   on:viewportenter   on:viewportleave >",
    ctx
  });
  return block;
}
function create_fragment10(ctx) {
  let object3dinstance;
  let updating_inViewport;
  let current;
  function object3dinstance_inViewport_binding(value) {
    ctx[17](value);
  }
  let object3dinstance_props = {
    object: (
      /*listener*/
      ctx[11]
    ),
    position: (
      /*position*/
      ctx[1]
    ),
    scale: (
      /*scale*/
      ctx[2]
    ),
    rotation: (
      /*rotation*/
      ctx[3]
    ),
    lookAt: (
      /*lookAt*/
      ctx[4]
    ),
    frustumCulled: (
      /*frustumCulled*/
      ctx[8]
    ),
    renderOrder: (
      /*renderOrder*/
      ctx[9]
    ),
    visible: (
      /*visible*/
      ctx[10]
    ),
    castShadow: (
      /*castShadow*/
      ctx[6]
    ),
    receiveShadow: (
      /*receiveShadow*/
      ctx[7]
    ),
    viewportAware: (
      /*viewportAware*/
      ctx[5]
    ),
    $$slots: { default: [create_default_slot5] },
    $$scope: { ctx }
  };
  if (
    /*inViewport*/
    ctx[0] !== void 0
  ) {
    object3dinstance_props.inViewport = /*inViewport*/
    ctx[0];
  }
  object3dinstance = new Object3DInstance_default({
    props: object3dinstance_props,
    $$inline: true
  });
  binding_callbacks.push(() => bind(object3dinstance, "inViewport", object3dinstance_inViewport_binding));
  object3dinstance.$on(
    "viewportenter",
    /*viewportenter_handler*/
    ctx[18]
  );
  object3dinstance.$on(
    "viewportleave",
    /*viewportleave_handler*/
    ctx[19]
  );
  const block = {
    c: function create() {
      create_component(object3dinstance.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(object3dinstance.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(object3dinstance, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const object3dinstance_changes = {};
      if (dirty & /*position*/
      2)
        object3dinstance_changes.position = /*position*/
        ctx2[1];
      if (dirty & /*scale*/
      4)
        object3dinstance_changes.scale = /*scale*/
        ctx2[2];
      if (dirty & /*rotation*/
      8)
        object3dinstance_changes.rotation = /*rotation*/
        ctx2[3];
      if (dirty & /*lookAt*/
      16)
        object3dinstance_changes.lookAt = /*lookAt*/
        ctx2[4];
      if (dirty & /*frustumCulled*/
      256)
        object3dinstance_changes.frustumCulled = /*frustumCulled*/
        ctx2[8];
      if (dirty & /*renderOrder*/
      512)
        object3dinstance_changes.renderOrder = /*renderOrder*/
        ctx2[9];
      if (dirty & /*visible*/
      1024)
        object3dinstance_changes.visible = /*visible*/
        ctx2[10];
      if (dirty & /*castShadow*/
      64)
        object3dinstance_changes.castShadow = /*castShadow*/
        ctx2[6];
      if (dirty & /*receiveShadow*/
      128)
        object3dinstance_changes.receiveShadow = /*receiveShadow*/
        ctx2[7];
      if (dirty & /*viewportAware*/
      32)
        object3dinstance_changes.viewportAware = /*viewportAware*/
        ctx2[5];
      if (dirty & /*$$scope*/
      1048576) {
        object3dinstance_changes.$$scope = { dirty, ctx: ctx2 };
      }
      if (!updating_inViewport && dirty & /*inViewport*/
      1) {
        updating_inViewport = true;
        object3dinstance_changes.inViewport = /*inViewport*/
        ctx2[0];
        add_flush_callback(() => updating_inViewport = false);
      }
      object3dinstance.$set(object3dinstance_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(object3dinstance.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(object3dinstance.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(object3dinstance, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment10.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance10($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("AudioListener", slots, ["default"]);
  let { position = void 0 } = $$props;
  let { scale = void 0 } = $$props;
  let { rotation = void 0 } = $$props;
  let { lookAt = void 0 } = $$props;
  let { viewportAware = false } = $$props;
  let { inViewport = false } = $$props;
  let { castShadow = void 0 } = $$props;
  let { receiveShadow = void 0 } = $$props;
  let { frustumCulled = void 0 } = $$props;
  let { renderOrder = void 0 } = $$props;
  let { visible = void 0 } = $$props;
  let { id = void 0 } = $$props;
  let { masterVolume = void 0 } = $$props;
  const listener = new AudioListener();
  const context = listener.context;
  const resumeContext = async () => await listener.context.resume();
  const { addAudioListener, removeAudioListener } = useThrelteAudio();
  addAudioListener(listener, id);
  onDestroy(() => {
    removeAudioListener(id);
  });
  const writable_props = [
    "position",
    "scale",
    "rotation",
    "lookAt",
    "viewportAware",
    "inViewport",
    "castShadow",
    "receiveShadow",
    "frustumCulled",
    "renderOrder",
    "visible",
    "id",
    "masterVolume"
  ];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<AudioListener> was created with unknown prop '${key}'`);
  });
  function object3dinstance_inViewport_binding(value) {
    inViewport = value;
    $$invalidate(0, inViewport);
  }
  function viewportenter_handler(event) {
    bubble.call(this, $$self, event);
  }
  function viewportleave_handler(event) {
    bubble.call(this, $$self, event);
  }
  $$self.$$set = ($$props2) => {
    if ("position" in $$props2)
      $$invalidate(1, position = $$props2.position);
    if ("scale" in $$props2)
      $$invalidate(2, scale = $$props2.scale);
    if ("rotation" in $$props2)
      $$invalidate(3, rotation = $$props2.rotation);
    if ("lookAt" in $$props2)
      $$invalidate(4, lookAt = $$props2.lookAt);
    if ("viewportAware" in $$props2)
      $$invalidate(5, viewportAware = $$props2.viewportAware);
    if ("inViewport" in $$props2)
      $$invalidate(0, inViewport = $$props2.inViewport);
    if ("castShadow" in $$props2)
      $$invalidate(6, castShadow = $$props2.castShadow);
    if ("receiveShadow" in $$props2)
      $$invalidate(7, receiveShadow = $$props2.receiveShadow);
    if ("frustumCulled" in $$props2)
      $$invalidate(8, frustumCulled = $$props2.frustumCulled);
    if ("renderOrder" in $$props2)
      $$invalidate(9, renderOrder = $$props2.renderOrder);
    if ("visible" in $$props2)
      $$invalidate(10, visible = $$props2.visible);
    if ("id" in $$props2)
      $$invalidate(12, id = $$props2.id);
    if ("masterVolume" in $$props2)
      $$invalidate(13, masterVolume = $$props2.masterVolume);
    if ("$$scope" in $$props2)
      $$invalidate(20, $$scope = $$props2.$$scope);
  };
  $$self.$capture_state = () => ({
    onDestroy,
    ThreeAudioListener: AudioListener,
    useThrelteAudio,
    Object3DInstance: Object3DInstance_default,
    position,
    scale,
    rotation,
    lookAt,
    viewportAware,
    inViewport,
    castShadow,
    receiveShadow,
    frustumCulled,
    renderOrder,
    visible,
    id,
    masterVolume,
    listener,
    context,
    resumeContext,
    addAudioListener,
    removeAudioListener
  });
  $$self.$inject_state = ($$props2) => {
    if ("position" in $$props2)
      $$invalidate(1, position = $$props2.position);
    if ("scale" in $$props2)
      $$invalidate(2, scale = $$props2.scale);
    if ("rotation" in $$props2)
      $$invalidate(3, rotation = $$props2.rotation);
    if ("lookAt" in $$props2)
      $$invalidate(4, lookAt = $$props2.lookAt);
    if ("viewportAware" in $$props2)
      $$invalidate(5, viewportAware = $$props2.viewportAware);
    if ("inViewport" in $$props2)
      $$invalidate(0, inViewport = $$props2.inViewport);
    if ("castShadow" in $$props2)
      $$invalidate(6, castShadow = $$props2.castShadow);
    if ("receiveShadow" in $$props2)
      $$invalidate(7, receiveShadow = $$props2.receiveShadow);
    if ("frustumCulled" in $$props2)
      $$invalidate(8, frustumCulled = $$props2.frustumCulled);
    if ("renderOrder" in $$props2)
      $$invalidate(9, renderOrder = $$props2.renderOrder);
    if ("visible" in $$props2)
      $$invalidate(10, visible = $$props2.visible);
    if ("id" in $$props2)
      $$invalidate(12, id = $$props2.id);
    if ("masterVolume" in $$props2)
      $$invalidate(13, masterVolume = $$props2.masterVolume);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*masterVolume*/
    8192) {
      $:
        if (masterVolume !== void 0)
          listener.setMasterVolume(masterVolume);
    }
  };
  return [
    inViewport,
    position,
    scale,
    rotation,
    lookAt,
    viewportAware,
    castShadow,
    receiveShadow,
    frustumCulled,
    renderOrder,
    visible,
    listener,
    id,
    masterVolume,
    context,
    resumeContext,
    slots,
    object3dinstance_inViewport_binding,
    viewportenter_handler,
    viewportleave_handler,
    $$scope
  ];
}
var AudioListener2 = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance10, create_fragment10, safe_not_equal, {
      position: 1,
      scale: 2,
      rotation: 3,
      lookAt: 4,
      viewportAware: 5,
      inViewport: 0,
      castShadow: 6,
      receiveShadow: 7,
      frustumCulled: 8,
      renderOrder: 9,
      visible: 10,
      id: 12,
      masterVolume: 13,
      listener: 11,
      context: 14,
      resumeContext: 15
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "AudioListener",
      options,
      id: create_fragment10.name
    });
  }
  get position() {
    throw new Error("<AudioListener>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set position(value) {
    throw new Error("<AudioListener>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get scale() {
    throw new Error("<AudioListener>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set scale(value) {
    throw new Error("<AudioListener>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get rotation() {
    throw new Error("<AudioListener>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set rotation(value) {
    throw new Error("<AudioListener>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get lookAt() {
    throw new Error("<AudioListener>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set lookAt(value) {
    throw new Error("<AudioListener>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get viewportAware() {
    throw new Error("<AudioListener>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set viewportAware(value) {
    throw new Error("<AudioListener>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get inViewport() {
    throw new Error("<AudioListener>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set inViewport(value) {
    throw new Error("<AudioListener>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get castShadow() {
    throw new Error("<AudioListener>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set castShadow(value) {
    throw new Error("<AudioListener>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get receiveShadow() {
    throw new Error("<AudioListener>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set receiveShadow(value) {
    throw new Error("<AudioListener>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get frustumCulled() {
    throw new Error("<AudioListener>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set frustumCulled(value) {
    throw new Error("<AudioListener>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get renderOrder() {
    throw new Error("<AudioListener>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set renderOrder(value) {
    throw new Error("<AudioListener>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get visible() {
    throw new Error("<AudioListener>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set visible(value) {
    throw new Error("<AudioListener>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get id() {
    throw new Error("<AudioListener>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set id(value) {
    throw new Error("<AudioListener>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get masterVolume() {
    throw new Error("<AudioListener>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set masterVolume(value) {
    throw new Error("<AudioListener>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get listener() {
    return this.$$.ctx[11];
  }
  set listener(value) {
    throw new Error("<AudioListener>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get context() {
    return this.$$.ctx[14];
  }
  set context(value) {
    throw new Error("<AudioListener>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get resumeContext() {
    return this.$$.ctx[15];
  }
  set resumeContext(value) {
    throw new Error("<AudioListener>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var AudioListener_default = AudioListener2;

// node_modules/threlte/hooks/useLoader.js
var loaders = [];
var useLoader = (loader2, memoizeFn) => {
  const maybeLoader = loaders.find((ll) => ll instanceof loader2);
  if (maybeLoader)
    return maybeLoader;
  const newLoader = memoizeFn();
  loaders.push(newLoader);
  return newLoader;
};

// node_modules/threlte/instances/AudioInstance.svelte
var { console: console_1 } = globals;
function create_default_slot6(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[23].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[27],
    null
  );
  const block = {
    c: function create() {
      if (default_slot)
        default_slot.c();
    },
    l: function claim(nodes) {
      if (default_slot)
        default_slot.l(nodes);
    },
    m: function mount(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty[0] & /*$$scope*/
        134217728)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[27],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[27]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[27],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot6.name,
    type: "slot",
    source: "(146:0) <Object3DInstance   object={audio}   {position}   {scale}   {rotation}   {lookAt}   {frustumCulled}   {renderOrder}   {visible}   {castShadow}   {receiveShadow}   {viewportAware}   bind:inViewport   on:viewportenter   on:viewportleave >",
    ctx
  });
  return block;
}
function create_fragment11(ctx) {
  let object3dinstance;
  let updating_inViewport;
  let current;
  function object3dinstance_inViewport_binding(value) {
    ctx[24](value);
  }
  let object3dinstance_props = {
    object: (
      /*audio*/
      ctx[0]
    ),
    position: (
      /*position*/
      ctx[2]
    ),
    scale: (
      /*scale*/
      ctx[3]
    ),
    rotation: (
      /*rotation*/
      ctx[4]
    ),
    lookAt: (
      /*lookAt*/
      ctx[5]
    ),
    frustumCulled: (
      /*frustumCulled*/
      ctx[9]
    ),
    renderOrder: (
      /*renderOrder*/
      ctx[10]
    ),
    visible: (
      /*visible*/
      ctx[11]
    ),
    castShadow: (
      /*castShadow*/
      ctx[7]
    ),
    receiveShadow: (
      /*receiveShadow*/
      ctx[8]
    ),
    viewportAware: (
      /*viewportAware*/
      ctx[6]
    ),
    $$slots: { default: [create_default_slot6] },
    $$scope: { ctx }
  };
  if (
    /*inViewport*/
    ctx[1] !== void 0
  ) {
    object3dinstance_props.inViewport = /*inViewport*/
    ctx[1];
  }
  object3dinstance = new Object3DInstance_default({
    props: object3dinstance_props,
    $$inline: true
  });
  binding_callbacks.push(() => bind(object3dinstance, "inViewport", object3dinstance_inViewport_binding));
  object3dinstance.$on(
    "viewportenter",
    /*viewportenter_handler*/
    ctx[25]
  );
  object3dinstance.$on(
    "viewportleave",
    /*viewportleave_handler*/
    ctx[26]
  );
  const block = {
    c: function create() {
      create_component(object3dinstance.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(object3dinstance.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(object3dinstance, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const object3dinstance_changes = {};
      if (dirty[0] & /*audio*/
      1)
        object3dinstance_changes.object = /*audio*/
        ctx2[0];
      if (dirty[0] & /*position*/
      4)
        object3dinstance_changes.position = /*position*/
        ctx2[2];
      if (dirty[0] & /*scale*/
      8)
        object3dinstance_changes.scale = /*scale*/
        ctx2[3];
      if (dirty[0] & /*rotation*/
      16)
        object3dinstance_changes.rotation = /*rotation*/
        ctx2[4];
      if (dirty[0] & /*lookAt*/
      32)
        object3dinstance_changes.lookAt = /*lookAt*/
        ctx2[5];
      if (dirty[0] & /*frustumCulled*/
      512)
        object3dinstance_changes.frustumCulled = /*frustumCulled*/
        ctx2[9];
      if (dirty[0] & /*renderOrder*/
      1024)
        object3dinstance_changes.renderOrder = /*renderOrder*/
        ctx2[10];
      if (dirty[0] & /*visible*/
      2048)
        object3dinstance_changes.visible = /*visible*/
        ctx2[11];
      if (dirty[0] & /*castShadow*/
      128)
        object3dinstance_changes.castShadow = /*castShadow*/
        ctx2[7];
      if (dirty[0] & /*receiveShadow*/
      256)
        object3dinstance_changes.receiveShadow = /*receiveShadow*/
        ctx2[8];
      if (dirty[0] & /*viewportAware*/
      64)
        object3dinstance_changes.viewportAware = /*viewportAware*/
        ctx2[6];
      if (dirty[0] & /*$$scope*/
      134217728) {
        object3dinstance_changes.$$scope = { dirty, ctx: ctx2 };
      }
      if (!updating_inViewport && dirty[0] & /*inViewport*/
      2) {
        updating_inViewport = true;
        object3dinstance_changes.inViewport = /*inViewport*/
        ctx2[1];
        add_flush_callback(() => updating_inViewport = false);
      }
      object3dinstance.$set(object3dinstance_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(object3dinstance.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(object3dinstance.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(object3dinstance, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment11.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance11($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("AudioInstance", slots, ["default"]);
  let { position = void 0 } = $$props;
  let { scale = void 0 } = $$props;
  let { rotation = void 0 } = $$props;
  let { lookAt = void 0 } = $$props;
  let { viewportAware = false } = $$props;
  let { inViewport = false } = $$props;
  let { castShadow = void 0 } = $$props;
  let { receiveShadow = void 0 } = $$props;
  let { frustumCulled = void 0 } = $$props;
  let { renderOrder = void 0 } = $$props;
  let { visible = void 0 } = $$props;
  let { autoplay = void 0 } = $$props;
  let { detune = void 0 } = $$props;
  let { source = void 0 } = $$props;
  let { volume = void 0 } = $$props;
  let { loop = void 0 } = $$props;
  let { filters = void 0 } = $$props;
  let { playbackRate = void 0 } = $$props;
  let { audio } = $$props;
  const play = async (delay) => {
    if (audio.context.state !== "running") {
      await audio.context.resume();
    }
    delay && typeof delay === "number" ? audio.play(delay) : audio.play();
    setDetune(detune);
    return audio;
  };
  const pause = () => audio.pause();
  const stop = () => {
    if (!audio.source)
      return audio;
    return audio.stop();
  };
  const setDetune = (detune2) => {
    if (detune2 !== void 0 && audio.source && audio.source.detune) {
      audio.setDetune(detune2);
    }
  };
  const dispatch = createEventDispatcher();
  const loader2 = useLoader(AudioLoader, () => new AudioLoader());
  const loadBufferFromUrl = (url) => {
    return new Promise((resolve, reject) => {
      loader2.load(
        url,
        (buffer) => {
          dispatch("load", buffer);
          resolve(buffer);
        },
        (e) => {
          dispatch("progress", e);
        },
        (e) => {
          dispatch("error", e);
          reject(e);
        }
      );
    });
  };
  let previousSource;
  const onSourceChange = async (newSource, signal) => {
    if (!newSource) {
      previousSource = newSource;
      stop();
      return;
    }
    if (!newSource || newSource === previousSource) {
      stop();
      return;
    }
    previousSource = newSource;
    let aborted = false;
    const onAbort = () => {
      aborted = true;
    };
    signal.addEventListener("abort", onAbort, { once: true });
    if (typeof newSource === "string") {
      const buffer = await loadBufferFromUrl(newSource);
      if (aborted)
        return;
      stop();
      audio.setBuffer(buffer);
    } else if (newSource instanceof AudioBuffer) {
      if (aborted)
        return;
      stop();
      audio.setBuffer(newSource);
    } else if (newSource instanceof HTMLMediaElement) {
      if (aborted)
        return;
      stop();
      audio.setMediaElementSource(newSource);
    } else if (newSource instanceof MediaStream) {
      if (aborted)
        return;
      stop();
      audio.setMediaStreamSource(newSource);
    } else if (newSource instanceof AudioBufferSourceNode) {
      if (aborted)
        return;
      stop();
      audio.setNodeSource(newSource);
    }
    signal.removeEventListener("abort", onAbort);
  };
  let ac;
  onDestroy(() => {
    try {
      stop();
      if (ac)
        ac.abort;
      if (audio.source)
        audio.disconnect();
    } catch (error) {
      console.warn("Error unmounting <AudioInstance>");
      console.error(error);
    }
  });
  $$self.$$.on_mount.push(function() {
    if (audio === void 0 && !("audio" in $$props || $$self.$$.bound[$$self.$$.props["audio"]])) {
      console_1.warn("<AudioInstance> was created without expected prop 'audio'");
    }
  });
  const writable_props = [
    "position",
    "scale",
    "rotation",
    "lookAt",
    "viewportAware",
    "inViewport",
    "castShadow",
    "receiveShadow",
    "frustumCulled",
    "renderOrder",
    "visible",
    "autoplay",
    "detune",
    "source",
    "volume",
    "loop",
    "filters",
    "playbackRate",
    "audio"
  ];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console_1.warn(`<AudioInstance> was created with unknown prop '${key}'`);
  });
  function object3dinstance_inViewport_binding(value) {
    inViewport = value;
    $$invalidate(1, inViewport);
  }
  function viewportenter_handler(event) {
    bubble.call(this, $$self, event);
  }
  function viewportleave_handler(event) {
    bubble.call(this, $$self, event);
  }
  $$self.$$set = ($$props2) => {
    if ("position" in $$props2)
      $$invalidate(2, position = $$props2.position);
    if ("scale" in $$props2)
      $$invalidate(3, scale = $$props2.scale);
    if ("rotation" in $$props2)
      $$invalidate(4, rotation = $$props2.rotation);
    if ("lookAt" in $$props2)
      $$invalidate(5, lookAt = $$props2.lookAt);
    if ("viewportAware" in $$props2)
      $$invalidate(6, viewportAware = $$props2.viewportAware);
    if ("inViewport" in $$props2)
      $$invalidate(1, inViewport = $$props2.inViewport);
    if ("castShadow" in $$props2)
      $$invalidate(7, castShadow = $$props2.castShadow);
    if ("receiveShadow" in $$props2)
      $$invalidate(8, receiveShadow = $$props2.receiveShadow);
    if ("frustumCulled" in $$props2)
      $$invalidate(9, frustumCulled = $$props2.frustumCulled);
    if ("renderOrder" in $$props2)
      $$invalidate(10, renderOrder = $$props2.renderOrder);
    if ("visible" in $$props2)
      $$invalidate(11, visible = $$props2.visible);
    if ("autoplay" in $$props2)
      $$invalidate(12, autoplay = $$props2.autoplay);
    if ("detune" in $$props2)
      $$invalidate(13, detune = $$props2.detune);
    if ("source" in $$props2)
      $$invalidate(14, source = $$props2.source);
    if ("volume" in $$props2)
      $$invalidate(15, volume = $$props2.volume);
    if ("loop" in $$props2)
      $$invalidate(16, loop = $$props2.loop);
    if ("filters" in $$props2)
      $$invalidate(17, filters = $$props2.filters);
    if ("playbackRate" in $$props2)
      $$invalidate(18, playbackRate = $$props2.playbackRate);
    if ("audio" in $$props2)
      $$invalidate(0, audio = $$props2.audio);
    if ("$$scope" in $$props2)
      $$invalidate(27, $$scope = $$props2.$$scope);
  };
  $$self.$capture_state = () => ({
    createEventDispatcher,
    onDestroy,
    Audio,
    AudioLoader,
    PositionalAudio,
    useLoader,
    Object3DInstance: Object3DInstance_default,
    position,
    scale,
    rotation,
    lookAt,
    viewportAware,
    inViewport,
    castShadow,
    receiveShadow,
    frustumCulled,
    renderOrder,
    visible,
    autoplay,
    detune,
    source,
    volume,
    loop,
    filters,
    playbackRate,
    audio,
    play,
    pause,
    stop,
    setDetune,
    dispatch,
    loader: loader2,
    loadBufferFromUrl,
    previousSource,
    onSourceChange,
    ac
  });
  $$self.$inject_state = ($$props2) => {
    if ("position" in $$props2)
      $$invalidate(2, position = $$props2.position);
    if ("scale" in $$props2)
      $$invalidate(3, scale = $$props2.scale);
    if ("rotation" in $$props2)
      $$invalidate(4, rotation = $$props2.rotation);
    if ("lookAt" in $$props2)
      $$invalidate(5, lookAt = $$props2.lookAt);
    if ("viewportAware" in $$props2)
      $$invalidate(6, viewportAware = $$props2.viewportAware);
    if ("inViewport" in $$props2)
      $$invalidate(1, inViewport = $$props2.inViewport);
    if ("castShadow" in $$props2)
      $$invalidate(7, castShadow = $$props2.castShadow);
    if ("receiveShadow" in $$props2)
      $$invalidate(8, receiveShadow = $$props2.receiveShadow);
    if ("frustumCulled" in $$props2)
      $$invalidate(9, frustumCulled = $$props2.frustumCulled);
    if ("renderOrder" in $$props2)
      $$invalidate(10, renderOrder = $$props2.renderOrder);
    if ("visible" in $$props2)
      $$invalidate(11, visible = $$props2.visible);
    if ("autoplay" in $$props2)
      $$invalidate(12, autoplay = $$props2.autoplay);
    if ("detune" in $$props2)
      $$invalidate(13, detune = $$props2.detune);
    if ("source" in $$props2)
      $$invalidate(14, source = $$props2.source);
    if ("volume" in $$props2)
      $$invalidate(15, volume = $$props2.volume);
    if ("loop" in $$props2)
      $$invalidate(16, loop = $$props2.loop);
    if ("filters" in $$props2)
      $$invalidate(17, filters = $$props2.filters);
    if ("playbackRate" in $$props2)
      $$invalidate(18, playbackRate = $$props2.playbackRate);
    if ("audio" in $$props2)
      $$invalidate(0, audio = $$props2.audio);
    if ("previousSource" in $$props2)
      previousSource = $$props2.previousSource;
    if ("ac" in $$props2)
      $$invalidate(22, ac = $$props2.ac);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty[0] & /*autoplay*/
    4096) {
      $:
        if (autoplay !== void 0)
          $$invalidate(0, audio.autoplay = autoplay, audio);
    }
    if ($$self.$$.dirty[0] & /*detune*/
    8192) {
      $:
        setDetune(detune);
    }
    if ($$self.$$.dirty[0] & /*volume, audio*/
    32769) {
      $:
        if (volume !== void 0)
          audio.setVolume(volume);
    }
    if ($$self.$$.dirty[0] & /*loop, audio*/
    65537) {
      $:
        if (loop !== void 0)
          audio.setLoop(loop);
    }
    if ($$self.$$.dirty[0] & /*filters, audio*/
    131073) {
      $:
        if (filters !== void 0)
          Array.isArray(filters) ? audio.setFilters(filters) : audio.setFilter(filters);
    }
    if ($$self.$$.dirty[0] & /*playbackRate, audio*/
    262145) {
      $:
        if (playbackRate !== void 0)
          audio.setPlaybackRate(playbackRate);
    }
    if ($$self.$$.dirty[0] & /*ac, source*/
    4210688) {
      $: {
        if (ac)
          ac.abort();
        $$invalidate(22, ac = new AbortController());
        onSourceChange(source, ac.signal);
      }
    }
  };
  return [
    audio,
    inViewport,
    position,
    scale,
    rotation,
    lookAt,
    viewportAware,
    castShadow,
    receiveShadow,
    frustumCulled,
    renderOrder,
    visible,
    autoplay,
    detune,
    source,
    volume,
    loop,
    filters,
    playbackRate,
    play,
    pause,
    stop,
    ac,
    slots,
    object3dinstance_inViewport_binding,
    viewportenter_handler,
    viewportleave_handler,
    $$scope
  ];
}
var AudioInstance = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(
      this,
      options,
      instance11,
      create_fragment11,
      safe_not_equal,
      {
        position: 2,
        scale: 3,
        rotation: 4,
        lookAt: 5,
        viewportAware: 6,
        inViewport: 1,
        castShadow: 7,
        receiveShadow: 8,
        frustumCulled: 9,
        renderOrder: 10,
        visible: 11,
        autoplay: 12,
        detune: 13,
        source: 14,
        volume: 15,
        loop: 16,
        filters: 17,
        playbackRate: 18,
        audio: 0,
        play: 19,
        pause: 20,
        stop: 21
      },
      null,
      [-1, -1]
    );
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "AudioInstance",
      options,
      id: create_fragment11.name
    });
  }
  get position() {
    throw new Error("<AudioInstance>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set position(value) {
    throw new Error("<AudioInstance>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get scale() {
    throw new Error("<AudioInstance>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set scale(value) {
    throw new Error("<AudioInstance>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get rotation() {
    throw new Error("<AudioInstance>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set rotation(value) {
    throw new Error("<AudioInstance>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get lookAt() {
    throw new Error("<AudioInstance>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set lookAt(value) {
    throw new Error("<AudioInstance>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get viewportAware() {
    throw new Error("<AudioInstance>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set viewportAware(value) {
    throw new Error("<AudioInstance>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get inViewport() {
    throw new Error("<AudioInstance>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set inViewport(value) {
    throw new Error("<AudioInstance>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get castShadow() {
    throw new Error("<AudioInstance>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set castShadow(value) {
    throw new Error("<AudioInstance>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get receiveShadow() {
    throw new Error("<AudioInstance>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set receiveShadow(value) {
    throw new Error("<AudioInstance>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get frustumCulled() {
    throw new Error("<AudioInstance>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set frustumCulled(value) {
    throw new Error("<AudioInstance>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get renderOrder() {
    throw new Error("<AudioInstance>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set renderOrder(value) {
    throw new Error("<AudioInstance>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get visible() {
    throw new Error("<AudioInstance>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set visible(value) {
    throw new Error("<AudioInstance>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get autoplay() {
    throw new Error("<AudioInstance>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set autoplay(value) {
    throw new Error("<AudioInstance>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get detune() {
    throw new Error("<AudioInstance>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set detune(value) {
    throw new Error("<AudioInstance>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get source() {
    throw new Error("<AudioInstance>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set source(value) {
    throw new Error("<AudioInstance>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get volume() {
    throw new Error("<AudioInstance>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set volume(value) {
    throw new Error("<AudioInstance>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get loop() {
    throw new Error("<AudioInstance>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set loop(value) {
    throw new Error("<AudioInstance>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get filters() {
    throw new Error("<AudioInstance>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set filters(value) {
    throw new Error("<AudioInstance>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get playbackRate() {
    throw new Error("<AudioInstance>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set playbackRate(value) {
    throw new Error("<AudioInstance>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get audio() {
    throw new Error("<AudioInstance>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set audio(value) {
    throw new Error("<AudioInstance>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get play() {
    return this.$$.ctx[19];
  }
  set play(value) {
    throw new Error("<AudioInstance>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get pause() {
    return this.$$.ctx[20];
  }
  set pause(value) {
    throw new Error("<AudioInstance>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get stop() {
    return this.$$.ctx[21];
  }
  set stop(value) {
    throw new Error("<AudioInstance>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var AudioInstance_default = AudioInstance;

// node_modules/threlte/audio/Audio.svelte
var { Error: Error_1 } = globals;
function create_default_slot7(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[23].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[33],
    null
  );
  const block = {
    c: function create() {
      if (default_slot)
        default_slot.c();
    },
    l: function claim(nodes) {
      if (default_slot)
        default_slot.l(nodes);
    },
    m: function mount(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty[1] & /*$$scope*/
        4)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[33],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[33]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[33],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot7.name,
    type: "slot",
    source: "(34:0) <AudioInstance   {audio}   {position}   {scale}   {rotation}   {lookAt}   {frustumCulled}   {renderOrder}   {visible}   {castShadow}   {receiveShadow}   {viewportAware}   {autoplay}   {source}   {detune}   {loop}   {filters}   {playbackRate}   {volume}   bind:inViewport   on:viewportenter   on:viewportleave   on:load   on:progress   on:error   bind:play   bind:pause   bind:stop >",
    ctx
  });
  return block;
}
function create_fragment12(ctx) {
  let audioinstance;
  let updating_inViewport;
  let updating_play;
  let updating_pause;
  let updating_stop;
  let current;
  function audioinstance_inViewport_binding(value) {
    ctx[24](value);
  }
  function audioinstance_play_binding(value) {
    ctx[25](value);
  }
  function audioinstance_pause_binding(value) {
    ctx[26](value);
  }
  function audioinstance_stop_binding(value) {
    ctx[27](value);
  }
  let audioinstance_props = {
    audio: (
      /*audio*/
      ctx[21]
    ),
    position: (
      /*position*/
      ctx[4]
    ),
    scale: (
      /*scale*/
      ctx[5]
    ),
    rotation: (
      /*rotation*/
      ctx[6]
    ),
    lookAt: (
      /*lookAt*/
      ctx[7]
    ),
    frustumCulled: (
      /*frustumCulled*/
      ctx[11]
    ),
    renderOrder: (
      /*renderOrder*/
      ctx[12]
    ),
    visible: (
      /*visible*/
      ctx[13]
    ),
    castShadow: (
      /*castShadow*/
      ctx[9]
    ),
    receiveShadow: (
      /*receiveShadow*/
      ctx[10]
    ),
    viewportAware: (
      /*viewportAware*/
      ctx[8]
    ),
    autoplay: (
      /*autoplay*/
      ctx[14]
    ),
    source: (
      /*source*/
      ctx[16]
    ),
    detune: (
      /*detune*/
      ctx[15]
    ),
    loop: (
      /*loop*/
      ctx[18]
    ),
    filters: (
      /*filters*/
      ctx[19]
    ),
    playbackRate: (
      /*playbackRate*/
      ctx[20]
    ),
    volume: (
      /*volume*/
      ctx[17]
    ),
    $$slots: { default: [create_default_slot7] },
    $$scope: { ctx }
  };
  if (
    /*inViewport*/
    ctx[0] !== void 0
  ) {
    audioinstance_props.inViewport = /*inViewport*/
    ctx[0];
  }
  if (
    /*play*/
    ctx[1] !== void 0
  ) {
    audioinstance_props.play = /*play*/
    ctx[1];
  }
  if (
    /*pause*/
    ctx[2] !== void 0
  ) {
    audioinstance_props.pause = /*pause*/
    ctx[2];
  }
  if (
    /*stop*/
    ctx[3] !== void 0
  ) {
    audioinstance_props.stop = /*stop*/
    ctx[3];
  }
  audioinstance = new AudioInstance_default({
    props: audioinstance_props,
    $$inline: true
  });
  binding_callbacks.push(() => bind(audioinstance, "inViewport", audioinstance_inViewport_binding));
  binding_callbacks.push(() => bind(audioinstance, "play", audioinstance_play_binding));
  binding_callbacks.push(() => bind(audioinstance, "pause", audioinstance_pause_binding));
  binding_callbacks.push(() => bind(audioinstance, "stop", audioinstance_stop_binding));
  audioinstance.$on(
    "viewportenter",
    /*viewportenter_handler*/
    ctx[28]
  );
  audioinstance.$on(
    "viewportleave",
    /*viewportleave_handler*/
    ctx[29]
  );
  audioinstance.$on(
    "load",
    /*load_handler*/
    ctx[30]
  );
  audioinstance.$on(
    "progress",
    /*progress_handler*/
    ctx[31]
  );
  audioinstance.$on(
    "error",
    /*error_handler*/
    ctx[32]
  );
  const block = {
    c: function create() {
      create_component(audioinstance.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(audioinstance.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(audioinstance, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const audioinstance_changes = {};
      if (dirty[0] & /*position*/
      16)
        audioinstance_changes.position = /*position*/
        ctx2[4];
      if (dirty[0] & /*scale*/
      32)
        audioinstance_changes.scale = /*scale*/
        ctx2[5];
      if (dirty[0] & /*rotation*/
      64)
        audioinstance_changes.rotation = /*rotation*/
        ctx2[6];
      if (dirty[0] & /*lookAt*/
      128)
        audioinstance_changes.lookAt = /*lookAt*/
        ctx2[7];
      if (dirty[0] & /*frustumCulled*/
      2048)
        audioinstance_changes.frustumCulled = /*frustumCulled*/
        ctx2[11];
      if (dirty[0] & /*renderOrder*/
      4096)
        audioinstance_changes.renderOrder = /*renderOrder*/
        ctx2[12];
      if (dirty[0] & /*visible*/
      8192)
        audioinstance_changes.visible = /*visible*/
        ctx2[13];
      if (dirty[0] & /*castShadow*/
      512)
        audioinstance_changes.castShadow = /*castShadow*/
        ctx2[9];
      if (dirty[0] & /*receiveShadow*/
      1024)
        audioinstance_changes.receiveShadow = /*receiveShadow*/
        ctx2[10];
      if (dirty[0] & /*viewportAware*/
      256)
        audioinstance_changes.viewportAware = /*viewportAware*/
        ctx2[8];
      if (dirty[0] & /*autoplay*/
      16384)
        audioinstance_changes.autoplay = /*autoplay*/
        ctx2[14];
      if (dirty[0] & /*source*/
      65536)
        audioinstance_changes.source = /*source*/
        ctx2[16];
      if (dirty[0] & /*detune*/
      32768)
        audioinstance_changes.detune = /*detune*/
        ctx2[15];
      if (dirty[0] & /*loop*/
      262144)
        audioinstance_changes.loop = /*loop*/
        ctx2[18];
      if (dirty[0] & /*filters*/
      524288)
        audioinstance_changes.filters = /*filters*/
        ctx2[19];
      if (dirty[0] & /*playbackRate*/
      1048576)
        audioinstance_changes.playbackRate = /*playbackRate*/
        ctx2[20];
      if (dirty[0] & /*volume*/
      131072)
        audioinstance_changes.volume = /*volume*/
        ctx2[17];
      if (dirty[1] & /*$$scope*/
      4) {
        audioinstance_changes.$$scope = { dirty, ctx: ctx2 };
      }
      if (!updating_inViewport && dirty[0] & /*inViewport*/
      1) {
        updating_inViewport = true;
        audioinstance_changes.inViewport = /*inViewport*/
        ctx2[0];
        add_flush_callback(() => updating_inViewport = false);
      }
      if (!updating_play && dirty[0] & /*play*/
      2) {
        updating_play = true;
        audioinstance_changes.play = /*play*/
        ctx2[1];
        add_flush_callback(() => updating_play = false);
      }
      if (!updating_pause && dirty[0] & /*pause*/
      4) {
        updating_pause = true;
        audioinstance_changes.pause = /*pause*/
        ctx2[2];
        add_flush_callback(() => updating_pause = false);
      }
      if (!updating_stop && dirty[0] & /*stop*/
      8) {
        updating_stop = true;
        audioinstance_changes.stop = /*stop*/
        ctx2[3];
        add_flush_callback(() => updating_stop = false);
      }
      audioinstance.$set(audioinstance_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(audioinstance.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(audioinstance.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(audioinstance, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment12.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance12($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Audio", slots, ["default"]);
  let { position = void 0 } = $$props;
  let { scale = void 0 } = $$props;
  let { rotation = void 0 } = $$props;
  let { lookAt = void 0 } = $$props;
  let { viewportAware = false } = $$props;
  let { inViewport = false } = $$props;
  let { castShadow = void 0 } = $$props;
  let { receiveShadow = void 0 } = $$props;
  let { frustumCulled = void 0 } = $$props;
  let { renderOrder = void 0 } = $$props;
  let { visible = void 0 } = $$props;
  let { autoplay = void 0 } = $$props;
  let { detune = void 0 } = $$props;
  let { source = void 0 } = $$props;
  let { volume = void 0 } = $$props;
  let { loop = void 0 } = $$props;
  let { filters = void 0 } = $$props;
  let { playbackRate = void 0 } = $$props;
  let { play = void 0 } = $$props;
  let { pause = void 0 } = $$props;
  let { stop = void 0 } = $$props;
  let { id = void 0 } = $$props;
  const { getAudioListener } = useThrelteAudio();
  const listener = getAudioListener(id);
  if (!listener) {
    throw new Error(`No Audiolistener with id ${id} found.`);
  }
  const audio = new Audio(listener);
  const writable_props = [
    "position",
    "scale",
    "rotation",
    "lookAt",
    "viewportAware",
    "inViewport",
    "castShadow",
    "receiveShadow",
    "frustumCulled",
    "renderOrder",
    "visible",
    "autoplay",
    "detune",
    "source",
    "volume",
    "loop",
    "filters",
    "playbackRate",
    "play",
    "pause",
    "stop",
    "id"
  ];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<Audio> was created with unknown prop '${key}'`);
  });
  function audioinstance_inViewport_binding(value) {
    inViewport = value;
    $$invalidate(0, inViewport);
  }
  function audioinstance_play_binding(value) {
    play = value;
    $$invalidate(1, play);
  }
  function audioinstance_pause_binding(value) {
    pause = value;
    $$invalidate(2, pause);
  }
  function audioinstance_stop_binding(value) {
    stop = value;
    $$invalidate(3, stop);
  }
  function viewportenter_handler(event) {
    bubble.call(this, $$self, event);
  }
  function viewportleave_handler(event) {
    bubble.call(this, $$self, event);
  }
  function load_handler(event) {
    bubble.call(this, $$self, event);
  }
  function progress_handler(event) {
    bubble.call(this, $$self, event);
  }
  function error_handler(event) {
    bubble.call(this, $$self, event);
  }
  $$self.$$set = ($$props2) => {
    if ("position" in $$props2)
      $$invalidate(4, position = $$props2.position);
    if ("scale" in $$props2)
      $$invalidate(5, scale = $$props2.scale);
    if ("rotation" in $$props2)
      $$invalidate(6, rotation = $$props2.rotation);
    if ("lookAt" in $$props2)
      $$invalidate(7, lookAt = $$props2.lookAt);
    if ("viewportAware" in $$props2)
      $$invalidate(8, viewportAware = $$props2.viewportAware);
    if ("inViewport" in $$props2)
      $$invalidate(0, inViewport = $$props2.inViewport);
    if ("castShadow" in $$props2)
      $$invalidate(9, castShadow = $$props2.castShadow);
    if ("receiveShadow" in $$props2)
      $$invalidate(10, receiveShadow = $$props2.receiveShadow);
    if ("frustumCulled" in $$props2)
      $$invalidate(11, frustumCulled = $$props2.frustumCulled);
    if ("renderOrder" in $$props2)
      $$invalidate(12, renderOrder = $$props2.renderOrder);
    if ("visible" in $$props2)
      $$invalidate(13, visible = $$props2.visible);
    if ("autoplay" in $$props2)
      $$invalidate(14, autoplay = $$props2.autoplay);
    if ("detune" in $$props2)
      $$invalidate(15, detune = $$props2.detune);
    if ("source" in $$props2)
      $$invalidate(16, source = $$props2.source);
    if ("volume" in $$props2)
      $$invalidate(17, volume = $$props2.volume);
    if ("loop" in $$props2)
      $$invalidate(18, loop = $$props2.loop);
    if ("filters" in $$props2)
      $$invalidate(19, filters = $$props2.filters);
    if ("playbackRate" in $$props2)
      $$invalidate(20, playbackRate = $$props2.playbackRate);
    if ("play" in $$props2)
      $$invalidate(1, play = $$props2.play);
    if ("pause" in $$props2)
      $$invalidate(2, pause = $$props2.pause);
    if ("stop" in $$props2)
      $$invalidate(3, stop = $$props2.stop);
    if ("id" in $$props2)
      $$invalidate(22, id = $$props2.id);
    if ("$$scope" in $$props2)
      $$invalidate(33, $$scope = $$props2.$$scope);
  };
  $$self.$capture_state = () => ({
    ThreeAudio: Audio,
    useThrelteAudio,
    AudioInstance: AudioInstance_default,
    position,
    scale,
    rotation,
    lookAt,
    viewportAware,
    inViewport,
    castShadow,
    receiveShadow,
    frustumCulled,
    renderOrder,
    visible,
    autoplay,
    detune,
    source,
    volume,
    loop,
    filters,
    playbackRate,
    play,
    pause,
    stop,
    id,
    getAudioListener,
    listener,
    audio
  });
  $$self.$inject_state = ($$props2) => {
    if ("position" in $$props2)
      $$invalidate(4, position = $$props2.position);
    if ("scale" in $$props2)
      $$invalidate(5, scale = $$props2.scale);
    if ("rotation" in $$props2)
      $$invalidate(6, rotation = $$props2.rotation);
    if ("lookAt" in $$props2)
      $$invalidate(7, lookAt = $$props2.lookAt);
    if ("viewportAware" in $$props2)
      $$invalidate(8, viewportAware = $$props2.viewportAware);
    if ("inViewport" in $$props2)
      $$invalidate(0, inViewport = $$props2.inViewport);
    if ("castShadow" in $$props2)
      $$invalidate(9, castShadow = $$props2.castShadow);
    if ("receiveShadow" in $$props2)
      $$invalidate(10, receiveShadow = $$props2.receiveShadow);
    if ("frustumCulled" in $$props2)
      $$invalidate(11, frustumCulled = $$props2.frustumCulled);
    if ("renderOrder" in $$props2)
      $$invalidate(12, renderOrder = $$props2.renderOrder);
    if ("visible" in $$props2)
      $$invalidate(13, visible = $$props2.visible);
    if ("autoplay" in $$props2)
      $$invalidate(14, autoplay = $$props2.autoplay);
    if ("detune" in $$props2)
      $$invalidate(15, detune = $$props2.detune);
    if ("source" in $$props2)
      $$invalidate(16, source = $$props2.source);
    if ("volume" in $$props2)
      $$invalidate(17, volume = $$props2.volume);
    if ("loop" in $$props2)
      $$invalidate(18, loop = $$props2.loop);
    if ("filters" in $$props2)
      $$invalidate(19, filters = $$props2.filters);
    if ("playbackRate" in $$props2)
      $$invalidate(20, playbackRate = $$props2.playbackRate);
    if ("play" in $$props2)
      $$invalidate(1, play = $$props2.play);
    if ("pause" in $$props2)
      $$invalidate(2, pause = $$props2.pause);
    if ("stop" in $$props2)
      $$invalidate(3, stop = $$props2.stop);
    if ("id" in $$props2)
      $$invalidate(22, id = $$props2.id);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [
    inViewport,
    play,
    pause,
    stop,
    position,
    scale,
    rotation,
    lookAt,
    viewportAware,
    castShadow,
    receiveShadow,
    frustumCulled,
    renderOrder,
    visible,
    autoplay,
    detune,
    source,
    volume,
    loop,
    filters,
    playbackRate,
    audio,
    id,
    slots,
    audioinstance_inViewport_binding,
    audioinstance_play_binding,
    audioinstance_pause_binding,
    audioinstance_stop_binding,
    viewportenter_handler,
    viewportleave_handler,
    load_handler,
    progress_handler,
    error_handler,
    $$scope
  ];
}
var Audio2 = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(
      this,
      options,
      instance12,
      create_fragment12,
      safe_not_equal,
      {
        position: 4,
        scale: 5,
        rotation: 6,
        lookAt: 7,
        viewportAware: 8,
        inViewport: 0,
        castShadow: 9,
        receiveShadow: 10,
        frustumCulled: 11,
        renderOrder: 12,
        visible: 13,
        autoplay: 14,
        detune: 15,
        source: 16,
        volume: 17,
        loop: 18,
        filters: 19,
        playbackRate: 20,
        play: 1,
        pause: 2,
        stop: 3,
        id: 22,
        audio: 21
      },
      null,
      [-1, -1]
    );
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Audio",
      options,
      id: create_fragment12.name
    });
  }
  get position() {
    throw new Error_1("<Audio>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set position(value) {
    throw new Error_1("<Audio>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get scale() {
    throw new Error_1("<Audio>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set scale(value) {
    throw new Error_1("<Audio>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get rotation() {
    throw new Error_1("<Audio>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set rotation(value) {
    throw new Error_1("<Audio>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get lookAt() {
    throw new Error_1("<Audio>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set lookAt(value) {
    throw new Error_1("<Audio>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get viewportAware() {
    throw new Error_1("<Audio>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set viewportAware(value) {
    throw new Error_1("<Audio>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get inViewport() {
    throw new Error_1("<Audio>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set inViewport(value) {
    throw new Error_1("<Audio>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get castShadow() {
    throw new Error_1("<Audio>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set castShadow(value) {
    throw new Error_1("<Audio>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get receiveShadow() {
    throw new Error_1("<Audio>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set receiveShadow(value) {
    throw new Error_1("<Audio>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get frustumCulled() {
    throw new Error_1("<Audio>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set frustumCulled(value) {
    throw new Error_1("<Audio>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get renderOrder() {
    throw new Error_1("<Audio>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set renderOrder(value) {
    throw new Error_1("<Audio>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get visible() {
    throw new Error_1("<Audio>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set visible(value) {
    throw new Error_1("<Audio>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get autoplay() {
    throw new Error_1("<Audio>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set autoplay(value) {
    throw new Error_1("<Audio>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get detune() {
    throw new Error_1("<Audio>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set detune(value) {
    throw new Error_1("<Audio>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get source() {
    throw new Error_1("<Audio>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set source(value) {
    throw new Error_1("<Audio>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get volume() {
    throw new Error_1("<Audio>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set volume(value) {
    throw new Error_1("<Audio>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get loop() {
    throw new Error_1("<Audio>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set loop(value) {
    throw new Error_1("<Audio>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get filters() {
    throw new Error_1("<Audio>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set filters(value) {
    throw new Error_1("<Audio>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get playbackRate() {
    throw new Error_1("<Audio>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set playbackRate(value) {
    throw new Error_1("<Audio>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get play() {
    throw new Error_1("<Audio>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set play(value) {
    throw new Error_1("<Audio>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get pause() {
    throw new Error_1("<Audio>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set pause(value) {
    throw new Error_1("<Audio>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get stop() {
    throw new Error_1("<Audio>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set stop(value) {
    throw new Error_1("<Audio>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get id() {
    throw new Error_1("<Audio>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set id(value) {
    throw new Error_1("<Audio>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get audio() {
    return this.$$.ctx[21];
  }
  set audio(value) {
    throw new Error_1("<Audio>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Audio_default = Audio2;

// node_modules/threlte/audio/PositionalAudio.svelte
var { Error: Error_12 } = globals;
function create_default_slot8(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[28].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[38],
    null
  );
  const block = {
    c: function create() {
      if (default_slot)
        default_slot.c();
    },
    l: function claim(nodes) {
      if (default_slot)
        default_slot.l(nodes);
    },
    m: function mount(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty[1] & /*$$scope*/
        128)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[38],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[38]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[38],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot8.name,
    type: "slot",
    source: "(52:0) <AudioInstance   {audio}   {position}   {filters}   {playbackRate}   {scale}   {rotation}   {lookAt}   {frustumCulled}   {renderOrder}   {visible}   {castShadow}   {receiveShadow}   {viewportAware}   {autoplay}   {source}   {detune}   {loop}   {volume}   bind:inViewport   on:viewportenter   on:viewportleave   on:load   on:progress   on:error   bind:play   bind:pause   bind:stop >",
    ctx
  });
  return block;
}
function create_fragment13(ctx) {
  let audioinstance;
  let updating_inViewport;
  let updating_play;
  let updating_pause;
  let updating_stop;
  let current;
  function audioinstance_inViewport_binding(value) {
    ctx[29](value);
  }
  function audioinstance_play_binding(value) {
    ctx[30](value);
  }
  function audioinstance_pause_binding(value) {
    ctx[31](value);
  }
  function audioinstance_stop_binding(value) {
    ctx[32](value);
  }
  let audioinstance_props = {
    audio: (
      /*audio*/
      ctx[21]
    ),
    position: (
      /*position*/
      ctx[4]
    ),
    filters: (
      /*filters*/
      ctx[19]
    ),
    playbackRate: (
      /*playbackRate*/
      ctx[20]
    ),
    scale: (
      /*scale*/
      ctx[5]
    ),
    rotation: (
      /*rotation*/
      ctx[6]
    ),
    lookAt: (
      /*lookAt*/
      ctx[7]
    ),
    frustumCulled: (
      /*frustumCulled*/
      ctx[11]
    ),
    renderOrder: (
      /*renderOrder*/
      ctx[12]
    ),
    visible: (
      /*visible*/
      ctx[13]
    ),
    castShadow: (
      /*castShadow*/
      ctx[9]
    ),
    receiveShadow: (
      /*receiveShadow*/
      ctx[10]
    ),
    viewportAware: (
      /*viewportAware*/
      ctx[8]
    ),
    autoplay: (
      /*autoplay*/
      ctx[14]
    ),
    source: (
      /*source*/
      ctx[16]
    ),
    detune: (
      /*detune*/
      ctx[15]
    ),
    loop: (
      /*loop*/
      ctx[18]
    ),
    volume: (
      /*volume*/
      ctx[17]
    ),
    $$slots: { default: [create_default_slot8] },
    $$scope: { ctx }
  };
  if (
    /*inViewport*/
    ctx[0] !== void 0
  ) {
    audioinstance_props.inViewport = /*inViewport*/
    ctx[0];
  }
  if (
    /*play*/
    ctx[1] !== void 0
  ) {
    audioinstance_props.play = /*play*/
    ctx[1];
  }
  if (
    /*pause*/
    ctx[2] !== void 0
  ) {
    audioinstance_props.pause = /*pause*/
    ctx[2];
  }
  if (
    /*stop*/
    ctx[3] !== void 0
  ) {
    audioinstance_props.stop = /*stop*/
    ctx[3];
  }
  audioinstance = new AudioInstance_default({
    props: audioinstance_props,
    $$inline: true
  });
  binding_callbacks.push(() => bind(audioinstance, "inViewport", audioinstance_inViewport_binding));
  binding_callbacks.push(() => bind(audioinstance, "play", audioinstance_play_binding));
  binding_callbacks.push(() => bind(audioinstance, "pause", audioinstance_pause_binding));
  binding_callbacks.push(() => bind(audioinstance, "stop", audioinstance_stop_binding));
  audioinstance.$on(
    "viewportenter",
    /*viewportenter_handler*/
    ctx[33]
  );
  audioinstance.$on(
    "viewportleave",
    /*viewportleave_handler*/
    ctx[34]
  );
  audioinstance.$on(
    "load",
    /*load_handler*/
    ctx[35]
  );
  audioinstance.$on(
    "progress",
    /*progress_handler*/
    ctx[36]
  );
  audioinstance.$on(
    "error",
    /*error_handler*/
    ctx[37]
  );
  const block = {
    c: function create() {
      create_component(audioinstance.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(audioinstance.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(audioinstance, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const audioinstance_changes = {};
      if (dirty[0] & /*position*/
      16)
        audioinstance_changes.position = /*position*/
        ctx2[4];
      if (dirty[0] & /*filters*/
      524288)
        audioinstance_changes.filters = /*filters*/
        ctx2[19];
      if (dirty[0] & /*playbackRate*/
      1048576)
        audioinstance_changes.playbackRate = /*playbackRate*/
        ctx2[20];
      if (dirty[0] & /*scale*/
      32)
        audioinstance_changes.scale = /*scale*/
        ctx2[5];
      if (dirty[0] & /*rotation*/
      64)
        audioinstance_changes.rotation = /*rotation*/
        ctx2[6];
      if (dirty[0] & /*lookAt*/
      128)
        audioinstance_changes.lookAt = /*lookAt*/
        ctx2[7];
      if (dirty[0] & /*frustumCulled*/
      2048)
        audioinstance_changes.frustumCulled = /*frustumCulled*/
        ctx2[11];
      if (dirty[0] & /*renderOrder*/
      4096)
        audioinstance_changes.renderOrder = /*renderOrder*/
        ctx2[12];
      if (dirty[0] & /*visible*/
      8192)
        audioinstance_changes.visible = /*visible*/
        ctx2[13];
      if (dirty[0] & /*castShadow*/
      512)
        audioinstance_changes.castShadow = /*castShadow*/
        ctx2[9];
      if (dirty[0] & /*receiveShadow*/
      1024)
        audioinstance_changes.receiveShadow = /*receiveShadow*/
        ctx2[10];
      if (dirty[0] & /*viewportAware*/
      256)
        audioinstance_changes.viewportAware = /*viewportAware*/
        ctx2[8];
      if (dirty[0] & /*autoplay*/
      16384)
        audioinstance_changes.autoplay = /*autoplay*/
        ctx2[14];
      if (dirty[0] & /*source*/
      65536)
        audioinstance_changes.source = /*source*/
        ctx2[16];
      if (dirty[0] & /*detune*/
      32768)
        audioinstance_changes.detune = /*detune*/
        ctx2[15];
      if (dirty[0] & /*loop*/
      262144)
        audioinstance_changes.loop = /*loop*/
        ctx2[18];
      if (dirty[0] & /*volume*/
      131072)
        audioinstance_changes.volume = /*volume*/
        ctx2[17];
      if (dirty[1] & /*$$scope*/
      128) {
        audioinstance_changes.$$scope = { dirty, ctx: ctx2 };
      }
      if (!updating_inViewport && dirty[0] & /*inViewport*/
      1) {
        updating_inViewport = true;
        audioinstance_changes.inViewport = /*inViewport*/
        ctx2[0];
        add_flush_callback(() => updating_inViewport = false);
      }
      if (!updating_play && dirty[0] & /*play*/
      2) {
        updating_play = true;
        audioinstance_changes.play = /*play*/
        ctx2[1];
        add_flush_callback(() => updating_play = false);
      }
      if (!updating_pause && dirty[0] & /*pause*/
      4) {
        updating_pause = true;
        audioinstance_changes.pause = /*pause*/
        ctx2[2];
        add_flush_callback(() => updating_pause = false);
      }
      if (!updating_stop && dirty[0] & /*stop*/
      8) {
        updating_stop = true;
        audioinstance_changes.stop = /*stop*/
        ctx2[3];
        add_flush_callback(() => updating_stop = false);
      }
      audioinstance.$set(audioinstance_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(audioinstance.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(audioinstance.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(audioinstance, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment13.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance13($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("PositionalAudio", slots, ["default"]);
  let { position = void 0 } = $$props;
  let { scale = void 0 } = $$props;
  let { rotation = void 0 } = $$props;
  let { lookAt = void 0 } = $$props;
  let { viewportAware = false } = $$props;
  let { inViewport = false } = $$props;
  let { castShadow = void 0 } = $$props;
  let { receiveShadow = void 0 } = $$props;
  let { frustumCulled = void 0 } = $$props;
  let { renderOrder = void 0 } = $$props;
  let { visible = void 0 } = $$props;
  let { autoplay = void 0 } = $$props;
  let { detune = void 0 } = $$props;
  let { source = void 0 } = $$props;
  let { volume = void 0 } = $$props;
  let { loop = void 0 } = $$props;
  let { filters = void 0 } = $$props;
  let { playbackRate = void 0 } = $$props;
  let { play = void 0 } = $$props;
  let { pause = void 0 } = $$props;
  let { stop = void 0 } = $$props;
  let { id = void 0 } = $$props;
  let { directionalCone = void 0 } = $$props;
  let { refDistance = void 0 } = $$props;
  let { rolloffFactor = void 0 } = $$props;
  let { distanceModel = void 0 } = $$props;
  let { maxDistance = void 0 } = $$props;
  const { getAudioListener } = useThrelteAudio();
  const listener = getAudioListener(id);
  if (!listener) {
    throw new Error(`No Audiolistener with id ${id} found.`);
  }
  const audio = new PositionalAudio(listener);
  const writable_props = [
    "position",
    "scale",
    "rotation",
    "lookAt",
    "viewportAware",
    "inViewport",
    "castShadow",
    "receiveShadow",
    "frustumCulled",
    "renderOrder",
    "visible",
    "autoplay",
    "detune",
    "source",
    "volume",
    "loop",
    "filters",
    "playbackRate",
    "play",
    "pause",
    "stop",
    "id",
    "directionalCone",
    "refDistance",
    "rolloffFactor",
    "distanceModel",
    "maxDistance"
  ];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<PositionalAudio> was created with unknown prop '${key}'`);
  });
  function audioinstance_inViewport_binding(value) {
    inViewport = value;
    $$invalidate(0, inViewport);
  }
  function audioinstance_play_binding(value) {
    play = value;
    $$invalidate(1, play);
  }
  function audioinstance_pause_binding(value) {
    pause = value;
    $$invalidate(2, pause);
  }
  function audioinstance_stop_binding(value) {
    stop = value;
    $$invalidate(3, stop);
  }
  function viewportenter_handler(event) {
    bubble.call(this, $$self, event);
  }
  function viewportleave_handler(event) {
    bubble.call(this, $$self, event);
  }
  function load_handler(event) {
    bubble.call(this, $$self, event);
  }
  function progress_handler(event) {
    bubble.call(this, $$self, event);
  }
  function error_handler(event) {
    bubble.call(this, $$self, event);
  }
  $$self.$$set = ($$props2) => {
    if ("position" in $$props2)
      $$invalidate(4, position = $$props2.position);
    if ("scale" in $$props2)
      $$invalidate(5, scale = $$props2.scale);
    if ("rotation" in $$props2)
      $$invalidate(6, rotation = $$props2.rotation);
    if ("lookAt" in $$props2)
      $$invalidate(7, lookAt = $$props2.lookAt);
    if ("viewportAware" in $$props2)
      $$invalidate(8, viewportAware = $$props2.viewportAware);
    if ("inViewport" in $$props2)
      $$invalidate(0, inViewport = $$props2.inViewport);
    if ("castShadow" in $$props2)
      $$invalidate(9, castShadow = $$props2.castShadow);
    if ("receiveShadow" in $$props2)
      $$invalidate(10, receiveShadow = $$props2.receiveShadow);
    if ("frustumCulled" in $$props2)
      $$invalidate(11, frustumCulled = $$props2.frustumCulled);
    if ("renderOrder" in $$props2)
      $$invalidate(12, renderOrder = $$props2.renderOrder);
    if ("visible" in $$props2)
      $$invalidate(13, visible = $$props2.visible);
    if ("autoplay" in $$props2)
      $$invalidate(14, autoplay = $$props2.autoplay);
    if ("detune" in $$props2)
      $$invalidate(15, detune = $$props2.detune);
    if ("source" in $$props2)
      $$invalidate(16, source = $$props2.source);
    if ("volume" in $$props2)
      $$invalidate(17, volume = $$props2.volume);
    if ("loop" in $$props2)
      $$invalidate(18, loop = $$props2.loop);
    if ("filters" in $$props2)
      $$invalidate(19, filters = $$props2.filters);
    if ("playbackRate" in $$props2)
      $$invalidate(20, playbackRate = $$props2.playbackRate);
    if ("play" in $$props2)
      $$invalidate(1, play = $$props2.play);
    if ("pause" in $$props2)
      $$invalidate(2, pause = $$props2.pause);
    if ("stop" in $$props2)
      $$invalidate(3, stop = $$props2.stop);
    if ("id" in $$props2)
      $$invalidate(22, id = $$props2.id);
    if ("directionalCone" in $$props2)
      $$invalidate(23, directionalCone = $$props2.directionalCone);
    if ("refDistance" in $$props2)
      $$invalidate(24, refDistance = $$props2.refDistance);
    if ("rolloffFactor" in $$props2)
      $$invalidate(25, rolloffFactor = $$props2.rolloffFactor);
    if ("distanceModel" in $$props2)
      $$invalidate(26, distanceModel = $$props2.distanceModel);
    if ("maxDistance" in $$props2)
      $$invalidate(27, maxDistance = $$props2.maxDistance);
    if ("$$scope" in $$props2)
      $$invalidate(38, $$scope = $$props2.$$scope);
  };
  $$self.$capture_state = () => ({
    ThreePositionalAudio: PositionalAudio,
    useThrelteAudio,
    AudioInstance: AudioInstance_default,
    position,
    scale,
    rotation,
    lookAt,
    viewportAware,
    inViewport,
    castShadow,
    receiveShadow,
    frustumCulled,
    renderOrder,
    visible,
    autoplay,
    detune,
    source,
    volume,
    loop,
    filters,
    playbackRate,
    play,
    pause,
    stop,
    id,
    directionalCone,
    refDistance,
    rolloffFactor,
    distanceModel,
    maxDistance,
    getAudioListener,
    listener,
    audio
  });
  $$self.$inject_state = ($$props2) => {
    if ("position" in $$props2)
      $$invalidate(4, position = $$props2.position);
    if ("scale" in $$props2)
      $$invalidate(5, scale = $$props2.scale);
    if ("rotation" in $$props2)
      $$invalidate(6, rotation = $$props2.rotation);
    if ("lookAt" in $$props2)
      $$invalidate(7, lookAt = $$props2.lookAt);
    if ("viewportAware" in $$props2)
      $$invalidate(8, viewportAware = $$props2.viewportAware);
    if ("inViewport" in $$props2)
      $$invalidate(0, inViewport = $$props2.inViewport);
    if ("castShadow" in $$props2)
      $$invalidate(9, castShadow = $$props2.castShadow);
    if ("receiveShadow" in $$props2)
      $$invalidate(10, receiveShadow = $$props2.receiveShadow);
    if ("frustumCulled" in $$props2)
      $$invalidate(11, frustumCulled = $$props2.frustumCulled);
    if ("renderOrder" in $$props2)
      $$invalidate(12, renderOrder = $$props2.renderOrder);
    if ("visible" in $$props2)
      $$invalidate(13, visible = $$props2.visible);
    if ("autoplay" in $$props2)
      $$invalidate(14, autoplay = $$props2.autoplay);
    if ("detune" in $$props2)
      $$invalidate(15, detune = $$props2.detune);
    if ("source" in $$props2)
      $$invalidate(16, source = $$props2.source);
    if ("volume" in $$props2)
      $$invalidate(17, volume = $$props2.volume);
    if ("loop" in $$props2)
      $$invalidate(18, loop = $$props2.loop);
    if ("filters" in $$props2)
      $$invalidate(19, filters = $$props2.filters);
    if ("playbackRate" in $$props2)
      $$invalidate(20, playbackRate = $$props2.playbackRate);
    if ("play" in $$props2)
      $$invalidate(1, play = $$props2.play);
    if ("pause" in $$props2)
      $$invalidate(2, pause = $$props2.pause);
    if ("stop" in $$props2)
      $$invalidate(3, stop = $$props2.stop);
    if ("id" in $$props2)
      $$invalidate(22, id = $$props2.id);
    if ("directionalCone" in $$props2)
      $$invalidate(23, directionalCone = $$props2.directionalCone);
    if ("refDistance" in $$props2)
      $$invalidate(24, refDistance = $$props2.refDistance);
    if ("rolloffFactor" in $$props2)
      $$invalidate(25, rolloffFactor = $$props2.rolloffFactor);
    if ("distanceModel" in $$props2)
      $$invalidate(26, distanceModel = $$props2.distanceModel);
    if ("maxDistance" in $$props2)
      $$invalidate(27, maxDistance = $$props2.maxDistance);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty[0] & /*refDistance, rolloffFactor, distanceModel, maxDistance, directionalCone*/
    260046848) {
      $: {
        if (refDistance !== void 0)
          audio.setRefDistance(refDistance);
        if (rolloffFactor !== void 0)
          audio.setRolloffFactor(rolloffFactor);
        if (distanceModel !== void 0)
          audio.setDistanceModel(distanceModel);
        if (maxDistance !== void 0)
          audio.setMaxDistance(maxDistance);
        if (directionalCone !== void 0) {
          audio.setDirectionalCone(directionalCone.coneInnerAngle, directionalCone.coneOuterAngle, directionalCone.coneOuterGain);
        }
      }
    }
  };
  return [
    inViewport,
    play,
    pause,
    stop,
    position,
    scale,
    rotation,
    lookAt,
    viewportAware,
    castShadow,
    receiveShadow,
    frustumCulled,
    renderOrder,
    visible,
    autoplay,
    detune,
    source,
    volume,
    loop,
    filters,
    playbackRate,
    audio,
    id,
    directionalCone,
    refDistance,
    rolloffFactor,
    distanceModel,
    maxDistance,
    slots,
    audioinstance_inViewport_binding,
    audioinstance_play_binding,
    audioinstance_pause_binding,
    audioinstance_stop_binding,
    viewportenter_handler,
    viewportleave_handler,
    load_handler,
    progress_handler,
    error_handler,
    $$scope
  ];
}
var PositionalAudio2 = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(
      this,
      options,
      instance13,
      create_fragment13,
      safe_not_equal,
      {
        position: 4,
        scale: 5,
        rotation: 6,
        lookAt: 7,
        viewportAware: 8,
        inViewport: 0,
        castShadow: 9,
        receiveShadow: 10,
        frustumCulled: 11,
        renderOrder: 12,
        visible: 13,
        autoplay: 14,
        detune: 15,
        source: 16,
        volume: 17,
        loop: 18,
        filters: 19,
        playbackRate: 20,
        play: 1,
        pause: 2,
        stop: 3,
        id: 22,
        directionalCone: 23,
        refDistance: 24,
        rolloffFactor: 25,
        distanceModel: 26,
        maxDistance: 27,
        audio: 21
      },
      null,
      [-1, -1]
    );
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "PositionalAudio",
      options,
      id: create_fragment13.name
    });
  }
  get position() {
    throw new Error_12("<PositionalAudio>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set position(value) {
    throw new Error_12("<PositionalAudio>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get scale() {
    throw new Error_12("<PositionalAudio>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set scale(value) {
    throw new Error_12("<PositionalAudio>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get rotation() {
    throw new Error_12("<PositionalAudio>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set rotation(value) {
    throw new Error_12("<PositionalAudio>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get lookAt() {
    throw new Error_12("<PositionalAudio>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set lookAt(value) {
    throw new Error_12("<PositionalAudio>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get viewportAware() {
    throw new Error_12("<PositionalAudio>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set viewportAware(value) {
    throw new Error_12("<PositionalAudio>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get inViewport() {
    throw new Error_12("<PositionalAudio>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set inViewport(value) {
    throw new Error_12("<PositionalAudio>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get castShadow() {
    throw new Error_12("<PositionalAudio>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set castShadow(value) {
    throw new Error_12("<PositionalAudio>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get receiveShadow() {
    throw new Error_12("<PositionalAudio>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set receiveShadow(value) {
    throw new Error_12("<PositionalAudio>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get frustumCulled() {
    throw new Error_12("<PositionalAudio>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set frustumCulled(value) {
    throw new Error_12("<PositionalAudio>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get renderOrder() {
    throw new Error_12("<PositionalAudio>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set renderOrder(value) {
    throw new Error_12("<PositionalAudio>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get visible() {
    throw new Error_12("<PositionalAudio>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set visible(value) {
    throw new Error_12("<PositionalAudio>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get autoplay() {
    throw new Error_12("<PositionalAudio>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set autoplay(value) {
    throw new Error_12("<PositionalAudio>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get detune() {
    throw new Error_12("<PositionalAudio>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set detune(value) {
    throw new Error_12("<PositionalAudio>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get source() {
    throw new Error_12("<PositionalAudio>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set source(value) {
    throw new Error_12("<PositionalAudio>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get volume() {
    throw new Error_12("<PositionalAudio>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set volume(value) {
    throw new Error_12("<PositionalAudio>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get loop() {
    throw new Error_12("<PositionalAudio>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set loop(value) {
    throw new Error_12("<PositionalAudio>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get filters() {
    throw new Error_12("<PositionalAudio>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set filters(value) {
    throw new Error_12("<PositionalAudio>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get playbackRate() {
    throw new Error_12("<PositionalAudio>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set playbackRate(value) {
    throw new Error_12("<PositionalAudio>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get play() {
    throw new Error_12("<PositionalAudio>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set play(value) {
    throw new Error_12("<PositionalAudio>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get pause() {
    throw new Error_12("<PositionalAudio>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set pause(value) {
    throw new Error_12("<PositionalAudio>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get stop() {
    throw new Error_12("<PositionalAudio>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set stop(value) {
    throw new Error_12("<PositionalAudio>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get id() {
    throw new Error_12("<PositionalAudio>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set id(value) {
    throw new Error_12("<PositionalAudio>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get directionalCone() {
    throw new Error_12("<PositionalAudio>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set directionalCone(value) {
    throw new Error_12("<PositionalAudio>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get refDistance() {
    throw new Error_12("<PositionalAudio>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set refDistance(value) {
    throw new Error_12("<PositionalAudio>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get rolloffFactor() {
    throw new Error_12("<PositionalAudio>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set rolloffFactor(value) {
    throw new Error_12("<PositionalAudio>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get distanceModel() {
    throw new Error_12("<PositionalAudio>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set distanceModel(value) {
    throw new Error_12("<PositionalAudio>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get maxDistance() {
    throw new Error_12("<PositionalAudio>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set maxDistance(value) {
    throw new Error_12("<PositionalAudio>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get audio() {
    return this.$$.ctx[21];
  }
  set audio(value) {
    throw new Error_12("<PositionalAudio>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var PositionalAudio_default = PositionalAudio2;

// node_modules/three/examples/jsm/helpers/PositionalAudioHelper.js
var PositionalAudioHelper = class extends Line {
  constructor(audio, range = 1, divisionsInnerAngle = 16, divisionsOuterAngle = 2) {
    const geometry = new BufferGeometry();
    const divisions = divisionsInnerAngle + divisionsOuterAngle * 2;
    const positions = new Float32Array((divisions * 3 + 3) * 3);
    geometry.setAttribute("position", new BufferAttribute(positions, 3));
    const materialInnerAngle = new LineBasicMaterial({ color: 65280 });
    const materialOuterAngle = new LineBasicMaterial({ color: 16776960 });
    super(geometry, [materialOuterAngle, materialInnerAngle]);
    this.audio = audio;
    this.range = range;
    this.divisionsInnerAngle = divisionsInnerAngle;
    this.divisionsOuterAngle = divisionsOuterAngle;
    this.type = "PositionalAudioHelper";
    this.update();
  }
  update() {
    const audio = this.audio;
    const range = this.range;
    const divisionsInnerAngle = this.divisionsInnerAngle;
    const divisionsOuterAngle = this.divisionsOuterAngle;
    const coneInnerAngle = MathUtils.degToRad(audio.panner.coneInnerAngle);
    const coneOuterAngle = MathUtils.degToRad(audio.panner.coneOuterAngle);
    const halfConeInnerAngle = coneInnerAngle / 2;
    const halfConeOuterAngle = coneOuterAngle / 2;
    let start = 0;
    let count = 0;
    let i;
    let stride;
    const geometry = this.geometry;
    const positionAttribute = geometry.attributes.position;
    geometry.clearGroups();
    function generateSegment(from, to, divisions, materialIndex) {
      const step = (to - from) / divisions;
      positionAttribute.setXYZ(start, 0, 0, 0);
      count++;
      for (i = from; i < to; i += step) {
        stride = start + count;
        positionAttribute.setXYZ(stride, Math.sin(i) * range, 0, Math.cos(i) * range);
        positionAttribute.setXYZ(stride + 1, Math.sin(Math.min(i + step, to)) * range, 0, Math.cos(Math.min(i + step, to)) * range);
        positionAttribute.setXYZ(stride + 2, 0, 0, 0);
        count += 3;
      }
      geometry.addGroup(start, count, materialIndex);
      start += count;
      count = 0;
    }
    generateSegment(-halfConeOuterAngle, -halfConeInnerAngle, divisionsOuterAngle, 0);
    generateSegment(-halfConeInnerAngle, halfConeInnerAngle, divisionsInnerAngle, 1);
    generateSegment(halfConeInnerAngle, halfConeOuterAngle, divisionsOuterAngle, 0);
    positionAttribute.needsUpdate = true;
    if (coneInnerAngle === coneOuterAngle)
      this.material[0].visible = false;
  }
  dispose() {
    this.geometry.dispose();
    this.material[0].dispose();
    this.material[1].dispose();
  }
};

// node_modules/threlte/helpers/PositionalAudioHelper.svelte
var { console: console_12 } = globals;
function create_if_block2(ctx) {
  let object3dinstance;
  let current;
  object3dinstance = new Object3DInstance_default({
    props: { object: (
      /*helper*/
      ctx[0]
    ) },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(object3dinstance.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(object3dinstance.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(object3dinstance, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const object3dinstance_changes = {};
      if (dirty & /*helper*/
      1)
        object3dinstance_changes.object = /*helper*/
        ctx2[0];
      object3dinstance.$set(object3dinstance_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(object3dinstance.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(object3dinstance.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(object3dinstance, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block2.name,
    type: "if",
    source: "(15:0) {#if helper}",
    ctx
  });
  return block;
}
function create_fragment14(ctx) {
  let if_block_anchor;
  let current;
  let if_block = (
    /*helper*/
    ctx[0] && create_if_block2(ctx)
  );
  const block = {
    c: function create() {
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
    },
    l: function claim(nodes) {
      if (if_block)
        if_block.l(nodes);
      if_block_anchor = empty();
    },
    m: function mount(target, anchor) {
      if (if_block)
        if_block.m(target, anchor);
      insert_hydration_dev(target, if_block_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      if (
        /*helper*/
        ctx2[0]
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & /*helper*/
          1) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block2(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if (if_block)
        if_block.d(detaching);
      if (detaching)
        detach_dev(if_block_anchor);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment14.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance14($$self, $$props, $$invalidate) {
  let $parent;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("PositionalAudioHelper", slots, []);
  const parent = getParent();
  validate_store(parent, "parent");
  component_subscribe($$self, parent, (value) => $$invalidate(2, $parent = value));
  let helper;
  if (!($parent instanceof PositionalAudio)) {
    console.warn("<PositionalAudioHelper> can only be used as a direct child of <PositionalAudio>");
  } else {
    helper = new PositionalAudioHelper($parent);
  }
  const writable_props = [];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console_12.warn(`<PositionalAudioHelper> was created with unknown prop '${key}'`);
  });
  $$self.$capture_state = () => ({
    PositionalAudio,
    ThreePositionalAudioHelper: PositionalAudioHelper,
    Object3DInstance: Object3DInstance_default,
    getParent,
    parent,
    helper,
    $parent
  });
  $$self.$inject_state = ($$props2) => {
    if ("helper" in $$props2)
      $$invalidate(0, helper = $$props2.helper);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [helper, parent];
}
var PositionalAudioHelper2 = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance14, create_fragment14, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "PositionalAudioHelper",
      options,
      id: create_fragment14.name
    });
  }
};
var PositionalAudioHelper_default = PositionalAudioHelper2;

// node_modules/three/examples/jsm/controls/OrbitControls.js
var _changeEvent = { type: "change" };
var _startEvent = { type: "start" };
var _endEvent = { type: "end" };
var OrbitControls = class extends EventDispatcher {
  constructor(object, domElement) {
    super();
    this.object = object;
    this.domElement = domElement;
    this.domElement.style.touchAction = "none";
    this.enabled = true;
    this.target = new Vector3();
    this.minDistance = 0;
    this.maxDistance = Infinity;
    this.minZoom = 0;
    this.maxZoom = Infinity;
    this.minPolarAngle = 0;
    this.maxPolarAngle = Math.PI;
    this.minAzimuthAngle = -Infinity;
    this.maxAzimuthAngle = Infinity;
    this.enableDamping = false;
    this.dampingFactor = 0.05;
    this.enableZoom = true;
    this.zoomSpeed = 1;
    this.enableRotate = true;
    this.rotateSpeed = 1;
    this.enablePan = true;
    this.panSpeed = 1;
    this.screenSpacePanning = true;
    this.keyPanSpeed = 7;
    this.autoRotate = false;
    this.autoRotateSpeed = 2;
    this.keys = { LEFT: "ArrowLeft", UP: "ArrowUp", RIGHT: "ArrowRight", BOTTOM: "ArrowDown" };
    this.mouseButtons = { LEFT: MOUSE.ROTATE, MIDDLE: MOUSE.DOLLY, RIGHT: MOUSE.PAN };
    this.touches = { ONE: TOUCH.ROTATE, TWO: TOUCH.DOLLY_PAN };
    this.target0 = this.target.clone();
    this.position0 = this.object.position.clone();
    this.zoom0 = this.object.zoom;
    this._domElementKeyEvents = null;
    this.getPolarAngle = function() {
      return spherical.phi;
    };
    this.getAzimuthalAngle = function() {
      return spherical.theta;
    };
    this.getDistance = function() {
      return this.object.position.distanceTo(this.target);
    };
    this.listenToKeyEvents = function(domElement2) {
      domElement2.addEventListener("keydown", onKeyDown);
      this._domElementKeyEvents = domElement2;
    };
    this.stopListenToKeyEvents = function() {
      this._domElementKeyEvents.removeEventListener("keydown", onKeyDown);
      this._domElementKeyEvents = null;
    };
    this.saveState = function() {
      scope.target0.copy(scope.target);
      scope.position0.copy(scope.object.position);
      scope.zoom0 = scope.object.zoom;
    };
    this.reset = function() {
      scope.target.copy(scope.target0);
      scope.object.position.copy(scope.position0);
      scope.object.zoom = scope.zoom0;
      scope.object.updateProjectionMatrix();
      scope.dispatchEvent(_changeEvent);
      scope.update();
      state = STATE.NONE;
    };
    this.update = function() {
      const offset = new Vector3();
      const quat = new Quaternion().setFromUnitVectors(object.up, new Vector3(0, 1, 0));
      const quatInverse = quat.clone().invert();
      const lastPosition = new Vector3();
      const lastQuaternion = new Quaternion();
      const lastTargetPosition = new Vector3();
      const twoPI = 2 * Math.PI;
      return function update() {
        const position = scope.object.position;
        offset.copy(position).sub(scope.target);
        offset.applyQuaternion(quat);
        spherical.setFromVector3(offset);
        if (scope.autoRotate && state === STATE.NONE) {
          rotateLeft(getAutoRotationAngle());
        }
        if (scope.enableDamping) {
          spherical.theta += sphericalDelta.theta * scope.dampingFactor;
          spherical.phi += sphericalDelta.phi * scope.dampingFactor;
        } else {
          spherical.theta += sphericalDelta.theta;
          spherical.phi += sphericalDelta.phi;
        }
        let min = scope.minAzimuthAngle;
        let max = scope.maxAzimuthAngle;
        if (isFinite(min) && isFinite(max)) {
          if (min < -Math.PI)
            min += twoPI;
          else if (min > Math.PI)
            min -= twoPI;
          if (max < -Math.PI)
            max += twoPI;
          else if (max > Math.PI)
            max -= twoPI;
          if (min <= max) {
            spherical.theta = Math.max(min, Math.min(max, spherical.theta));
          } else {
            spherical.theta = spherical.theta > (min + max) / 2 ? Math.max(min, spherical.theta) : Math.min(max, spherical.theta);
          }
        }
        spherical.phi = Math.max(scope.minPolarAngle, Math.min(scope.maxPolarAngle, spherical.phi));
        spherical.makeSafe();
        spherical.radius *= scale;
        spherical.radius = Math.max(scope.minDistance, Math.min(scope.maxDistance, spherical.radius));
        if (scope.enableDamping === true) {
          scope.target.addScaledVector(panOffset, scope.dampingFactor);
        } else {
          scope.target.add(panOffset);
        }
        offset.setFromSpherical(spherical);
        offset.applyQuaternion(quatInverse);
        position.copy(scope.target).add(offset);
        scope.object.lookAt(scope.target);
        if (scope.enableDamping === true) {
          sphericalDelta.theta *= 1 - scope.dampingFactor;
          sphericalDelta.phi *= 1 - scope.dampingFactor;
          panOffset.multiplyScalar(1 - scope.dampingFactor);
        } else {
          sphericalDelta.set(0, 0, 0);
          panOffset.set(0, 0, 0);
        }
        scale = 1;
        if (zoomChanged || lastPosition.distanceToSquared(scope.object.position) > EPS || 8 * (1 - lastQuaternion.dot(scope.object.quaternion)) > EPS || lastTargetPosition.distanceToSquared(scope.target) > 0) {
          scope.dispatchEvent(_changeEvent);
          lastPosition.copy(scope.object.position);
          lastQuaternion.copy(scope.object.quaternion);
          lastTargetPosition.copy(scope.target);
          zoomChanged = false;
          return true;
        }
        return false;
      };
    }();
    this.dispose = function() {
      scope.domElement.removeEventListener("contextmenu", onContextMenu);
      scope.domElement.removeEventListener("pointerdown", onPointerDown2);
      scope.domElement.removeEventListener("pointercancel", onPointerUp2);
      scope.domElement.removeEventListener("wheel", onMouseWheel);
      scope.domElement.removeEventListener("pointermove", onPointerMove2);
      scope.domElement.removeEventListener("pointerup", onPointerUp2);
      if (scope._domElementKeyEvents !== null) {
        scope._domElementKeyEvents.removeEventListener("keydown", onKeyDown);
        scope._domElementKeyEvents = null;
      }
    };
    const scope = this;
    const STATE = {
      NONE: -1,
      ROTATE: 0,
      DOLLY: 1,
      PAN: 2,
      TOUCH_ROTATE: 3,
      TOUCH_PAN: 4,
      TOUCH_DOLLY_PAN: 5,
      TOUCH_DOLLY_ROTATE: 6
    };
    let state = STATE.NONE;
    const EPS = 1e-6;
    const spherical = new Spherical();
    const sphericalDelta = new Spherical();
    let scale = 1;
    const panOffset = new Vector3();
    let zoomChanged = false;
    const rotateStart = new Vector2();
    const rotateEnd = new Vector2();
    const rotateDelta = new Vector2();
    const panStart = new Vector2();
    const panEnd = new Vector2();
    const panDelta = new Vector2();
    const dollyStart = new Vector2();
    const dollyEnd = new Vector2();
    const dollyDelta = new Vector2();
    const pointers = [];
    const pointerPositions = {};
    function getAutoRotationAngle() {
      return 2 * Math.PI / 60 / 60 * scope.autoRotateSpeed;
    }
    function getZoomScale() {
      return Math.pow(0.95, scope.zoomSpeed);
    }
    function rotateLeft(angle) {
      sphericalDelta.theta -= angle;
    }
    function rotateUp(angle) {
      sphericalDelta.phi -= angle;
    }
    const panLeft = function() {
      const v = new Vector3();
      return function panLeft2(distance, objectMatrix) {
        v.setFromMatrixColumn(objectMatrix, 0);
        v.multiplyScalar(-distance);
        panOffset.add(v);
      };
    }();
    const panUp = function() {
      const v = new Vector3();
      return function panUp2(distance, objectMatrix) {
        if (scope.screenSpacePanning === true) {
          v.setFromMatrixColumn(objectMatrix, 1);
        } else {
          v.setFromMatrixColumn(objectMatrix, 0);
          v.crossVectors(scope.object.up, v);
        }
        v.multiplyScalar(distance);
        panOffset.add(v);
      };
    }();
    const pan = function() {
      const offset = new Vector3();
      return function pan2(deltaX, deltaY) {
        const element2 = scope.domElement;
        if (scope.object.isPerspectiveCamera) {
          const position = scope.object.position;
          offset.copy(position).sub(scope.target);
          let targetDistance = offset.length();
          targetDistance *= Math.tan(scope.object.fov / 2 * Math.PI / 180);
          panLeft(2 * deltaX * targetDistance / element2.clientHeight, scope.object.matrix);
          panUp(2 * deltaY * targetDistance / element2.clientHeight, scope.object.matrix);
        } else if (scope.object.isOrthographicCamera) {
          panLeft(deltaX * (scope.object.right - scope.object.left) / scope.object.zoom / element2.clientWidth, scope.object.matrix);
          panUp(deltaY * (scope.object.top - scope.object.bottom) / scope.object.zoom / element2.clientHeight, scope.object.matrix);
        } else {
          console.warn("WARNING: OrbitControls.js encountered an unknown camera type - pan disabled.");
          scope.enablePan = false;
        }
      };
    }();
    function dollyOut(dollyScale) {
      if (scope.object.isPerspectiveCamera) {
        scale /= dollyScale;
      } else if (scope.object.isOrthographicCamera) {
        scope.object.zoom = Math.max(scope.minZoom, Math.min(scope.maxZoom, scope.object.zoom * dollyScale));
        scope.object.updateProjectionMatrix();
        zoomChanged = true;
      } else {
        console.warn("WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled.");
        scope.enableZoom = false;
      }
    }
    function dollyIn(dollyScale) {
      if (scope.object.isPerspectiveCamera) {
        scale *= dollyScale;
      } else if (scope.object.isOrthographicCamera) {
        scope.object.zoom = Math.max(scope.minZoom, Math.min(scope.maxZoom, scope.object.zoom / dollyScale));
        scope.object.updateProjectionMatrix();
        zoomChanged = true;
      } else {
        console.warn("WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled.");
        scope.enableZoom = false;
      }
    }
    function handleMouseDownRotate(event) {
      rotateStart.set(event.clientX, event.clientY);
    }
    function handleMouseDownDolly(event) {
      dollyStart.set(event.clientX, event.clientY);
    }
    function handleMouseDownPan(event) {
      panStart.set(event.clientX, event.clientY);
    }
    function handleMouseMoveRotate(event) {
      rotateEnd.set(event.clientX, event.clientY);
      rotateDelta.subVectors(rotateEnd, rotateStart).multiplyScalar(scope.rotateSpeed);
      const element2 = scope.domElement;
      rotateLeft(2 * Math.PI * rotateDelta.x / element2.clientHeight);
      rotateUp(2 * Math.PI * rotateDelta.y / element2.clientHeight);
      rotateStart.copy(rotateEnd);
      scope.update();
    }
    function handleMouseMoveDolly(event) {
      dollyEnd.set(event.clientX, event.clientY);
      dollyDelta.subVectors(dollyEnd, dollyStart);
      if (dollyDelta.y > 0) {
        dollyOut(getZoomScale());
      } else if (dollyDelta.y < 0) {
        dollyIn(getZoomScale());
      }
      dollyStart.copy(dollyEnd);
      scope.update();
    }
    function handleMouseMovePan(event) {
      panEnd.set(event.clientX, event.clientY);
      panDelta.subVectors(panEnd, panStart).multiplyScalar(scope.panSpeed);
      pan(panDelta.x, panDelta.y);
      panStart.copy(panEnd);
      scope.update();
    }
    function handleMouseWheel(event) {
      if (event.deltaY < 0) {
        dollyIn(getZoomScale());
      } else if (event.deltaY > 0) {
        dollyOut(getZoomScale());
      }
      scope.update();
    }
    function handleKeyDown(event) {
      let needsUpdate = false;
      switch (event.code) {
        case scope.keys.UP:
          if (event.ctrlKey || event.metaKey || event.shiftKey) {
            rotateUp(2 * Math.PI * scope.rotateSpeed / scope.domElement.clientHeight);
          } else {
            pan(0, scope.keyPanSpeed);
          }
          needsUpdate = true;
          break;
        case scope.keys.BOTTOM:
          if (event.ctrlKey || event.metaKey || event.shiftKey) {
            rotateUp(-2 * Math.PI * scope.rotateSpeed / scope.domElement.clientHeight);
          } else {
            pan(0, -scope.keyPanSpeed);
          }
          needsUpdate = true;
          break;
        case scope.keys.LEFT:
          if (event.ctrlKey || event.metaKey || event.shiftKey) {
            rotateLeft(2 * Math.PI * scope.rotateSpeed / scope.domElement.clientHeight);
          } else {
            pan(scope.keyPanSpeed, 0);
          }
          needsUpdate = true;
          break;
        case scope.keys.RIGHT:
          if (event.ctrlKey || event.metaKey || event.shiftKey) {
            rotateLeft(-2 * Math.PI * scope.rotateSpeed / scope.domElement.clientHeight);
          } else {
            pan(-scope.keyPanSpeed, 0);
          }
          needsUpdate = true;
          break;
      }
      if (needsUpdate) {
        event.preventDefault();
        scope.update();
      }
    }
    function handleTouchStartRotate() {
      if (pointers.length === 1) {
        rotateStart.set(pointers[0].pageX, pointers[0].pageY);
      } else {
        const x2 = 0.5 * (pointers[0].pageX + pointers[1].pageX);
        const y = 0.5 * (pointers[0].pageY + pointers[1].pageY);
        rotateStart.set(x2, y);
      }
    }
    function handleTouchStartPan() {
      if (pointers.length === 1) {
        panStart.set(pointers[0].pageX, pointers[0].pageY);
      } else {
        const x2 = 0.5 * (pointers[0].pageX + pointers[1].pageX);
        const y = 0.5 * (pointers[0].pageY + pointers[1].pageY);
        panStart.set(x2, y);
      }
    }
    function handleTouchStartDolly() {
      const dx = pointers[0].pageX - pointers[1].pageX;
      const dy = pointers[0].pageY - pointers[1].pageY;
      const distance = Math.sqrt(dx * dx + dy * dy);
      dollyStart.set(0, distance);
    }
    function handleTouchStartDollyPan() {
      if (scope.enableZoom)
        handleTouchStartDolly();
      if (scope.enablePan)
        handleTouchStartPan();
    }
    function handleTouchStartDollyRotate() {
      if (scope.enableZoom)
        handleTouchStartDolly();
      if (scope.enableRotate)
        handleTouchStartRotate();
    }
    function handleTouchMoveRotate(event) {
      if (pointers.length == 1) {
        rotateEnd.set(event.pageX, event.pageY);
      } else {
        const position = getSecondPointerPosition(event);
        const x2 = 0.5 * (event.pageX + position.x);
        const y = 0.5 * (event.pageY + position.y);
        rotateEnd.set(x2, y);
      }
      rotateDelta.subVectors(rotateEnd, rotateStart).multiplyScalar(scope.rotateSpeed);
      const element2 = scope.domElement;
      rotateLeft(2 * Math.PI * rotateDelta.x / element2.clientHeight);
      rotateUp(2 * Math.PI * rotateDelta.y / element2.clientHeight);
      rotateStart.copy(rotateEnd);
    }
    function handleTouchMovePan(event) {
      if (pointers.length === 1) {
        panEnd.set(event.pageX, event.pageY);
      } else {
        const position = getSecondPointerPosition(event);
        const x2 = 0.5 * (event.pageX + position.x);
        const y = 0.5 * (event.pageY + position.y);
        panEnd.set(x2, y);
      }
      panDelta.subVectors(panEnd, panStart).multiplyScalar(scope.panSpeed);
      pan(panDelta.x, panDelta.y);
      panStart.copy(panEnd);
    }
    function handleTouchMoveDolly(event) {
      const position = getSecondPointerPosition(event);
      const dx = event.pageX - position.x;
      const dy = event.pageY - position.y;
      const distance = Math.sqrt(dx * dx + dy * dy);
      dollyEnd.set(0, distance);
      dollyDelta.set(0, Math.pow(dollyEnd.y / dollyStart.y, scope.zoomSpeed));
      dollyOut(dollyDelta.y);
      dollyStart.copy(dollyEnd);
    }
    function handleTouchMoveDollyPan(event) {
      if (scope.enableZoom)
        handleTouchMoveDolly(event);
      if (scope.enablePan)
        handleTouchMovePan(event);
    }
    function handleTouchMoveDollyRotate(event) {
      if (scope.enableZoom)
        handleTouchMoveDolly(event);
      if (scope.enableRotate)
        handleTouchMoveRotate(event);
    }
    function onPointerDown2(event) {
      if (scope.enabled === false)
        return;
      if (pointers.length === 0) {
        scope.domElement.setPointerCapture(event.pointerId);
        scope.domElement.addEventListener("pointermove", onPointerMove2);
        scope.domElement.addEventListener("pointerup", onPointerUp2);
      }
      addPointer(event);
      if (event.pointerType === "touch") {
        onTouchStart(event);
      } else {
        onMouseDown(event);
      }
    }
    function onPointerMove2(event) {
      if (scope.enabled === false)
        return;
      if (event.pointerType === "touch") {
        onTouchMove(event);
      } else {
        onMouseMove(event);
      }
    }
    function onPointerUp2(event) {
      removePointer(event);
      if (pointers.length === 0) {
        scope.domElement.releasePointerCapture(event.pointerId);
        scope.domElement.removeEventListener("pointermove", onPointerMove2);
        scope.domElement.removeEventListener("pointerup", onPointerUp2);
      }
      scope.dispatchEvent(_endEvent);
      state = STATE.NONE;
    }
    function onMouseDown(event) {
      let mouseAction;
      switch (event.button) {
        case 0:
          mouseAction = scope.mouseButtons.LEFT;
          break;
        case 1:
          mouseAction = scope.mouseButtons.MIDDLE;
          break;
        case 2:
          mouseAction = scope.mouseButtons.RIGHT;
          break;
        default:
          mouseAction = -1;
      }
      switch (mouseAction) {
        case MOUSE.DOLLY:
          if (scope.enableZoom === false)
            return;
          handleMouseDownDolly(event);
          state = STATE.DOLLY;
          break;
        case MOUSE.ROTATE:
          if (event.ctrlKey || event.metaKey || event.shiftKey) {
            if (scope.enablePan === false)
              return;
            handleMouseDownPan(event);
            state = STATE.PAN;
          } else {
            if (scope.enableRotate === false)
              return;
            handleMouseDownRotate(event);
            state = STATE.ROTATE;
          }
          break;
        case MOUSE.PAN:
          if (event.ctrlKey || event.metaKey || event.shiftKey) {
            if (scope.enableRotate === false)
              return;
            handleMouseDownRotate(event);
            state = STATE.ROTATE;
          } else {
            if (scope.enablePan === false)
              return;
            handleMouseDownPan(event);
            state = STATE.PAN;
          }
          break;
        default:
          state = STATE.NONE;
      }
      if (state !== STATE.NONE) {
        scope.dispatchEvent(_startEvent);
      }
    }
    function onMouseMove(event) {
      switch (state) {
        case STATE.ROTATE:
          if (scope.enableRotate === false)
            return;
          handleMouseMoveRotate(event);
          break;
        case STATE.DOLLY:
          if (scope.enableZoom === false)
            return;
          handleMouseMoveDolly(event);
          break;
        case STATE.PAN:
          if (scope.enablePan === false)
            return;
          handleMouseMovePan(event);
          break;
      }
    }
    function onMouseWheel(event) {
      if (scope.enabled === false || scope.enableZoom === false || state !== STATE.NONE)
        return;
      event.preventDefault();
      scope.dispatchEvent(_startEvent);
      handleMouseWheel(event);
      scope.dispatchEvent(_endEvent);
    }
    function onKeyDown(event) {
      if (scope.enabled === false || scope.enablePan === false)
        return;
      handleKeyDown(event);
    }
    function onTouchStart(event) {
      trackPointer(event);
      switch (pointers.length) {
        case 1:
          switch (scope.touches.ONE) {
            case TOUCH.ROTATE:
              if (scope.enableRotate === false)
                return;
              handleTouchStartRotate();
              state = STATE.TOUCH_ROTATE;
              break;
            case TOUCH.PAN:
              if (scope.enablePan === false)
                return;
              handleTouchStartPan();
              state = STATE.TOUCH_PAN;
              break;
            default:
              state = STATE.NONE;
          }
          break;
        case 2:
          switch (scope.touches.TWO) {
            case TOUCH.DOLLY_PAN:
              if (scope.enableZoom === false && scope.enablePan === false)
                return;
              handleTouchStartDollyPan();
              state = STATE.TOUCH_DOLLY_PAN;
              break;
            case TOUCH.DOLLY_ROTATE:
              if (scope.enableZoom === false && scope.enableRotate === false)
                return;
              handleTouchStartDollyRotate();
              state = STATE.TOUCH_DOLLY_ROTATE;
              break;
            default:
              state = STATE.NONE;
          }
          break;
        default:
          state = STATE.NONE;
      }
      if (state !== STATE.NONE) {
        scope.dispatchEvent(_startEvent);
      }
    }
    function onTouchMove(event) {
      trackPointer(event);
      switch (state) {
        case STATE.TOUCH_ROTATE:
          if (scope.enableRotate === false)
            return;
          handleTouchMoveRotate(event);
          scope.update();
          break;
        case STATE.TOUCH_PAN:
          if (scope.enablePan === false)
            return;
          handleTouchMovePan(event);
          scope.update();
          break;
        case STATE.TOUCH_DOLLY_PAN:
          if (scope.enableZoom === false && scope.enablePan === false)
            return;
          handleTouchMoveDollyPan(event);
          scope.update();
          break;
        case STATE.TOUCH_DOLLY_ROTATE:
          if (scope.enableZoom === false && scope.enableRotate === false)
            return;
          handleTouchMoveDollyRotate(event);
          scope.update();
          break;
        default:
          state = STATE.NONE;
      }
    }
    function onContextMenu(event) {
      if (scope.enabled === false)
        return;
      event.preventDefault();
    }
    function addPointer(event) {
      pointers.push(event);
    }
    function removePointer(event) {
      delete pointerPositions[event.pointerId];
      for (let i = 0; i < pointers.length; i++) {
        if (pointers[i].pointerId == event.pointerId) {
          pointers.splice(i, 1);
          return;
        }
      }
    }
    function trackPointer(event) {
      let position = pointerPositions[event.pointerId];
      if (position === void 0) {
        position = new Vector2();
        pointerPositions[event.pointerId] = position;
      }
      position.set(event.pageX, event.pageY);
    }
    function getSecondPointerPosition(event) {
      const pointer = event.pointerId === pointers[0].pointerId ? pointers[1] : pointers[0];
      return pointerPositions[pointer.pointerId];
    }
    scope.domElement.addEventListener("contextmenu", onContextMenu);
    scope.domElement.addEventListener("pointerdown", onPointerDown2);
    scope.domElement.addEventListener("pointercancel", onPointerUp2);
    scope.domElement.addEventListener("wheel", onMouseWheel, { passive: false });
    this.update();
  }
};

// node_modules/threlte/controls/OrbitControls.svelte
var { Error: Error_13 } = globals;
function create_fragment15(ctx) {
  let transformableobject;
  let current;
  transformableobject = new TransformableObject_default({
    props: {
      object: (
        /*targetObject*/
        ctx[2]
      ),
      position: (
        /*target*/
        ctx[0]
      )
    },
    $$inline: true
  });
  transformableobject.$on(
    "transform",
    /*updateControls*/
    ctx[3]
  );
  const block = {
    c: function create() {
      create_component(transformableobject.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(transformableobject.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(transformableobject, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const transformableobject_changes = {};
      if (dirty[0] & /*target*/
      1)
        transformableobject_changes.position = /*target*/
        ctx2[0];
      transformableobject.$set(transformableobject_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(transformableobject.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(transformableobject.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(transformableobject, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment15.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance15($$self, $$props, $$invalidate) {
  let $parent;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("OrbitControls", slots, []);
  let { autoRotate = void 0 } = $$props;
  let { autoRotateSpeed = void 0 } = $$props;
  let { dampingFactor = void 0 } = $$props;
  let { enableDamping = void 0 } = $$props;
  let { enabled = void 0 } = $$props;
  let { enablePan = void 0 } = $$props;
  let { enableRotate = void 0 } = $$props;
  let { enableZoom = void 0 } = $$props;
  let { keyPanSpeed = void 0 } = $$props;
  let { keys = void 0 } = $$props;
  let { maxAzimuthAngle = void 0 } = $$props;
  let { maxDistance = void 0 } = $$props;
  let { maxPolarAngle = void 0 } = $$props;
  let { maxZoom = void 0 } = $$props;
  let { minAzimuthAngle = void 0 } = $$props;
  let { minDistance = void 0 } = $$props;
  let { minPolarAngle = void 0 } = $$props;
  let { minZoom = void 0 } = $$props;
  let { mouseButtons = void 0 } = $$props;
  let { panSpeed = void 0 } = $$props;
  let { rotateSpeed = void 0 } = $$props;
  let { screenSpacePanning = void 0 } = $$props;
  let { touches = void 0 } = $$props;
  let { zoomSpeed = void 0 } = $$props;
  let { target = void 0 } = $$props;
  const parent = getParent();
  validate_store(parent, "parent");
  component_subscribe($$self, parent, (value) => $$invalidate(29, $parent = value));
  const { renderer, invalidate } = useThrelte();
  if (!renderer)
    throw new Error("Threlte Context missing: Is <OrbitControls> a child of <Canvas>?");
  if (!($parent instanceof Camera)) {
    throw new Error("Parent missing: <OrbitControls> need to be a child of a <Camera>");
  }
  const dispatch = createEventDispatcher();
  const onChange = () => {
    invalidate("Orbitcontrols: change event");
    dispatch("change");
  };
  const onStart = () => dispatch("start");
  const onEnd = () => dispatch("end");
  const controls = new OrbitControls($parent, renderer.domElement);
  getThrelteUserData($parent).orbitControls = controls;
  controls.addEventListener("change", onChange);
  controls.addEventListener("start", onStart);
  controls.addEventListener("end", onEnd);
  onDestroy(() => {
    delete getThrelteUserData($parent).orbitControls;
    controls.removeEventListener("change", onChange);
    controls.removeEventListener("start", onStart);
    controls.removeEventListener("end", onEnd);
  });
  const { start, stop } = useFrame(() => controls.update(), {
    autostart: false,
    debugFrameloopMessage: "OrbitControlts: updating controls"
  });
  const targetObject = new Object3D();
  const updateControls = () => {
    $$invalidate(4, controls.target = targetObject.position, controls);
    controls.update();
    invalidate("OrbitControls: target changed");
  };
  onDestroy(() => {
    controls.dispose();
    invalidate("OrbitControls: onDestroy");
  });
  const writable_props = [
    "autoRotate",
    "autoRotateSpeed",
    "dampingFactor",
    "enableDamping",
    "enabled",
    "enablePan",
    "enableRotate",
    "enableZoom",
    "keyPanSpeed",
    "keys",
    "maxAzimuthAngle",
    "maxDistance",
    "maxPolarAngle",
    "maxZoom",
    "minAzimuthAngle",
    "minDistance",
    "minPolarAngle",
    "minZoom",
    "mouseButtons",
    "panSpeed",
    "rotateSpeed",
    "screenSpacePanning",
    "touches",
    "zoomSpeed",
    "target"
  ];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<OrbitControls> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("autoRotate" in $$props2)
      $$invalidate(5, autoRotate = $$props2.autoRotate);
    if ("autoRotateSpeed" in $$props2)
      $$invalidate(6, autoRotateSpeed = $$props2.autoRotateSpeed);
    if ("dampingFactor" in $$props2)
      $$invalidate(7, dampingFactor = $$props2.dampingFactor);
    if ("enableDamping" in $$props2)
      $$invalidate(8, enableDamping = $$props2.enableDamping);
    if ("enabled" in $$props2)
      $$invalidate(9, enabled = $$props2.enabled);
    if ("enablePan" in $$props2)
      $$invalidate(10, enablePan = $$props2.enablePan);
    if ("enableRotate" in $$props2)
      $$invalidate(11, enableRotate = $$props2.enableRotate);
    if ("enableZoom" in $$props2)
      $$invalidate(12, enableZoom = $$props2.enableZoom);
    if ("keyPanSpeed" in $$props2)
      $$invalidate(13, keyPanSpeed = $$props2.keyPanSpeed);
    if ("keys" in $$props2)
      $$invalidate(14, keys = $$props2.keys);
    if ("maxAzimuthAngle" in $$props2)
      $$invalidate(15, maxAzimuthAngle = $$props2.maxAzimuthAngle);
    if ("maxDistance" in $$props2)
      $$invalidate(16, maxDistance = $$props2.maxDistance);
    if ("maxPolarAngle" in $$props2)
      $$invalidate(17, maxPolarAngle = $$props2.maxPolarAngle);
    if ("maxZoom" in $$props2)
      $$invalidate(18, maxZoom = $$props2.maxZoom);
    if ("minAzimuthAngle" in $$props2)
      $$invalidate(19, minAzimuthAngle = $$props2.minAzimuthAngle);
    if ("minDistance" in $$props2)
      $$invalidate(20, minDistance = $$props2.minDistance);
    if ("minPolarAngle" in $$props2)
      $$invalidate(21, minPolarAngle = $$props2.minPolarAngle);
    if ("minZoom" in $$props2)
      $$invalidate(22, minZoom = $$props2.minZoom);
    if ("mouseButtons" in $$props2)
      $$invalidate(23, mouseButtons = $$props2.mouseButtons);
    if ("panSpeed" in $$props2)
      $$invalidate(24, panSpeed = $$props2.panSpeed);
    if ("rotateSpeed" in $$props2)
      $$invalidate(25, rotateSpeed = $$props2.rotateSpeed);
    if ("screenSpacePanning" in $$props2)
      $$invalidate(26, screenSpacePanning = $$props2.screenSpacePanning);
    if ("touches" in $$props2)
      $$invalidate(27, touches = $$props2.touches);
    if ("zoomSpeed" in $$props2)
      $$invalidate(28, zoomSpeed = $$props2.zoomSpeed);
    if ("target" in $$props2)
      $$invalidate(0, target = $$props2.target);
  };
  $$self.$capture_state = () => ({
    createEventDispatcher,
    onDestroy,
    Camera,
    Object3D,
    ThreeOrbitControls: OrbitControls,
    useFrame,
    useThrelte,
    getParent,
    TransformableObject: TransformableObject_default,
    getThrelteUserData,
    autoRotate,
    autoRotateSpeed,
    dampingFactor,
    enableDamping,
    enabled,
    enablePan,
    enableRotate,
    enableZoom,
    keyPanSpeed,
    keys,
    maxAzimuthAngle,
    maxDistance,
    maxPolarAngle,
    maxZoom,
    minAzimuthAngle,
    minDistance,
    minPolarAngle,
    minZoom,
    mouseButtons,
    panSpeed,
    rotateSpeed,
    screenSpacePanning,
    touches,
    zoomSpeed,
    target,
    parent,
    renderer,
    invalidate,
    dispatch,
    onChange,
    onStart,
    onEnd,
    controls,
    start,
    stop,
    targetObject,
    updateControls,
    $parent
  });
  $$self.$inject_state = ($$props2) => {
    if ("autoRotate" in $$props2)
      $$invalidate(5, autoRotate = $$props2.autoRotate);
    if ("autoRotateSpeed" in $$props2)
      $$invalidate(6, autoRotateSpeed = $$props2.autoRotateSpeed);
    if ("dampingFactor" in $$props2)
      $$invalidate(7, dampingFactor = $$props2.dampingFactor);
    if ("enableDamping" in $$props2)
      $$invalidate(8, enableDamping = $$props2.enableDamping);
    if ("enabled" in $$props2)
      $$invalidate(9, enabled = $$props2.enabled);
    if ("enablePan" in $$props2)
      $$invalidate(10, enablePan = $$props2.enablePan);
    if ("enableRotate" in $$props2)
      $$invalidate(11, enableRotate = $$props2.enableRotate);
    if ("enableZoom" in $$props2)
      $$invalidate(12, enableZoom = $$props2.enableZoom);
    if ("keyPanSpeed" in $$props2)
      $$invalidate(13, keyPanSpeed = $$props2.keyPanSpeed);
    if ("keys" in $$props2)
      $$invalidate(14, keys = $$props2.keys);
    if ("maxAzimuthAngle" in $$props2)
      $$invalidate(15, maxAzimuthAngle = $$props2.maxAzimuthAngle);
    if ("maxDistance" in $$props2)
      $$invalidate(16, maxDistance = $$props2.maxDistance);
    if ("maxPolarAngle" in $$props2)
      $$invalidate(17, maxPolarAngle = $$props2.maxPolarAngle);
    if ("maxZoom" in $$props2)
      $$invalidate(18, maxZoom = $$props2.maxZoom);
    if ("minAzimuthAngle" in $$props2)
      $$invalidate(19, minAzimuthAngle = $$props2.minAzimuthAngle);
    if ("minDistance" in $$props2)
      $$invalidate(20, minDistance = $$props2.minDistance);
    if ("minPolarAngle" in $$props2)
      $$invalidate(21, minPolarAngle = $$props2.minPolarAngle);
    if ("minZoom" in $$props2)
      $$invalidate(22, minZoom = $$props2.minZoom);
    if ("mouseButtons" in $$props2)
      $$invalidate(23, mouseButtons = $$props2.mouseButtons);
    if ("panSpeed" in $$props2)
      $$invalidate(24, panSpeed = $$props2.panSpeed);
    if ("rotateSpeed" in $$props2)
      $$invalidate(25, rotateSpeed = $$props2.rotateSpeed);
    if ("screenSpacePanning" in $$props2)
      $$invalidate(26, screenSpacePanning = $$props2.screenSpacePanning);
    if ("touches" in $$props2)
      $$invalidate(27, touches = $$props2.touches);
    if ("zoomSpeed" in $$props2)
      $$invalidate(28, zoomSpeed = $$props2.zoomSpeed);
    if ("target" in $$props2)
      $$invalidate(0, target = $$props2.target);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty[0] & /*autoRotate, autoRotateSpeed, dampingFactor, enableDamping, enabled, enablePan, enableRotate, enableZoom, keyPanSpeed, keys, maxAzimuthAngle, maxDistance, maxPolarAngle, maxZoom, minAzimuthAngle, minDistance, minPolarAngle, minZoom, mouseButtons, panSpeed, rotateSpeed, screenSpacePanning, touches, zoomSpeed, controls*/
    536870896) {
      $: {
        if (autoRotate !== void 0)
          $$invalidate(4, controls.autoRotate = autoRotate, controls);
        if (autoRotateSpeed !== void 0)
          $$invalidate(4, controls.autoRotateSpeed = autoRotateSpeed, controls);
        if (dampingFactor !== void 0)
          $$invalidate(4, controls.dampingFactor = dampingFactor, controls);
        if (enableDamping !== void 0)
          $$invalidate(4, controls.enableDamping = enableDamping, controls);
        if (enabled !== void 0)
          $$invalidate(4, controls.enabled = enabled, controls);
        if (enablePan !== void 0)
          $$invalidate(4, controls.enablePan = enablePan, controls);
        if (enableRotate !== void 0)
          $$invalidate(4, controls.enableRotate = enableRotate, controls);
        if (enableZoom !== void 0)
          $$invalidate(4, controls.enableZoom = enableZoom, controls);
        if (keyPanSpeed !== void 0)
          $$invalidate(4, controls.keyPanSpeed = keyPanSpeed, controls);
        if (keys !== void 0)
          $$invalidate(4, controls.keys = keys, controls);
        if (maxAzimuthAngle !== void 0)
          $$invalidate(4, controls.maxAzimuthAngle = maxAzimuthAngle, controls);
        if (maxDistance !== void 0)
          $$invalidate(4, controls.maxDistance = maxDistance, controls);
        if (maxPolarAngle !== void 0)
          $$invalidate(4, controls.maxPolarAngle = maxPolarAngle, controls);
        if (maxZoom !== void 0)
          $$invalidate(4, controls.maxZoom = maxZoom, controls);
        if (minAzimuthAngle !== void 0)
          $$invalidate(4, controls.minAzimuthAngle = minAzimuthAngle, controls);
        if (minDistance !== void 0)
          $$invalidate(4, controls.minDistance = minDistance, controls);
        if (minPolarAngle !== void 0)
          $$invalidate(4, controls.minPolarAngle = minPolarAngle, controls);
        if (minZoom !== void 0)
          $$invalidate(4, controls.minZoom = minZoom, controls);
        if (mouseButtons !== void 0)
          $$invalidate(4, controls.mouseButtons = mouseButtons, controls);
        if (panSpeed !== void 0)
          $$invalidate(4, controls.panSpeed = panSpeed, controls);
        if (rotateSpeed !== void 0)
          $$invalidate(4, controls.rotateSpeed = rotateSpeed, controls);
        if (screenSpacePanning !== void 0)
          $$invalidate(4, controls.screenSpacePanning = screenSpacePanning, controls);
        if (touches !== void 0)
          $$invalidate(4, controls.touches = touches, controls);
        if (zoomSpeed !== void 0)
          $$invalidate(4, controls.zoomSpeed = zoomSpeed, controls);
        controls.update();
        invalidate("OrbitControls: props changed");
      }
    }
    if ($$self.$$.dirty[0] & /*autoRotate, enableDamping*/
    288) {
      $: {
        if (autoRotate || enableDamping)
          start();
        else
          stop();
      }
    }
  };
  return [
    target,
    parent,
    targetObject,
    updateControls,
    controls,
    autoRotate,
    autoRotateSpeed,
    dampingFactor,
    enableDamping,
    enabled,
    enablePan,
    enableRotate,
    enableZoom,
    keyPanSpeed,
    keys,
    maxAzimuthAngle,
    maxDistance,
    maxPolarAngle,
    maxZoom,
    minAzimuthAngle,
    minDistance,
    minPolarAngle,
    minZoom,
    mouseButtons,
    panSpeed,
    rotateSpeed,
    screenSpacePanning,
    touches,
    zoomSpeed
  ];
}
var OrbitControls2 = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(
      this,
      options,
      instance15,
      create_fragment15,
      safe_not_equal,
      {
        autoRotate: 5,
        autoRotateSpeed: 6,
        dampingFactor: 7,
        enableDamping: 8,
        enabled: 9,
        enablePan: 10,
        enableRotate: 11,
        enableZoom: 12,
        keyPanSpeed: 13,
        keys: 14,
        maxAzimuthAngle: 15,
        maxDistance: 16,
        maxPolarAngle: 17,
        maxZoom: 18,
        minAzimuthAngle: 19,
        minDistance: 20,
        minPolarAngle: 21,
        minZoom: 22,
        mouseButtons: 23,
        panSpeed: 24,
        rotateSpeed: 25,
        screenSpacePanning: 26,
        touches: 27,
        zoomSpeed: 28,
        target: 0,
        controls: 4
      },
      null,
      [-1, -1]
    );
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "OrbitControls",
      options,
      id: create_fragment15.name
    });
  }
  get autoRotate() {
    throw new Error_13("<OrbitControls>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set autoRotate(value) {
    throw new Error_13("<OrbitControls>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get autoRotateSpeed() {
    throw new Error_13("<OrbitControls>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set autoRotateSpeed(value) {
    throw new Error_13("<OrbitControls>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get dampingFactor() {
    throw new Error_13("<OrbitControls>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set dampingFactor(value) {
    throw new Error_13("<OrbitControls>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get enableDamping() {
    throw new Error_13("<OrbitControls>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set enableDamping(value) {
    throw new Error_13("<OrbitControls>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get enabled() {
    throw new Error_13("<OrbitControls>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set enabled(value) {
    throw new Error_13("<OrbitControls>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get enablePan() {
    throw new Error_13("<OrbitControls>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set enablePan(value) {
    throw new Error_13("<OrbitControls>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get enableRotate() {
    throw new Error_13("<OrbitControls>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set enableRotate(value) {
    throw new Error_13("<OrbitControls>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get enableZoom() {
    throw new Error_13("<OrbitControls>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set enableZoom(value) {
    throw new Error_13("<OrbitControls>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get keyPanSpeed() {
    throw new Error_13("<OrbitControls>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set keyPanSpeed(value) {
    throw new Error_13("<OrbitControls>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get keys() {
    throw new Error_13("<OrbitControls>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set keys(value) {
    throw new Error_13("<OrbitControls>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get maxAzimuthAngle() {
    throw new Error_13("<OrbitControls>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set maxAzimuthAngle(value) {
    throw new Error_13("<OrbitControls>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get maxDistance() {
    throw new Error_13("<OrbitControls>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set maxDistance(value) {
    throw new Error_13("<OrbitControls>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get maxPolarAngle() {
    throw new Error_13("<OrbitControls>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set maxPolarAngle(value) {
    throw new Error_13("<OrbitControls>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get maxZoom() {
    throw new Error_13("<OrbitControls>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set maxZoom(value) {
    throw new Error_13("<OrbitControls>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get minAzimuthAngle() {
    throw new Error_13("<OrbitControls>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set minAzimuthAngle(value) {
    throw new Error_13("<OrbitControls>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get minDistance() {
    throw new Error_13("<OrbitControls>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set minDistance(value) {
    throw new Error_13("<OrbitControls>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get minPolarAngle() {
    throw new Error_13("<OrbitControls>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set minPolarAngle(value) {
    throw new Error_13("<OrbitControls>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get minZoom() {
    throw new Error_13("<OrbitControls>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set minZoom(value) {
    throw new Error_13("<OrbitControls>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get mouseButtons() {
    throw new Error_13("<OrbitControls>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set mouseButtons(value) {
    throw new Error_13("<OrbitControls>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get panSpeed() {
    throw new Error_13("<OrbitControls>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set panSpeed(value) {
    throw new Error_13("<OrbitControls>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get rotateSpeed() {
    throw new Error_13("<OrbitControls>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set rotateSpeed(value) {
    throw new Error_13("<OrbitControls>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get screenSpacePanning() {
    throw new Error_13("<OrbitControls>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set screenSpacePanning(value) {
    throw new Error_13("<OrbitControls>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get touches() {
    throw new Error_13("<OrbitControls>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set touches(value) {
    throw new Error_13("<OrbitControls>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get zoomSpeed() {
    throw new Error_13("<OrbitControls>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set zoomSpeed(value) {
    throw new Error_13("<OrbitControls>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get target() {
    throw new Error_13("<OrbitControls>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set target(value) {
    throw new Error_13("<OrbitControls>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get controls() {
    return this.$$.ctx[4];
  }
  set controls(value) {
    throw new Error_13("<OrbitControls>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var OrbitControls_default = OrbitControls2;

// node_modules/three/examples/jsm/controls/TransformControls.js
var _raycaster = new Raycaster();
var _tempVector = new Vector3();
var _tempVector2 = new Vector3();
var _tempQuaternion = new Quaternion();
var _unit = {
  X: new Vector3(1, 0, 0),
  Y: new Vector3(0, 1, 0),
  Z: new Vector3(0, 0, 1)
};
var _changeEvent2 = { type: "change" };
var _mouseDownEvent = { type: "mouseDown" };
var _mouseUpEvent = { type: "mouseUp", mode: null };
var _objectChangeEvent = { type: "objectChange" };
var TransformControls = class extends Object3D {
  constructor(camera, domElement) {
    super();
    if (domElement === void 0) {
      console.warn('THREE.TransformControls: The second parameter "domElement" is now mandatory.');
      domElement = document;
    }
    this.isTransformControls = true;
    this.visible = false;
    this.domElement = domElement;
    this.domElement.style.touchAction = "none";
    const _gizmo = new TransformControlsGizmo();
    this._gizmo = _gizmo;
    this.add(_gizmo);
    const _plane = new TransformControlsPlane();
    this._plane = _plane;
    this.add(_plane);
    const scope = this;
    function defineProperty(propName, defaultValue) {
      let propValue = defaultValue;
      Object.defineProperty(scope, propName, {
        get: function() {
          return propValue !== void 0 ? propValue : defaultValue;
        },
        set: function(value) {
          if (propValue !== value) {
            propValue = value;
            _plane[propName] = value;
            _gizmo[propName] = value;
            scope.dispatchEvent({ type: propName + "-changed", value });
            scope.dispatchEvent(_changeEvent2);
          }
        }
      });
      scope[propName] = defaultValue;
      _plane[propName] = defaultValue;
      _gizmo[propName] = defaultValue;
    }
    defineProperty("camera", camera);
    defineProperty("object", void 0);
    defineProperty("enabled", true);
    defineProperty("axis", null);
    defineProperty("mode", "translate");
    defineProperty("translationSnap", null);
    defineProperty("rotationSnap", null);
    defineProperty("scaleSnap", null);
    defineProperty("space", "world");
    defineProperty("size", 1);
    defineProperty("dragging", false);
    defineProperty("showX", true);
    defineProperty("showY", true);
    defineProperty("showZ", true);
    const worldPosition = new Vector3();
    const worldPositionStart = new Vector3();
    const worldQuaternion = new Quaternion();
    const worldQuaternionStart = new Quaternion();
    const cameraPosition = new Vector3();
    const cameraQuaternion = new Quaternion();
    const pointStart = new Vector3();
    const pointEnd = new Vector3();
    const rotationAxis = new Vector3();
    const rotationAngle = 0;
    const eye = new Vector3();
    defineProperty("worldPosition", worldPosition);
    defineProperty("worldPositionStart", worldPositionStart);
    defineProperty("worldQuaternion", worldQuaternion);
    defineProperty("worldQuaternionStart", worldQuaternionStart);
    defineProperty("cameraPosition", cameraPosition);
    defineProperty("cameraQuaternion", cameraQuaternion);
    defineProperty("pointStart", pointStart);
    defineProperty("pointEnd", pointEnd);
    defineProperty("rotationAxis", rotationAxis);
    defineProperty("rotationAngle", rotationAngle);
    defineProperty("eye", eye);
    this._offset = new Vector3();
    this._startNorm = new Vector3();
    this._endNorm = new Vector3();
    this._cameraScale = new Vector3();
    this._parentPosition = new Vector3();
    this._parentQuaternion = new Quaternion();
    this._parentQuaternionInv = new Quaternion();
    this._parentScale = new Vector3();
    this._worldScaleStart = new Vector3();
    this._worldQuaternionInv = new Quaternion();
    this._worldScale = new Vector3();
    this._positionStart = new Vector3();
    this._quaternionStart = new Quaternion();
    this._scaleStart = new Vector3();
    this._getPointer = getPointer.bind(this);
    this._onPointerDown = onPointerDown.bind(this);
    this._onPointerHover = onPointerHover.bind(this);
    this._onPointerMove = onPointerMove.bind(this);
    this._onPointerUp = onPointerUp.bind(this);
    this.domElement.addEventListener("pointerdown", this._onPointerDown);
    this.domElement.addEventListener("pointermove", this._onPointerHover);
    this.domElement.addEventListener("pointerup", this._onPointerUp);
  }
  // updateMatrixWorld  updates key transformation variables
  updateMatrixWorld() {
    if (this.object !== void 0) {
      this.object.updateMatrixWorld();
      if (this.object.parent === null) {
        console.error("TransformControls: The attached 3D object must be a part of the scene graph.");
      } else {
        this.object.parent.matrixWorld.decompose(this._parentPosition, this._parentQuaternion, this._parentScale);
      }
      this.object.matrixWorld.decompose(this.worldPosition, this.worldQuaternion, this._worldScale);
      this._parentQuaternionInv.copy(this._parentQuaternion).invert();
      this._worldQuaternionInv.copy(this.worldQuaternion).invert();
    }
    this.camera.updateMatrixWorld();
    this.camera.matrixWorld.decompose(this.cameraPosition, this.cameraQuaternion, this._cameraScale);
    if (this.camera.isOrthographicCamera) {
      this.camera.getWorldDirection(this.eye).negate();
    } else {
      this.eye.copy(this.cameraPosition).sub(this.worldPosition).normalize();
    }
    super.updateMatrixWorld(this);
  }
  pointerHover(pointer) {
    if (this.object === void 0 || this.dragging === true)
      return;
    _raycaster.setFromCamera(pointer, this.camera);
    const intersect = intersectObjectWithRay(this._gizmo.picker[this.mode], _raycaster);
    if (intersect) {
      this.axis = intersect.object.name;
    } else {
      this.axis = null;
    }
  }
  pointerDown(pointer) {
    if (this.object === void 0 || this.dragging === true || pointer.button !== 0)
      return;
    if (this.axis !== null) {
      _raycaster.setFromCamera(pointer, this.camera);
      const planeIntersect = intersectObjectWithRay(this._plane, _raycaster, true);
      if (planeIntersect) {
        this.object.updateMatrixWorld();
        this.object.parent.updateMatrixWorld();
        this._positionStart.copy(this.object.position);
        this._quaternionStart.copy(this.object.quaternion);
        this._scaleStart.copy(this.object.scale);
        this.object.matrixWorld.decompose(this.worldPositionStart, this.worldQuaternionStart, this._worldScaleStart);
        this.pointStart.copy(planeIntersect.point).sub(this.worldPositionStart);
      }
      this.dragging = true;
      _mouseDownEvent.mode = this.mode;
      this.dispatchEvent(_mouseDownEvent);
    }
  }
  pointerMove(pointer) {
    const axis = this.axis;
    const mode = this.mode;
    const object = this.object;
    let space2 = this.space;
    if (mode === "scale") {
      space2 = "local";
    } else if (axis === "E" || axis === "XYZE" || axis === "XYZ") {
      space2 = "world";
    }
    if (object === void 0 || axis === null || this.dragging === false || pointer.button !== -1)
      return;
    _raycaster.setFromCamera(pointer, this.camera);
    const planeIntersect = intersectObjectWithRay(this._plane, _raycaster, true);
    if (!planeIntersect)
      return;
    this.pointEnd.copy(planeIntersect.point).sub(this.worldPositionStart);
    if (mode === "translate") {
      this._offset.copy(this.pointEnd).sub(this.pointStart);
      if (space2 === "local" && axis !== "XYZ") {
        this._offset.applyQuaternion(this._worldQuaternionInv);
      }
      if (axis.indexOf("X") === -1)
        this._offset.x = 0;
      if (axis.indexOf("Y") === -1)
        this._offset.y = 0;
      if (axis.indexOf("Z") === -1)
        this._offset.z = 0;
      if (space2 === "local" && axis !== "XYZ") {
        this._offset.applyQuaternion(this._quaternionStart).divide(this._parentScale);
      } else {
        this._offset.applyQuaternion(this._parentQuaternionInv).divide(this._parentScale);
      }
      object.position.copy(this._offset).add(this._positionStart);
      if (this.translationSnap) {
        if (space2 === "local") {
          object.position.applyQuaternion(_tempQuaternion.copy(this._quaternionStart).invert());
          if (axis.search("X") !== -1) {
            object.position.x = Math.round(object.position.x / this.translationSnap) * this.translationSnap;
          }
          if (axis.search("Y") !== -1) {
            object.position.y = Math.round(object.position.y / this.translationSnap) * this.translationSnap;
          }
          if (axis.search("Z") !== -1) {
            object.position.z = Math.round(object.position.z / this.translationSnap) * this.translationSnap;
          }
          object.position.applyQuaternion(this._quaternionStart);
        }
        if (space2 === "world") {
          if (object.parent) {
            object.position.add(_tempVector.setFromMatrixPosition(object.parent.matrixWorld));
          }
          if (axis.search("X") !== -1) {
            object.position.x = Math.round(object.position.x / this.translationSnap) * this.translationSnap;
          }
          if (axis.search("Y") !== -1) {
            object.position.y = Math.round(object.position.y / this.translationSnap) * this.translationSnap;
          }
          if (axis.search("Z") !== -1) {
            object.position.z = Math.round(object.position.z / this.translationSnap) * this.translationSnap;
          }
          if (object.parent) {
            object.position.sub(_tempVector.setFromMatrixPosition(object.parent.matrixWorld));
          }
        }
      }
    } else if (mode === "scale") {
      if (axis.search("XYZ") !== -1) {
        let d = this.pointEnd.length() / this.pointStart.length();
        if (this.pointEnd.dot(this.pointStart) < 0)
          d *= -1;
        _tempVector2.set(d, d, d);
      } else {
        _tempVector.copy(this.pointStart);
        _tempVector2.copy(this.pointEnd);
        _tempVector.applyQuaternion(this._worldQuaternionInv);
        _tempVector2.applyQuaternion(this._worldQuaternionInv);
        _tempVector2.divide(_tempVector);
        if (axis.search("X") === -1) {
          _tempVector2.x = 1;
        }
        if (axis.search("Y") === -1) {
          _tempVector2.y = 1;
        }
        if (axis.search("Z") === -1) {
          _tempVector2.z = 1;
        }
      }
      object.scale.copy(this._scaleStart).multiply(_tempVector2);
      if (this.scaleSnap) {
        if (axis.search("X") !== -1) {
          object.scale.x = Math.round(object.scale.x / this.scaleSnap) * this.scaleSnap || this.scaleSnap;
        }
        if (axis.search("Y") !== -1) {
          object.scale.y = Math.round(object.scale.y / this.scaleSnap) * this.scaleSnap || this.scaleSnap;
        }
        if (axis.search("Z") !== -1) {
          object.scale.z = Math.round(object.scale.z / this.scaleSnap) * this.scaleSnap || this.scaleSnap;
        }
      }
    } else if (mode === "rotate") {
      this._offset.copy(this.pointEnd).sub(this.pointStart);
      const ROTATION_SPEED = 20 / this.worldPosition.distanceTo(_tempVector.setFromMatrixPosition(this.camera.matrixWorld));
      if (axis === "E") {
        this.rotationAxis.copy(this.eye);
        this.rotationAngle = this.pointEnd.angleTo(this.pointStart);
        this._startNorm.copy(this.pointStart).normalize();
        this._endNorm.copy(this.pointEnd).normalize();
        this.rotationAngle *= this._endNorm.cross(this._startNorm).dot(this.eye) < 0 ? 1 : -1;
      } else if (axis === "XYZE") {
        this.rotationAxis.copy(this._offset).cross(this.eye).normalize();
        this.rotationAngle = this._offset.dot(_tempVector.copy(this.rotationAxis).cross(this.eye)) * ROTATION_SPEED;
      } else if (axis === "X" || axis === "Y" || axis === "Z") {
        this.rotationAxis.copy(_unit[axis]);
        _tempVector.copy(_unit[axis]);
        if (space2 === "local") {
          _tempVector.applyQuaternion(this.worldQuaternion);
        }
        this.rotationAngle = this._offset.dot(_tempVector.cross(this.eye).normalize()) * ROTATION_SPEED;
      }
      if (this.rotationSnap)
        this.rotationAngle = Math.round(this.rotationAngle / this.rotationSnap) * this.rotationSnap;
      if (space2 === "local" && axis !== "E" && axis !== "XYZE") {
        object.quaternion.copy(this._quaternionStart);
        object.quaternion.multiply(_tempQuaternion.setFromAxisAngle(this.rotationAxis, this.rotationAngle)).normalize();
      } else {
        this.rotationAxis.applyQuaternion(this._parentQuaternionInv);
        object.quaternion.copy(_tempQuaternion.setFromAxisAngle(this.rotationAxis, this.rotationAngle));
        object.quaternion.multiply(this._quaternionStart).normalize();
      }
    }
    this.dispatchEvent(_changeEvent2);
    this.dispatchEvent(_objectChangeEvent);
  }
  pointerUp(pointer) {
    if (pointer.button !== 0)
      return;
    if (this.dragging && this.axis !== null) {
      _mouseUpEvent.mode = this.mode;
      this.dispatchEvent(_mouseUpEvent);
    }
    this.dragging = false;
    this.axis = null;
  }
  dispose() {
    this.domElement.removeEventListener("pointerdown", this._onPointerDown);
    this.domElement.removeEventListener("pointermove", this._onPointerHover);
    this.domElement.removeEventListener("pointermove", this._onPointerMove);
    this.domElement.removeEventListener("pointerup", this._onPointerUp);
    this.traverse(function(child) {
      if (child.geometry)
        child.geometry.dispose();
      if (child.material)
        child.material.dispose();
    });
  }
  // Set current object
  attach(object) {
    this.object = object;
    this.visible = true;
    return this;
  }
  // Detach from object
  detach() {
    this.object = void 0;
    this.visible = false;
    this.axis = null;
    return this;
  }
  reset() {
    if (!this.enabled)
      return;
    if (this.dragging) {
      this.object.position.copy(this._positionStart);
      this.object.quaternion.copy(this._quaternionStart);
      this.object.scale.copy(this._scaleStart);
      this.dispatchEvent(_changeEvent2);
      this.dispatchEvent(_objectChangeEvent);
      this.pointStart.copy(this.pointEnd);
    }
  }
  getRaycaster() {
    return _raycaster;
  }
  // TODO: deprecate
  getMode() {
    return this.mode;
  }
  setMode(mode) {
    this.mode = mode;
  }
  setTranslationSnap(translationSnap) {
    this.translationSnap = translationSnap;
  }
  setRotationSnap(rotationSnap) {
    this.rotationSnap = rotationSnap;
  }
  setScaleSnap(scaleSnap) {
    this.scaleSnap = scaleSnap;
  }
  setSize(size) {
    this.size = size;
  }
  setSpace(space2) {
    this.space = space2;
  }
};
function getPointer(event) {
  if (this.domElement.ownerDocument.pointerLockElement) {
    return {
      x: 0,
      y: 0,
      button: event.button
    };
  } else {
    const rect = this.domElement.getBoundingClientRect();
    return {
      x: (event.clientX - rect.left) / rect.width * 2 - 1,
      y: -(event.clientY - rect.top) / rect.height * 2 + 1,
      button: event.button
    };
  }
}
function onPointerHover(event) {
  if (!this.enabled)
    return;
  switch (event.pointerType) {
    case "mouse":
    case "pen":
      this.pointerHover(this._getPointer(event));
      break;
  }
}
function onPointerDown(event) {
  if (!this.enabled)
    return;
  if (!document.pointerLockElement) {
    this.domElement.setPointerCapture(event.pointerId);
  }
  this.domElement.addEventListener("pointermove", this._onPointerMove);
  this.pointerHover(this._getPointer(event));
  this.pointerDown(this._getPointer(event));
}
function onPointerMove(event) {
  if (!this.enabled)
    return;
  this.pointerMove(this._getPointer(event));
}
function onPointerUp(event) {
  if (!this.enabled)
    return;
  this.domElement.releasePointerCapture(event.pointerId);
  this.domElement.removeEventListener("pointermove", this._onPointerMove);
  this.pointerUp(this._getPointer(event));
}
function intersectObjectWithRay(object, raycaster, includeInvisible) {
  const allIntersections = raycaster.intersectObject(object, true);
  for (let i = 0; i < allIntersections.length; i++) {
    if (allIntersections[i].object.visible || includeInvisible) {
      return allIntersections[i];
    }
  }
  return false;
}
var _tempEuler = new Euler();
var _alignVector = new Vector3(0, 1, 0);
var _zeroVector = new Vector3(0, 0, 0);
var _lookAtMatrix = new Matrix4();
var _tempQuaternion2 = new Quaternion();
var _identityQuaternion = new Quaternion();
var _dirVector = new Vector3();
var _tempMatrix = new Matrix4();
var _unitX = new Vector3(1, 0, 0);
var _unitY = new Vector3(0, 1, 0);
var _unitZ = new Vector3(0, 0, 1);
var _v1 = new Vector3();
var _v2 = new Vector3();
var _v3 = new Vector3();
var TransformControlsGizmo = class extends Object3D {
  constructor() {
    super();
    this.isTransformControlsGizmo = true;
    this.type = "TransformControlsGizmo";
    const gizmoMaterial = new MeshBasicMaterial({
      depthTest: false,
      depthWrite: false,
      fog: false,
      toneMapped: false,
      transparent: true
    });
    const gizmoLineMaterial = new LineBasicMaterial({
      depthTest: false,
      depthWrite: false,
      fog: false,
      toneMapped: false,
      transparent: true
    });
    const matInvisible = gizmoMaterial.clone();
    matInvisible.opacity = 0.15;
    const matHelper = gizmoLineMaterial.clone();
    matHelper.opacity = 0.5;
    const matRed = gizmoMaterial.clone();
    matRed.color.setHex(16711680);
    const matGreen = gizmoMaterial.clone();
    matGreen.color.setHex(65280);
    const matBlue = gizmoMaterial.clone();
    matBlue.color.setHex(255);
    const matRedTransparent = gizmoMaterial.clone();
    matRedTransparent.color.setHex(16711680);
    matRedTransparent.opacity = 0.5;
    const matGreenTransparent = gizmoMaterial.clone();
    matGreenTransparent.color.setHex(65280);
    matGreenTransparent.opacity = 0.5;
    const matBlueTransparent = gizmoMaterial.clone();
    matBlueTransparent.color.setHex(255);
    matBlueTransparent.opacity = 0.5;
    const matWhiteTransparent = gizmoMaterial.clone();
    matWhiteTransparent.opacity = 0.25;
    const matYellowTransparent = gizmoMaterial.clone();
    matYellowTransparent.color.setHex(16776960);
    matYellowTransparent.opacity = 0.25;
    const matYellow = gizmoMaterial.clone();
    matYellow.color.setHex(16776960);
    const matGray = gizmoMaterial.clone();
    matGray.color.setHex(7895160);
    const arrowGeometry = new CylinderGeometry(0, 0.04, 0.1, 12);
    arrowGeometry.translate(0, 0.05, 0);
    const scaleHandleGeometry = new BoxGeometry(0.08, 0.08, 0.08);
    scaleHandleGeometry.translate(0, 0.04, 0);
    const lineGeometry = new BufferGeometry();
    lineGeometry.setAttribute("position", new Float32BufferAttribute([0, 0, 0, 1, 0, 0], 3));
    const lineGeometry2 = new CylinderGeometry(75e-4, 75e-4, 0.5, 3);
    lineGeometry2.translate(0, 0.25, 0);
    function CircleGeometry(radius, arc) {
      const geometry = new TorusGeometry(radius, 75e-4, 3, 64, arc * Math.PI * 2);
      geometry.rotateY(Math.PI / 2);
      geometry.rotateX(Math.PI / 2);
      return geometry;
    }
    function TranslateHelperGeometry() {
      const geometry = new BufferGeometry();
      geometry.setAttribute("position", new Float32BufferAttribute([0, 0, 0, 1, 1, 1], 3));
      return geometry;
    }
    const gizmoTranslate = {
      X: [
        [new Mesh(arrowGeometry, matRed), [0.5, 0, 0], [0, 0, -Math.PI / 2]],
        [new Mesh(arrowGeometry, matRed), [-0.5, 0, 0], [0, 0, Math.PI / 2]],
        [new Mesh(lineGeometry2, matRed), [0, 0, 0], [0, 0, -Math.PI / 2]]
      ],
      Y: [
        [new Mesh(arrowGeometry, matGreen), [0, 0.5, 0]],
        [new Mesh(arrowGeometry, matGreen), [0, -0.5, 0], [Math.PI, 0, 0]],
        [new Mesh(lineGeometry2, matGreen)]
      ],
      Z: [
        [new Mesh(arrowGeometry, matBlue), [0, 0, 0.5], [Math.PI / 2, 0, 0]],
        [new Mesh(arrowGeometry, matBlue), [0, 0, -0.5], [-Math.PI / 2, 0, 0]],
        [new Mesh(lineGeometry2, matBlue), null, [Math.PI / 2, 0, 0]]
      ],
      XYZ: [
        [new Mesh(new OctahedronGeometry(0.1, 0), matWhiteTransparent.clone()), [0, 0, 0]]
      ],
      XY: [
        [new Mesh(new BoxGeometry(0.15, 0.15, 0.01), matBlueTransparent.clone()), [0.15, 0.15, 0]]
      ],
      YZ: [
        [new Mesh(new BoxGeometry(0.15, 0.15, 0.01), matRedTransparent.clone()), [0, 0.15, 0.15], [0, Math.PI / 2, 0]]
      ],
      XZ: [
        [new Mesh(new BoxGeometry(0.15, 0.15, 0.01), matGreenTransparent.clone()), [0.15, 0, 0.15], [-Math.PI / 2, 0, 0]]
      ]
    };
    const pickerTranslate = {
      X: [
        [new Mesh(new CylinderGeometry(0.2, 0, 0.6, 4), matInvisible), [0.3, 0, 0], [0, 0, -Math.PI / 2]],
        [new Mesh(new CylinderGeometry(0.2, 0, 0.6, 4), matInvisible), [-0.3, 0, 0], [0, 0, Math.PI / 2]]
      ],
      Y: [
        [new Mesh(new CylinderGeometry(0.2, 0, 0.6, 4), matInvisible), [0, 0.3, 0]],
        [new Mesh(new CylinderGeometry(0.2, 0, 0.6, 4), matInvisible), [0, -0.3, 0], [0, 0, Math.PI]]
      ],
      Z: [
        [new Mesh(new CylinderGeometry(0.2, 0, 0.6, 4), matInvisible), [0, 0, 0.3], [Math.PI / 2, 0, 0]],
        [new Mesh(new CylinderGeometry(0.2, 0, 0.6, 4), matInvisible), [0, 0, -0.3], [-Math.PI / 2, 0, 0]]
      ],
      XYZ: [
        [new Mesh(new OctahedronGeometry(0.2, 0), matInvisible)]
      ],
      XY: [
        [new Mesh(new BoxGeometry(0.2, 0.2, 0.01), matInvisible), [0.15, 0.15, 0]]
      ],
      YZ: [
        [new Mesh(new BoxGeometry(0.2, 0.2, 0.01), matInvisible), [0, 0.15, 0.15], [0, Math.PI / 2, 0]]
      ],
      XZ: [
        [new Mesh(new BoxGeometry(0.2, 0.2, 0.01), matInvisible), [0.15, 0, 0.15], [-Math.PI / 2, 0, 0]]
      ]
    };
    const helperTranslate = {
      START: [
        [new Mesh(new OctahedronGeometry(0.01, 2), matHelper), null, null, null, "helper"]
      ],
      END: [
        [new Mesh(new OctahedronGeometry(0.01, 2), matHelper), null, null, null, "helper"]
      ],
      DELTA: [
        [new Line(TranslateHelperGeometry(), matHelper), null, null, null, "helper"]
      ],
      X: [
        [new Line(lineGeometry, matHelper.clone()), [-1e3, 0, 0], null, [1e6, 1, 1], "helper"]
      ],
      Y: [
        [new Line(lineGeometry, matHelper.clone()), [0, -1e3, 0], [0, 0, Math.PI / 2], [1e6, 1, 1], "helper"]
      ],
      Z: [
        [new Line(lineGeometry, matHelper.clone()), [0, 0, -1e3], [0, -Math.PI / 2, 0], [1e6, 1, 1], "helper"]
      ]
    };
    const gizmoRotate = {
      XYZE: [
        [new Mesh(CircleGeometry(0.5, 1), matGray), null, [0, Math.PI / 2, 0]]
      ],
      X: [
        [new Mesh(CircleGeometry(0.5, 0.5), matRed)]
      ],
      Y: [
        [new Mesh(CircleGeometry(0.5, 0.5), matGreen), null, [0, 0, -Math.PI / 2]]
      ],
      Z: [
        [new Mesh(CircleGeometry(0.5, 0.5), matBlue), null, [0, Math.PI / 2, 0]]
      ],
      E: [
        [new Mesh(CircleGeometry(0.75, 1), matYellowTransparent), null, [0, Math.PI / 2, 0]]
      ]
    };
    const helperRotate = {
      AXIS: [
        [new Line(lineGeometry, matHelper.clone()), [-1e3, 0, 0], null, [1e6, 1, 1], "helper"]
      ]
    };
    const pickerRotate = {
      XYZE: [
        [new Mesh(new SphereGeometry(0.25, 10, 8), matInvisible)]
      ],
      X: [
        [new Mesh(new TorusGeometry(0.5, 0.1, 4, 24), matInvisible), [0, 0, 0], [0, -Math.PI / 2, -Math.PI / 2]]
      ],
      Y: [
        [new Mesh(new TorusGeometry(0.5, 0.1, 4, 24), matInvisible), [0, 0, 0], [Math.PI / 2, 0, 0]]
      ],
      Z: [
        [new Mesh(new TorusGeometry(0.5, 0.1, 4, 24), matInvisible), [0, 0, 0], [0, 0, -Math.PI / 2]]
      ],
      E: [
        [new Mesh(new TorusGeometry(0.75, 0.1, 2, 24), matInvisible)]
      ]
    };
    const gizmoScale = {
      X: [
        [new Mesh(scaleHandleGeometry, matRed), [0.5, 0, 0], [0, 0, -Math.PI / 2]],
        [new Mesh(lineGeometry2, matRed), [0, 0, 0], [0, 0, -Math.PI / 2]],
        [new Mesh(scaleHandleGeometry, matRed), [-0.5, 0, 0], [0, 0, Math.PI / 2]]
      ],
      Y: [
        [new Mesh(scaleHandleGeometry, matGreen), [0, 0.5, 0]],
        [new Mesh(lineGeometry2, matGreen)],
        [new Mesh(scaleHandleGeometry, matGreen), [0, -0.5, 0], [0, 0, Math.PI]]
      ],
      Z: [
        [new Mesh(scaleHandleGeometry, matBlue), [0, 0, 0.5], [Math.PI / 2, 0, 0]],
        [new Mesh(lineGeometry2, matBlue), [0, 0, 0], [Math.PI / 2, 0, 0]],
        [new Mesh(scaleHandleGeometry, matBlue), [0, 0, -0.5], [-Math.PI / 2, 0, 0]]
      ],
      XY: [
        [new Mesh(new BoxGeometry(0.15, 0.15, 0.01), matBlueTransparent), [0.15, 0.15, 0]]
      ],
      YZ: [
        [new Mesh(new BoxGeometry(0.15, 0.15, 0.01), matRedTransparent), [0, 0.15, 0.15], [0, Math.PI / 2, 0]]
      ],
      XZ: [
        [new Mesh(new BoxGeometry(0.15, 0.15, 0.01), matGreenTransparent), [0.15, 0, 0.15], [-Math.PI / 2, 0, 0]]
      ],
      XYZ: [
        [new Mesh(new BoxGeometry(0.1, 0.1, 0.1), matWhiteTransparent.clone())]
      ]
    };
    const pickerScale = {
      X: [
        [new Mesh(new CylinderGeometry(0.2, 0, 0.6, 4), matInvisible), [0.3, 0, 0], [0, 0, -Math.PI / 2]],
        [new Mesh(new CylinderGeometry(0.2, 0, 0.6, 4), matInvisible), [-0.3, 0, 0], [0, 0, Math.PI / 2]]
      ],
      Y: [
        [new Mesh(new CylinderGeometry(0.2, 0, 0.6, 4), matInvisible), [0, 0.3, 0]],
        [new Mesh(new CylinderGeometry(0.2, 0, 0.6, 4), matInvisible), [0, -0.3, 0], [0, 0, Math.PI]]
      ],
      Z: [
        [new Mesh(new CylinderGeometry(0.2, 0, 0.6, 4), matInvisible), [0, 0, 0.3], [Math.PI / 2, 0, 0]],
        [new Mesh(new CylinderGeometry(0.2, 0, 0.6, 4), matInvisible), [0, 0, -0.3], [-Math.PI / 2, 0, 0]]
      ],
      XY: [
        [new Mesh(new BoxGeometry(0.2, 0.2, 0.01), matInvisible), [0.15, 0.15, 0]]
      ],
      YZ: [
        [new Mesh(new BoxGeometry(0.2, 0.2, 0.01), matInvisible), [0, 0.15, 0.15], [0, Math.PI / 2, 0]]
      ],
      XZ: [
        [new Mesh(new BoxGeometry(0.2, 0.2, 0.01), matInvisible), [0.15, 0, 0.15], [-Math.PI / 2, 0, 0]]
      ],
      XYZ: [
        [new Mesh(new BoxGeometry(0.2, 0.2, 0.2), matInvisible), [0, 0, 0]]
      ]
    };
    const helperScale = {
      X: [
        [new Line(lineGeometry, matHelper.clone()), [-1e3, 0, 0], null, [1e6, 1, 1], "helper"]
      ],
      Y: [
        [new Line(lineGeometry, matHelper.clone()), [0, -1e3, 0], [0, 0, Math.PI / 2], [1e6, 1, 1], "helper"]
      ],
      Z: [
        [new Line(lineGeometry, matHelper.clone()), [0, 0, -1e3], [0, -Math.PI / 2, 0], [1e6, 1, 1], "helper"]
      ]
    };
    function setupGizmo(gizmoMap) {
      const gizmo = new Object3D();
      for (const name in gizmoMap) {
        for (let i = gizmoMap[name].length; i--; ) {
          const object = gizmoMap[name][i][0].clone();
          const position = gizmoMap[name][i][1];
          const rotation = gizmoMap[name][i][2];
          const scale = gizmoMap[name][i][3];
          const tag = gizmoMap[name][i][4];
          object.name = name;
          object.tag = tag;
          if (position) {
            object.position.set(position[0], position[1], position[2]);
          }
          if (rotation) {
            object.rotation.set(rotation[0], rotation[1], rotation[2]);
          }
          if (scale) {
            object.scale.set(scale[0], scale[1], scale[2]);
          }
          object.updateMatrix();
          const tempGeometry = object.geometry.clone();
          tempGeometry.applyMatrix4(object.matrix);
          object.geometry = tempGeometry;
          object.renderOrder = Infinity;
          object.position.set(0, 0, 0);
          object.rotation.set(0, 0, 0);
          object.scale.set(1, 1, 1);
          gizmo.add(object);
        }
      }
      return gizmo;
    }
    this.gizmo = {};
    this.picker = {};
    this.helper = {};
    this.add(this.gizmo["translate"] = setupGizmo(gizmoTranslate));
    this.add(this.gizmo["rotate"] = setupGizmo(gizmoRotate));
    this.add(this.gizmo["scale"] = setupGizmo(gizmoScale));
    this.add(this.picker["translate"] = setupGizmo(pickerTranslate));
    this.add(this.picker["rotate"] = setupGizmo(pickerRotate));
    this.add(this.picker["scale"] = setupGizmo(pickerScale));
    this.add(this.helper["translate"] = setupGizmo(helperTranslate));
    this.add(this.helper["rotate"] = setupGizmo(helperRotate));
    this.add(this.helper["scale"] = setupGizmo(helperScale));
    this.picker["translate"].visible = false;
    this.picker["rotate"].visible = false;
    this.picker["scale"].visible = false;
  }
  // updateMatrixWorld will update transformations and appearance of individual handles
  updateMatrixWorld(force) {
    const space2 = this.mode === "scale" ? "local" : this.space;
    const quaternion = space2 === "local" ? this.worldQuaternion : _identityQuaternion;
    this.gizmo["translate"].visible = this.mode === "translate";
    this.gizmo["rotate"].visible = this.mode === "rotate";
    this.gizmo["scale"].visible = this.mode === "scale";
    this.helper["translate"].visible = this.mode === "translate";
    this.helper["rotate"].visible = this.mode === "rotate";
    this.helper["scale"].visible = this.mode === "scale";
    let handles = [];
    handles = handles.concat(this.picker[this.mode].children);
    handles = handles.concat(this.gizmo[this.mode].children);
    handles = handles.concat(this.helper[this.mode].children);
    for (let i = 0; i < handles.length; i++) {
      const handle = handles[i];
      handle.visible = true;
      handle.rotation.set(0, 0, 0);
      handle.position.copy(this.worldPosition);
      let factor;
      if (this.camera.isOrthographicCamera) {
        factor = (this.camera.top - this.camera.bottom) / this.camera.zoom;
      } else {
        factor = this.worldPosition.distanceTo(this.cameraPosition) * Math.min(1.9 * Math.tan(Math.PI * this.camera.fov / 360) / this.camera.zoom, 7);
      }
      handle.scale.set(1, 1, 1).multiplyScalar(factor * this.size / 4);
      if (handle.tag === "helper") {
        handle.visible = false;
        if (handle.name === "AXIS") {
          handle.visible = !!this.axis;
          if (this.axis === "X") {
            _tempQuaternion.setFromEuler(_tempEuler.set(0, 0, 0));
            handle.quaternion.copy(quaternion).multiply(_tempQuaternion);
            if (Math.abs(_alignVector.copy(_unitX).applyQuaternion(quaternion).dot(this.eye)) > 0.9) {
              handle.visible = false;
            }
          }
          if (this.axis === "Y") {
            _tempQuaternion.setFromEuler(_tempEuler.set(0, 0, Math.PI / 2));
            handle.quaternion.copy(quaternion).multiply(_tempQuaternion);
            if (Math.abs(_alignVector.copy(_unitY).applyQuaternion(quaternion).dot(this.eye)) > 0.9) {
              handle.visible = false;
            }
          }
          if (this.axis === "Z") {
            _tempQuaternion.setFromEuler(_tempEuler.set(0, Math.PI / 2, 0));
            handle.quaternion.copy(quaternion).multiply(_tempQuaternion);
            if (Math.abs(_alignVector.copy(_unitZ).applyQuaternion(quaternion).dot(this.eye)) > 0.9) {
              handle.visible = false;
            }
          }
          if (this.axis === "XYZE") {
            _tempQuaternion.setFromEuler(_tempEuler.set(0, Math.PI / 2, 0));
            _alignVector.copy(this.rotationAxis);
            handle.quaternion.setFromRotationMatrix(_lookAtMatrix.lookAt(_zeroVector, _alignVector, _unitY));
            handle.quaternion.multiply(_tempQuaternion);
            handle.visible = this.dragging;
          }
          if (this.axis === "E") {
            handle.visible = false;
          }
        } else if (handle.name === "START") {
          handle.position.copy(this.worldPositionStart);
          handle.visible = this.dragging;
        } else if (handle.name === "END") {
          handle.position.copy(this.worldPosition);
          handle.visible = this.dragging;
        } else if (handle.name === "DELTA") {
          handle.position.copy(this.worldPositionStart);
          handle.quaternion.copy(this.worldQuaternionStart);
          _tempVector.set(1e-10, 1e-10, 1e-10).add(this.worldPositionStart).sub(this.worldPosition).multiplyScalar(-1);
          _tempVector.applyQuaternion(this.worldQuaternionStart.clone().invert());
          handle.scale.copy(_tempVector);
          handle.visible = this.dragging;
        } else {
          handle.quaternion.copy(quaternion);
          if (this.dragging) {
            handle.position.copy(this.worldPositionStart);
          } else {
            handle.position.copy(this.worldPosition);
          }
          if (this.axis) {
            handle.visible = this.axis.search(handle.name) !== -1;
          }
        }
        continue;
      }
      handle.quaternion.copy(quaternion);
      if (this.mode === "translate" || this.mode === "scale") {
        const AXIS_HIDE_THRESHOLD = 0.99;
        const PLANE_HIDE_THRESHOLD = 0.2;
        if (handle.name === "X") {
          if (Math.abs(_alignVector.copy(_unitX).applyQuaternion(quaternion).dot(this.eye)) > AXIS_HIDE_THRESHOLD) {
            handle.scale.set(1e-10, 1e-10, 1e-10);
            handle.visible = false;
          }
        }
        if (handle.name === "Y") {
          if (Math.abs(_alignVector.copy(_unitY).applyQuaternion(quaternion).dot(this.eye)) > AXIS_HIDE_THRESHOLD) {
            handle.scale.set(1e-10, 1e-10, 1e-10);
            handle.visible = false;
          }
        }
        if (handle.name === "Z") {
          if (Math.abs(_alignVector.copy(_unitZ).applyQuaternion(quaternion).dot(this.eye)) > AXIS_HIDE_THRESHOLD) {
            handle.scale.set(1e-10, 1e-10, 1e-10);
            handle.visible = false;
          }
        }
        if (handle.name === "XY") {
          if (Math.abs(_alignVector.copy(_unitZ).applyQuaternion(quaternion).dot(this.eye)) < PLANE_HIDE_THRESHOLD) {
            handle.scale.set(1e-10, 1e-10, 1e-10);
            handle.visible = false;
          }
        }
        if (handle.name === "YZ") {
          if (Math.abs(_alignVector.copy(_unitX).applyQuaternion(quaternion).dot(this.eye)) < PLANE_HIDE_THRESHOLD) {
            handle.scale.set(1e-10, 1e-10, 1e-10);
            handle.visible = false;
          }
        }
        if (handle.name === "XZ") {
          if (Math.abs(_alignVector.copy(_unitY).applyQuaternion(quaternion).dot(this.eye)) < PLANE_HIDE_THRESHOLD) {
            handle.scale.set(1e-10, 1e-10, 1e-10);
            handle.visible = false;
          }
        }
      } else if (this.mode === "rotate") {
        _tempQuaternion2.copy(quaternion);
        _alignVector.copy(this.eye).applyQuaternion(_tempQuaternion.copy(quaternion).invert());
        if (handle.name.search("E") !== -1) {
          handle.quaternion.setFromRotationMatrix(_lookAtMatrix.lookAt(this.eye, _zeroVector, _unitY));
        }
        if (handle.name === "X") {
          _tempQuaternion.setFromAxisAngle(_unitX, Math.atan2(-_alignVector.y, _alignVector.z));
          _tempQuaternion.multiplyQuaternions(_tempQuaternion2, _tempQuaternion);
          handle.quaternion.copy(_tempQuaternion);
        }
        if (handle.name === "Y") {
          _tempQuaternion.setFromAxisAngle(_unitY, Math.atan2(_alignVector.x, _alignVector.z));
          _tempQuaternion.multiplyQuaternions(_tempQuaternion2, _tempQuaternion);
          handle.quaternion.copy(_tempQuaternion);
        }
        if (handle.name === "Z") {
          _tempQuaternion.setFromAxisAngle(_unitZ, Math.atan2(_alignVector.y, _alignVector.x));
          _tempQuaternion.multiplyQuaternions(_tempQuaternion2, _tempQuaternion);
          handle.quaternion.copy(_tempQuaternion);
        }
      }
      handle.visible = handle.visible && (handle.name.indexOf("X") === -1 || this.showX);
      handle.visible = handle.visible && (handle.name.indexOf("Y") === -1 || this.showY);
      handle.visible = handle.visible && (handle.name.indexOf("Z") === -1 || this.showZ);
      handle.visible = handle.visible && (handle.name.indexOf("E") === -1 || this.showX && this.showY && this.showZ);
      handle.material._color = handle.material._color || handle.material.color.clone();
      handle.material._opacity = handle.material._opacity || handle.material.opacity;
      handle.material.color.copy(handle.material._color);
      handle.material.opacity = handle.material._opacity;
      if (this.enabled && this.axis) {
        if (handle.name === this.axis) {
          handle.material.color.setHex(16776960);
          handle.material.opacity = 1;
        } else if (this.axis.split("").some(function(a) {
          return handle.name === a;
        })) {
          handle.material.color.setHex(16776960);
          handle.material.opacity = 1;
        }
      }
    }
    super.updateMatrixWorld(force);
  }
};
var TransformControlsPlane = class extends Mesh {
  constructor() {
    super(
      new PlaneGeometry(1e5, 1e5, 2, 2),
      new MeshBasicMaterial({ visible: false, wireframe: true, side: DoubleSide, transparent: true, opacity: 0.1, toneMapped: false })
    );
    this.isTransformControlsPlane = true;
    this.type = "TransformControlsPlane";
  }
  updateMatrixWorld(force) {
    let space2 = this.space;
    this.position.copy(this.worldPosition);
    if (this.mode === "scale")
      space2 = "local";
    _v1.copy(_unitX).applyQuaternion(space2 === "local" ? this.worldQuaternion : _identityQuaternion);
    _v2.copy(_unitY).applyQuaternion(space2 === "local" ? this.worldQuaternion : _identityQuaternion);
    _v3.copy(_unitZ).applyQuaternion(space2 === "local" ? this.worldQuaternion : _identityQuaternion);
    _alignVector.copy(_v2);
    switch (this.mode) {
      case "translate":
      case "scale":
        switch (this.axis) {
          case "X":
            _alignVector.copy(this.eye).cross(_v1);
            _dirVector.copy(_v1).cross(_alignVector);
            break;
          case "Y":
            _alignVector.copy(this.eye).cross(_v2);
            _dirVector.copy(_v2).cross(_alignVector);
            break;
          case "Z":
            _alignVector.copy(this.eye).cross(_v3);
            _dirVector.copy(_v3).cross(_alignVector);
            break;
          case "XY":
            _dirVector.copy(_v3);
            break;
          case "YZ":
            _dirVector.copy(_v1);
            break;
          case "XZ":
            _alignVector.copy(_v3);
            _dirVector.copy(_v2);
            break;
          case "XYZ":
          case "E":
            _dirVector.set(0, 0, 0);
            break;
        }
        break;
      case "rotate":
      default:
        _dirVector.set(0, 0, 0);
    }
    if (_dirVector.length() === 0) {
      this.quaternion.copy(this.cameraQuaternion);
    } else {
      _tempMatrix.lookAt(_tempVector.set(0, 0, 0), _dirVector, _alignVector);
      this.quaternion.setFromRotationMatrix(_tempMatrix);
    }
    super.updateMatrixWorld(force);
  }
};

// node_modules/threlte/hooks/useOnStoreChange.js
var useOnStoreChange = (store, callback, options) => {
  let oldValue = get_store_value(store);
  let initialized = false;
  const unsubscribe = store.subscribe(async (newValue) => {
    if (!initialized) {
      oldValue = newValue;
      initialized = true;
      return;
    }
    if ((options == null ? void 0 : options.equalityFn) && !options.equalityFn(newValue, oldValue)) {
      await callback(newValue, oldValue);
    } else {
      await callback(newValue, oldValue);
    }
    oldValue = newValue;
  });
  onDestroy(unsubscribe);
};

// node_modules/threlte/controls/TransformControls.svelte
var { Object: Object_1 } = globals;
function create_fragment16(ctx) {
  let layerableobject;
  let current;
  layerableobject = new LayerableObject_default({
    props: { object: (
      /*transformControls*/
      ctx[0]
    ) },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(layerableobject.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(layerableobject.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(layerableobject, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const layerableobject_changes = {};
      if (dirty & /*transformControls*/
      1)
        layerableobject_changes.object = /*transformControls*/
        ctx2[0];
      layerableobject.$set(layerableobject_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(layerableobject.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(layerableobject.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(layerableobject, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment16.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance16($$self, $$props, $$invalidate) {
  let $parent;
  let $camera;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("TransformControls", slots, []);
  let { autoPauseOrbitControls = true } = $$props;
  let { mode = void 0 } = $$props;
  let { axis = null } = $$props;
  let { dragging = false } = $$props;
  let { enabled = void 0 } = $$props;
  let { translationSnap = void 0 } = $$props;
  let { scaleSnap = void 0 } = $$props;
  let { rotationSnap = void 0 } = $$props;
  let { showX = void 0 } = $$props;
  let { showY = void 0 } = $$props;
  let { showZ = void 0 } = $$props;
  let { size = void 0 } = $$props;
  let { space: space2 = void 0 } = $$props;
  const { camera, renderer, invalidate, scene } = useThrelte();
  validate_store(camera, "camera");
  component_subscribe($$self, camera, (value) => $$invalidate(19, $camera = value));
  const parent = getParent();
  validate_store(parent, "parent");
  component_subscribe($$self, parent, (value) => $$invalidate(18, $parent = value));
  const dispatch = createEventDispatcher();
  const maybeGetCameraOrbitControls = () => {
    if (!$camera)
      return;
    return getThrelteUserData($camera).orbitControls;
  };
  let enabledStateBeforeAutoPause;
  const cleanupAutoPause = () => {
    if (enabledStateBeforeAutoPause !== void 0) {
      const orbitControls = maybeGetCameraOrbitControls();
      if (orbitControls)
        orbitControls.enabled = enabledStateBeforeAutoPause;
      enabledStateBeforeAutoPause = void 0;
    }
  };
  onDestroy(cleanupAutoPause);
  const eventMap = {
    change: (e) => {
      var _a, _b;
      (_b = (_a = getThrelteUserData($parent)).onTransform) == null ? void 0 : _b.call(_a);
      invalidate("TransformControls: change event");
      dispatch("change", e);
    },
    "camera-changed": (e) => dispatch("camera-changed", e),
    "object-changed": (e) => dispatch("object-changed", e),
    "enabled-changed": (e) => dispatch("enabled-changed", e),
    "axis-changed": (e) => {
      $$invalidate(3, axis = e.value);
      dispatch("axis-changed", e);
    },
    "mode-changed": (e) => dispatch("mode-changed", e),
    "translationSnap-changed": (e) => dispatch("translationSnap-changed", e),
    "rotationSnap-changed": (e) => dispatch("rotationSnap-changed", e),
    "scaleSnap-changed": (e) => dispatch("scaleSnap-changed", e),
    "space-changed": (e) => dispatch("space-changed", e),
    "size-changed": (e) => dispatch("size-changed", e),
    "dragging-changed": (e) => {
      $$invalidate(4, dragging = e.value);
      autopause: {
        if (autoPauseOrbitControls) {
          const orbitControls = maybeGetCameraOrbitControls();
          if (!orbitControls)
            break autopause;
          const shouldBeEnabled = !e.value;
          if (orbitControls.enabled === shouldBeEnabled)
            break autopause;
          enabledStateBeforeAutoPause = orbitControls.enabled;
          orbitControls.enabled = shouldBeEnabled;
        }
      }
      dispatch("dragging-changed", e);
    },
    "showX-changed": (e) => dispatch("showX-changed", e),
    "showY-changed": (e) => dispatch("showY-changed", e),
    "showZ-changed": (e) => dispatch("showZ-changed", e),
    "worldPosition-changed": (e) => dispatch("worldPosition-changed", e),
    "worldPositionStart-changed": (e) => dispatch("worldPositionStart-changed", e),
    "worldQuaternion-changed": (e) => dispatch("worldQuaternion-changed", e),
    "worldQuaternionStart-changed": (e) => dispatch("worldQuaternionStart-changed", e),
    "cameraPosition-changed": (e) => dispatch("cameraPosition-changed", e),
    "cameraQuaternion-changed": (e) => dispatch("cameraQuaternion-changed", e),
    "pointStart-changed": (e) => dispatch("pointStart-changed", e),
    "pointEnd-changed": (e) => dispatch("pointEnd-changed", e),
    "rotationAxis-changed": (e) => dispatch("rotationAxis-changed", e),
    "rotationAngle-changed": (e) => dispatch("rotationAngle-changed", e),
    "eye-changed": (e) => dispatch("eye-changed", e)
  };
  const transformControls = new TransformControls($camera, renderer.domElement);
  const reset = () => transformControls.reset();
  transformControls.attach($parent);
  useOnStoreChange(
    parent,
    (newParent, oldParent) => {
      if (oldParent !== null) {
        transformControls.detach();
      }
      if (newParent) {
        transformControls.attach(newParent);
      }
    },
    {
      equalityFn: (newParent, oldParent) => (newParent == null ? void 0 : newParent.uuid) === (oldParent == null ? void 0 : oldParent.uuid)
    }
  );
  const addListeners = () => {
    Object.entries(eventMap).forEach(([key, fn]) => {
      transformControls.addEventListener(key, fn);
    });
  };
  const removeListeners = () => {
    Object.entries(eventMap).forEach(([key, fn]) => {
      transformControls.removeEventListener(key, fn);
    });
  };
  addListeners();
  scene.add(transformControls);
  onDestroy(() => {
    transformControls.detach();
    scene.remove(transformControls);
    removeListeners();
    transformControls.dispose();
  });
  const writable_props = [
    "autoPauseOrbitControls",
    "mode",
    "axis",
    "dragging",
    "enabled",
    "translationSnap",
    "scaleSnap",
    "rotationSnap",
    "showX",
    "showY",
    "showZ",
    "size",
    "space"
  ];
  Object_1.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<TransformControls> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("autoPauseOrbitControls" in $$props2)
      $$invalidate(5, autoPauseOrbitControls = $$props2.autoPauseOrbitControls);
    if ("mode" in $$props2)
      $$invalidate(6, mode = $$props2.mode);
    if ("axis" in $$props2)
      $$invalidate(3, axis = $$props2.axis);
    if ("dragging" in $$props2)
      $$invalidate(4, dragging = $$props2.dragging);
    if ("enabled" in $$props2)
      $$invalidate(7, enabled = $$props2.enabled);
    if ("translationSnap" in $$props2)
      $$invalidate(8, translationSnap = $$props2.translationSnap);
    if ("scaleSnap" in $$props2)
      $$invalidate(9, scaleSnap = $$props2.scaleSnap);
    if ("rotationSnap" in $$props2)
      $$invalidate(10, rotationSnap = $$props2.rotationSnap);
    if ("showX" in $$props2)
      $$invalidate(11, showX = $$props2.showX);
    if ("showY" in $$props2)
      $$invalidate(12, showY = $$props2.showY);
    if ("showZ" in $$props2)
      $$invalidate(13, showZ = $$props2.showZ);
    if ("size" in $$props2)
      $$invalidate(14, size = $$props2.size);
    if ("space" in $$props2)
      $$invalidate(15, space2 = $$props2.space);
  };
  $$self.$capture_state = () => ({
    createEventDispatcher,
    onDestroy,
    get: get_store_value,
    TransformControls,
    useOnStoreChange,
    useThrelte,
    getParent,
    LayerableObject: LayerableObject_default,
    getThrelteUserData,
    autoPauseOrbitControls,
    mode,
    axis,
    dragging,
    enabled,
    translationSnap,
    scaleSnap,
    rotationSnap,
    showX,
    showY,
    showZ,
    size,
    space: space2,
    camera,
    renderer,
    invalidate,
    scene,
    parent,
    dispatch,
    maybeGetCameraOrbitControls,
    enabledStateBeforeAutoPause,
    cleanupAutoPause,
    eventMap,
    transformControls,
    reset,
    addListeners,
    removeListeners,
    $parent,
    $camera
  });
  $$self.$inject_state = ($$props2) => {
    if ("autoPauseOrbitControls" in $$props2)
      $$invalidate(5, autoPauseOrbitControls = $$props2.autoPauseOrbitControls);
    if ("mode" in $$props2)
      $$invalidate(6, mode = $$props2.mode);
    if ("axis" in $$props2)
      $$invalidate(3, axis = $$props2.axis);
    if ("dragging" in $$props2)
      $$invalidate(4, dragging = $$props2.dragging);
    if ("enabled" in $$props2)
      $$invalidate(7, enabled = $$props2.enabled);
    if ("translationSnap" in $$props2)
      $$invalidate(8, translationSnap = $$props2.translationSnap);
    if ("scaleSnap" in $$props2)
      $$invalidate(9, scaleSnap = $$props2.scaleSnap);
    if ("rotationSnap" in $$props2)
      $$invalidate(10, rotationSnap = $$props2.rotationSnap);
    if ("showX" in $$props2)
      $$invalidate(11, showX = $$props2.showX);
    if ("showY" in $$props2)
      $$invalidate(12, showY = $$props2.showY);
    if ("showZ" in $$props2)
      $$invalidate(13, showZ = $$props2.showZ);
    if ("size" in $$props2)
      $$invalidate(14, size = $$props2.size);
    if ("space" in $$props2)
      $$invalidate(15, space2 = $$props2.space);
    if ("enabledStateBeforeAutoPause" in $$props2)
      enabledStateBeforeAutoPause = $$props2.enabledStateBeforeAutoPause;
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*autoPauseOrbitControls*/
    32) {
      $:
        if (!autoPauseOrbitControls)
          cleanupAutoPause();
    }
    if ($$self.$$.dirty & /*enabled*/
    128) {
      $:
        if (enabled !== void 0)
          $$invalidate(0, transformControls.enabled = enabled, transformControls);
    }
    if ($$self.$$.dirty & /*showX*/
    2048) {
      $:
        if (showX !== void 0)
          $$invalidate(0, transformControls.showX = showX, transformControls);
    }
    if ($$self.$$.dirty & /*showY*/
    4096) {
      $:
        if (showY !== void 0)
          $$invalidate(0, transformControls.showY = showY, transformControls);
    }
    if ($$self.$$.dirty & /*showZ*/
    8192) {
      $:
        if (showZ !== void 0)
          $$invalidate(0, transformControls.showZ = showZ, transformControls);
    }
    if ($$self.$$.dirty & /*mode, transformControls*/
    65) {
      $:
        if (mode !== void 0)
          transformControls.setMode(mode);
    }
    if ($$self.$$.dirty & /*translationSnap, transformControls*/
    257) {
      $:
        if (translationSnap !== void 0)
          transformControls.setTranslationSnap(translationSnap);
    }
    if ($$self.$$.dirty & /*scaleSnap, transformControls*/
    513) {
      $:
        if (scaleSnap !== void 0)
          transformControls.setScaleSnap(scaleSnap);
    }
    if ($$self.$$.dirty & /*rotationSnap, transformControls*/
    1025) {
      $:
        if (rotationSnap !== void 0)
          transformControls.setRotationSnap(rotationSnap);
    }
    if ($$self.$$.dirty & /*size, transformControls*/
    16385) {
      $:
        if (size !== void 0)
          transformControls.setSize(size);
    }
    if ($$self.$$.dirty & /*space, transformControls*/
    32769) {
      $:
        if (space2 !== void 0)
          transformControls.setSpace(space2);
    }
  };
  return [
    transformControls,
    camera,
    parent,
    axis,
    dragging,
    autoPauseOrbitControls,
    mode,
    enabled,
    translationSnap,
    scaleSnap,
    rotationSnap,
    showX,
    showY,
    showZ,
    size,
    space2,
    reset
  ];
}
var TransformControls_1 = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance16, create_fragment16, safe_not_equal, {
      autoPauseOrbitControls: 5,
      mode: 6,
      axis: 3,
      dragging: 4,
      enabled: 7,
      translationSnap: 8,
      scaleSnap: 9,
      rotationSnap: 10,
      showX: 11,
      showY: 12,
      showZ: 13,
      size: 14,
      space: 15,
      reset: 16
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "TransformControls_1",
      options,
      id: create_fragment16.name
    });
  }
  get autoPauseOrbitControls() {
    throw new Error("<TransformControls>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set autoPauseOrbitControls(value) {
    throw new Error("<TransformControls>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get mode() {
    throw new Error("<TransformControls>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set mode(value) {
    throw new Error("<TransformControls>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get axis() {
    throw new Error("<TransformControls>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set axis(value) {
    throw new Error("<TransformControls>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get dragging() {
    throw new Error("<TransformControls>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set dragging(value) {
    throw new Error("<TransformControls>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get enabled() {
    throw new Error("<TransformControls>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set enabled(value) {
    throw new Error("<TransformControls>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get translationSnap() {
    throw new Error("<TransformControls>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set translationSnap(value) {
    throw new Error("<TransformControls>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get scaleSnap() {
    throw new Error("<TransformControls>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set scaleSnap(value) {
    throw new Error("<TransformControls>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get rotationSnap() {
    throw new Error("<TransformControls>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set rotationSnap(value) {
    throw new Error("<TransformControls>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get showX() {
    throw new Error("<TransformControls>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set showX(value) {
    throw new Error("<TransformControls>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get showY() {
    throw new Error("<TransformControls>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set showY(value) {
    throw new Error("<TransformControls>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get showZ() {
    throw new Error("<TransformControls>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set showZ(value) {
    throw new Error("<TransformControls>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get size() {
    throw new Error("<TransformControls>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set size(value) {
    throw new Error("<TransformControls>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get space() {
    throw new Error("<TransformControls>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set space(value) {
    throw new Error("<TransformControls>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get reset() {
    return this.$$.ctx[16];
  }
  set reset(value) {
    throw new Error("<TransformControls>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var TransformControls_default = TransformControls_1;

// node_modules/threlte/effects/Pass.svelte
function create_fragment17(ctx) {
  const block = {
    c: noop,
    l: noop,
    m: noop,
    p: noop,
    i: noop,
    o: noop,
    d: noop
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment17.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance17($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Pass", slots, []);
  let { pass } = $$props;
  const { addPass, removePass } = useThrelteRoot();
  addPass(pass);
  useFrame(
    () => {
    },
    { debugFrameloopMessage: "Pass component" }
  );
  onDestroy(() => {
    removePass(pass);
  });
  $$self.$$.on_mount.push(function() {
    if (pass === void 0 && !("pass" in $$props || $$self.$$.bound[$$self.$$.props["pass"]])) {
      console.warn("<Pass> was created without expected prop 'pass'");
    }
  });
  const writable_props = ["pass"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<Pass> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("pass" in $$props2)
      $$invalidate(0, pass = $$props2.pass);
  };
  $$self.$capture_state = () => ({
    useFrame,
    onDestroy,
    useThrelteRoot,
    pass,
    addPass,
    removePass
  });
  $$self.$inject_state = ($$props2) => {
    if ("pass" in $$props2)
      $$invalidate(0, pass = $$props2.pass);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [pass];
}
var Pass2 = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance17, create_fragment17, safe_not_equal, { pass: 0 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Pass",
      options,
      id: create_fragment17.name
    });
  }
  get pass() {
    throw new Error("<Pass>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set pass(value) {
    throw new Error("<Pass>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Pass_default = Pass2;

// node_modules/threlte/lib/colors.js
var convertColorRepresentationToColor = (colorRep, linear) => {
  if (linear)
    return new Color(colorRep);
  return new Color().setHex(new Color(colorRep).getHex()).convertSRGBToLinear();
};

// node_modules/threlte/instances/LightInstance.svelte
function create_default_slot9(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[16].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[20],
    null
  );
  const block = {
    c: function create() {
      if (default_slot)
        default_slot.c();
    },
    l: function claim(nodes) {
      if (default_slot)
        default_slot.l(nodes);
    },
    m: function mount(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        1048576)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[20],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[20]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[20],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot9.name,
    type: "slot",
    source: "(30:0) <Object3DInstance   object={light}   {lookAt}   {castShadow}   {receiveShadow}   {frustumCulled}   {renderOrder}   {position}   {scale}   {rotation}   {viewportAware}   {visible}   on:viewportenter   on:viewportleave   bind:inViewport >",
    ctx
  });
  return block;
}
function create_fragment18(ctx) {
  let object3dinstance;
  let updating_inViewport;
  let current;
  function object3dinstance_inViewport_binding(value) {
    ctx[17](value);
  }
  let object3dinstance_props = {
    object: (
      /*light*/
      ctx[0]
    ),
    lookAt: (
      /*lookAt*/
      ctx[5]
    ),
    castShadow: (
      /*castShadow*/
      ctx[7]
    ),
    receiveShadow: (
      /*receiveShadow*/
      ctx[8]
    ),
    frustumCulled: (
      /*frustumCulled*/
      ctx[9]
    ),
    renderOrder: (
      /*renderOrder*/
      ctx[10]
    ),
    position: (
      /*position*/
      ctx[2]
    ),
    scale: (
      /*scale*/
      ctx[3]
    ),
    rotation: (
      /*rotation*/
      ctx[4]
    ),
    viewportAware: (
      /*viewportAware*/
      ctx[6]
    ),
    visible: (
      /*visible*/
      ctx[11]
    ),
    $$slots: { default: [create_default_slot9] },
    $$scope: { ctx }
  };
  if (
    /*inViewport*/
    ctx[1] !== void 0
  ) {
    object3dinstance_props.inViewport = /*inViewport*/
    ctx[1];
  }
  object3dinstance = new Object3DInstance_default({
    props: object3dinstance_props,
    $$inline: true
  });
  binding_callbacks.push(() => bind(object3dinstance, "inViewport", object3dinstance_inViewport_binding));
  object3dinstance.$on(
    "viewportenter",
    /*viewportenter_handler*/
    ctx[18]
  );
  object3dinstance.$on(
    "viewportleave",
    /*viewportleave_handler*/
    ctx[19]
  );
  const block = {
    c: function create() {
      create_component(object3dinstance.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(object3dinstance.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(object3dinstance, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const object3dinstance_changes = {};
      if (dirty & /*light*/
      1)
        object3dinstance_changes.object = /*light*/
        ctx2[0];
      if (dirty & /*lookAt*/
      32)
        object3dinstance_changes.lookAt = /*lookAt*/
        ctx2[5];
      if (dirty & /*castShadow*/
      128)
        object3dinstance_changes.castShadow = /*castShadow*/
        ctx2[7];
      if (dirty & /*receiveShadow*/
      256)
        object3dinstance_changes.receiveShadow = /*receiveShadow*/
        ctx2[8];
      if (dirty & /*frustumCulled*/
      512)
        object3dinstance_changes.frustumCulled = /*frustumCulled*/
        ctx2[9];
      if (dirty & /*renderOrder*/
      1024)
        object3dinstance_changes.renderOrder = /*renderOrder*/
        ctx2[10];
      if (dirty & /*position*/
      4)
        object3dinstance_changes.position = /*position*/
        ctx2[2];
      if (dirty & /*scale*/
      8)
        object3dinstance_changes.scale = /*scale*/
        ctx2[3];
      if (dirty & /*rotation*/
      16)
        object3dinstance_changes.rotation = /*rotation*/
        ctx2[4];
      if (dirty & /*viewportAware*/
      64)
        object3dinstance_changes.viewportAware = /*viewportAware*/
        ctx2[6];
      if (dirty & /*visible*/
      2048)
        object3dinstance_changes.visible = /*visible*/
        ctx2[11];
      if (dirty & /*$$scope*/
      1048576) {
        object3dinstance_changes.$$scope = { dirty, ctx: ctx2 };
      }
      if (!updating_inViewport && dirty & /*inViewport*/
      2) {
        updating_inViewport = true;
        object3dinstance_changes.inViewport = /*inViewport*/
        ctx2[1];
        add_flush_callback(() => updating_inViewport = false);
      }
      object3dinstance.$set(object3dinstance_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(object3dinstance.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(object3dinstance.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(object3dinstance, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment18.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance18($$self, $$props, $$invalidate) {
  let $linear;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("LightInstance", slots, ["default"]);
  let { light } = $$props;
  let { position = void 0 } = $$props;
  let { scale = void 0 } = $$props;
  let { rotation = void 0 } = $$props;
  let { lookAt = void 0 } = $$props;
  let { viewportAware = false } = $$props;
  let { inViewport = false } = $$props;
  let { castShadow = void 0 } = $$props;
  let { receiveShadow = void 0 } = $$props;
  let { frustumCulled = void 0 } = $$props;
  let { renderOrder = void 0 } = $$props;
  let { visible = void 0 } = $$props;
  let { color = void 0 } = $$props;
  let { intensity = void 0 } = $$props;
  const { invalidate } = useThrelte();
  const { linear } = useThrelteRoot();
  validate_store(linear, "linear");
  component_subscribe($$self, linear, (value) => $$invalidate(15, $linear = value));
  $$self.$$.on_mount.push(function() {
    if (light === void 0 && !("light" in $$props || $$self.$$.bound[$$self.$$.props["light"]])) {
      console.warn("<LightInstance> was created without expected prop 'light'");
    }
  });
  const writable_props = [
    "light",
    "position",
    "scale",
    "rotation",
    "lookAt",
    "viewportAware",
    "inViewport",
    "castShadow",
    "receiveShadow",
    "frustumCulled",
    "renderOrder",
    "visible",
    "color",
    "intensity"
  ];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<LightInstance> was created with unknown prop '${key}'`);
  });
  function object3dinstance_inViewport_binding(value) {
    inViewport = value;
    $$invalidate(1, inViewport);
  }
  function viewportenter_handler(event) {
    bubble.call(this, $$self, event);
  }
  function viewportleave_handler(event) {
    bubble.call(this, $$self, event);
  }
  $$self.$$set = ($$props2) => {
    if ("light" in $$props2)
      $$invalidate(0, light = $$props2.light);
    if ("position" in $$props2)
      $$invalidate(2, position = $$props2.position);
    if ("scale" in $$props2)
      $$invalidate(3, scale = $$props2.scale);
    if ("rotation" in $$props2)
      $$invalidate(4, rotation = $$props2.rotation);
    if ("lookAt" in $$props2)
      $$invalidate(5, lookAt = $$props2.lookAt);
    if ("viewportAware" in $$props2)
      $$invalidate(6, viewportAware = $$props2.viewportAware);
    if ("inViewport" in $$props2)
      $$invalidate(1, inViewport = $$props2.inViewport);
    if ("castShadow" in $$props2)
      $$invalidate(7, castShadow = $$props2.castShadow);
    if ("receiveShadow" in $$props2)
      $$invalidate(8, receiveShadow = $$props2.receiveShadow);
    if ("frustumCulled" in $$props2)
      $$invalidate(9, frustumCulled = $$props2.frustumCulled);
    if ("renderOrder" in $$props2)
      $$invalidate(10, renderOrder = $$props2.renderOrder);
    if ("visible" in $$props2)
      $$invalidate(11, visible = $$props2.visible);
    if ("color" in $$props2)
      $$invalidate(13, color = $$props2.color);
    if ("intensity" in $$props2)
      $$invalidate(14, intensity = $$props2.intensity);
    if ("$$scope" in $$props2)
      $$invalidate(20, $$scope = $$props2.$$scope);
  };
  $$self.$capture_state = () => ({
    useThrelte,
    useThrelteRoot,
    convertColorRepresentationToColor,
    Object3DInstance: Object3DInstance_default,
    light,
    position,
    scale,
    rotation,
    lookAt,
    viewportAware,
    inViewport,
    castShadow,
    receiveShadow,
    frustumCulled,
    renderOrder,
    visible,
    color,
    intensity,
    invalidate,
    linear,
    $linear
  });
  $$self.$inject_state = ($$props2) => {
    if ("light" in $$props2)
      $$invalidate(0, light = $$props2.light);
    if ("position" in $$props2)
      $$invalidate(2, position = $$props2.position);
    if ("scale" in $$props2)
      $$invalidate(3, scale = $$props2.scale);
    if ("rotation" in $$props2)
      $$invalidate(4, rotation = $$props2.rotation);
    if ("lookAt" in $$props2)
      $$invalidate(5, lookAt = $$props2.lookAt);
    if ("viewportAware" in $$props2)
      $$invalidate(6, viewportAware = $$props2.viewportAware);
    if ("inViewport" in $$props2)
      $$invalidate(1, inViewport = $$props2.inViewport);
    if ("castShadow" in $$props2)
      $$invalidate(7, castShadow = $$props2.castShadow);
    if ("receiveShadow" in $$props2)
      $$invalidate(8, receiveShadow = $$props2.receiveShadow);
    if ("frustumCulled" in $$props2)
      $$invalidate(9, frustumCulled = $$props2.frustumCulled);
    if ("renderOrder" in $$props2)
      $$invalidate(10, renderOrder = $$props2.renderOrder);
    if ("visible" in $$props2)
      $$invalidate(11, visible = $$props2.visible);
    if ("color" in $$props2)
      $$invalidate(13, color = $$props2.color);
    if ("intensity" in $$props2)
      $$invalidate(14, intensity = $$props2.intensity);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*intensity, color, $linear*/
    57344) {
      $: {
        if (intensity !== void 0)
          $$invalidate(0, light.intensity = intensity, light);
        if (color !== void 0)
          $$invalidate(0, light.color = convertColorRepresentationToColor(color, $linear), light);
        invalidate("LightInstance: props changed");
      }
    }
  };
  return [
    light,
    inViewport,
    position,
    scale,
    rotation,
    lookAt,
    viewportAware,
    castShadow,
    receiveShadow,
    frustumCulled,
    renderOrder,
    visible,
    linear,
    color,
    intensity,
    $linear,
    slots,
    object3dinstance_inViewport_binding,
    viewportenter_handler,
    viewportleave_handler,
    $$scope
  ];
}
var LightInstance = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance18, create_fragment18, safe_not_equal, {
      light: 0,
      position: 2,
      scale: 3,
      rotation: 4,
      lookAt: 5,
      viewportAware: 6,
      inViewport: 1,
      castShadow: 7,
      receiveShadow: 8,
      frustumCulled: 9,
      renderOrder: 10,
      visible: 11,
      color: 13,
      intensity: 14
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "LightInstance",
      options,
      id: create_fragment18.name
    });
  }
  get light() {
    throw new Error("<LightInstance>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set light(value) {
    throw new Error("<LightInstance>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get position() {
    throw new Error("<LightInstance>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set position(value) {
    throw new Error("<LightInstance>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get scale() {
    throw new Error("<LightInstance>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set scale(value) {
    throw new Error("<LightInstance>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get rotation() {
    throw new Error("<LightInstance>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set rotation(value) {
    throw new Error("<LightInstance>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get lookAt() {
    throw new Error("<LightInstance>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set lookAt(value) {
    throw new Error("<LightInstance>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get viewportAware() {
    throw new Error("<LightInstance>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set viewportAware(value) {
    throw new Error("<LightInstance>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get inViewport() {
    throw new Error("<LightInstance>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set inViewport(value) {
    throw new Error("<LightInstance>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get castShadow() {
    throw new Error("<LightInstance>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set castShadow(value) {
    throw new Error("<LightInstance>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get receiveShadow() {
    throw new Error("<LightInstance>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set receiveShadow(value) {
    throw new Error("<LightInstance>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get frustumCulled() {
    throw new Error("<LightInstance>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set frustumCulled(value) {
    throw new Error("<LightInstance>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get renderOrder() {
    throw new Error("<LightInstance>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set renderOrder(value) {
    throw new Error("<LightInstance>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get visible() {
    throw new Error("<LightInstance>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set visible(value) {
    throw new Error("<LightInstance>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get color() {
    throw new Error("<LightInstance>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set color(value) {
    throw new Error("<LightInstance>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get intensity() {
    throw new Error("<LightInstance>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set intensity(value) {
    throw new Error("<LightInstance>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var LightInstance_default = LightInstance;

// node_modules/threlte/lights/AmbientLight.svelte
function create_default_slot10(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[14].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[18],
    null
  );
  const block = {
    c: function create() {
      if (default_slot)
        default_slot.c();
    },
    l: function claim(nodes) {
      if (default_slot)
        default_slot.l(nodes);
    },
    m: function mount(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        262144)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[18],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[18]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[18],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot10.name,
    type: "slot",
    source: "(19:0) <LightInstance   {light}   {lookAt}   {position}   {scale}   {rotation}   {castShadow}   {receiveShadow}   {frustumCulled}   {renderOrder}   {visible}   {viewportAware}   bind:inViewport   on:viewportenter   on:viewportleave   {color}   {intensity} >",
    ctx
  });
  return block;
}
function create_fragment19(ctx) {
  let lightinstance;
  let updating_inViewport;
  let current;
  function lightinstance_inViewport_binding(value) {
    ctx[15](value);
  }
  let lightinstance_props = {
    light: (
      /*light*/
      ctx[13]
    ),
    lookAt: (
      /*lookAt*/
      ctx[4]
    ),
    position: (
      /*position*/
      ctx[1]
    ),
    scale: (
      /*scale*/
      ctx[2]
    ),
    rotation: (
      /*rotation*/
      ctx[3]
    ),
    castShadow: (
      /*castShadow*/
      ctx[5]
    ),
    receiveShadow: (
      /*receiveShadow*/
      ctx[6]
    ),
    frustumCulled: (
      /*frustumCulled*/
      ctx[7]
    ),
    renderOrder: (
      /*renderOrder*/
      ctx[8]
    ),
    visible: (
      /*visible*/
      ctx[9]
    ),
    viewportAware: (
      /*viewportAware*/
      ctx[10]
    ),
    color: (
      /*color*/
      ctx[11]
    ),
    intensity: (
      /*intensity*/
      ctx[12]
    ),
    $$slots: { default: [create_default_slot10] },
    $$scope: { ctx }
  };
  if (
    /*inViewport*/
    ctx[0] !== void 0
  ) {
    lightinstance_props.inViewport = /*inViewport*/
    ctx[0];
  }
  lightinstance = new LightInstance_default({
    props: lightinstance_props,
    $$inline: true
  });
  binding_callbacks.push(() => bind(lightinstance, "inViewport", lightinstance_inViewport_binding));
  lightinstance.$on(
    "viewportenter",
    /*viewportenter_handler*/
    ctx[16]
  );
  lightinstance.$on(
    "viewportleave",
    /*viewportleave_handler*/
    ctx[17]
  );
  const block = {
    c: function create() {
      create_component(lightinstance.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(lightinstance.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(lightinstance, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const lightinstance_changes = {};
      if (dirty & /*lookAt*/
      16)
        lightinstance_changes.lookAt = /*lookAt*/
        ctx2[4];
      if (dirty & /*position*/
      2)
        lightinstance_changes.position = /*position*/
        ctx2[1];
      if (dirty & /*scale*/
      4)
        lightinstance_changes.scale = /*scale*/
        ctx2[2];
      if (dirty & /*rotation*/
      8)
        lightinstance_changes.rotation = /*rotation*/
        ctx2[3];
      if (dirty & /*castShadow*/
      32)
        lightinstance_changes.castShadow = /*castShadow*/
        ctx2[5];
      if (dirty & /*receiveShadow*/
      64)
        lightinstance_changes.receiveShadow = /*receiveShadow*/
        ctx2[6];
      if (dirty & /*frustumCulled*/
      128)
        lightinstance_changes.frustumCulled = /*frustumCulled*/
        ctx2[7];
      if (dirty & /*renderOrder*/
      256)
        lightinstance_changes.renderOrder = /*renderOrder*/
        ctx2[8];
      if (dirty & /*visible*/
      512)
        lightinstance_changes.visible = /*visible*/
        ctx2[9];
      if (dirty & /*viewportAware*/
      1024)
        lightinstance_changes.viewportAware = /*viewportAware*/
        ctx2[10];
      if (dirty & /*color*/
      2048)
        lightinstance_changes.color = /*color*/
        ctx2[11];
      if (dirty & /*intensity*/
      4096)
        lightinstance_changes.intensity = /*intensity*/
        ctx2[12];
      if (dirty & /*$$scope*/
      262144) {
        lightinstance_changes.$$scope = { dirty, ctx: ctx2 };
      }
      if (!updating_inViewport && dirty & /*inViewport*/
      1) {
        updating_inViewport = true;
        lightinstance_changes.inViewport = /*inViewport*/
        ctx2[0];
        add_flush_callback(() => updating_inViewport = false);
      }
      lightinstance.$set(lightinstance_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(lightinstance.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(lightinstance.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(lightinstance, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment19.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance19($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("AmbientLight", slots, ["default"]);
  let { position = void 0 } = $$props;
  let { scale = void 0 } = $$props;
  let { rotation = void 0 } = $$props;
  let { lookAt = void 0 } = $$props;
  let { castShadow = void 0 } = $$props;
  let { receiveShadow = void 0 } = $$props;
  let { frustumCulled = void 0 } = $$props;
  let { renderOrder = void 0 } = $$props;
  let { visible = void 0 } = $$props;
  let { viewportAware = false } = $$props;
  let { inViewport = false } = $$props;
  let { color = void 0 } = $$props;
  let { intensity = void 0 } = $$props;
  const light = new AmbientLight(color, intensity);
  const writable_props = [
    "position",
    "scale",
    "rotation",
    "lookAt",
    "castShadow",
    "receiveShadow",
    "frustumCulled",
    "renderOrder",
    "visible",
    "viewportAware",
    "inViewport",
    "color",
    "intensity"
  ];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<AmbientLight> was created with unknown prop '${key}'`);
  });
  function lightinstance_inViewport_binding(value) {
    inViewport = value;
    $$invalidate(0, inViewport);
  }
  function viewportenter_handler(event) {
    bubble.call(this, $$self, event);
  }
  function viewportleave_handler(event) {
    bubble.call(this, $$self, event);
  }
  $$self.$$set = ($$props2) => {
    if ("position" in $$props2)
      $$invalidate(1, position = $$props2.position);
    if ("scale" in $$props2)
      $$invalidate(2, scale = $$props2.scale);
    if ("rotation" in $$props2)
      $$invalidate(3, rotation = $$props2.rotation);
    if ("lookAt" in $$props2)
      $$invalidate(4, lookAt = $$props2.lookAt);
    if ("castShadow" in $$props2)
      $$invalidate(5, castShadow = $$props2.castShadow);
    if ("receiveShadow" in $$props2)
      $$invalidate(6, receiveShadow = $$props2.receiveShadow);
    if ("frustumCulled" in $$props2)
      $$invalidate(7, frustumCulled = $$props2.frustumCulled);
    if ("renderOrder" in $$props2)
      $$invalidate(8, renderOrder = $$props2.renderOrder);
    if ("visible" in $$props2)
      $$invalidate(9, visible = $$props2.visible);
    if ("viewportAware" in $$props2)
      $$invalidate(10, viewportAware = $$props2.viewportAware);
    if ("inViewport" in $$props2)
      $$invalidate(0, inViewport = $$props2.inViewport);
    if ("color" in $$props2)
      $$invalidate(11, color = $$props2.color);
    if ("intensity" in $$props2)
      $$invalidate(12, intensity = $$props2.intensity);
    if ("$$scope" in $$props2)
      $$invalidate(18, $$scope = $$props2.$$scope);
  };
  $$self.$capture_state = () => ({
    ThreeAmbientLight: AmbientLight,
    LightInstance: LightInstance_default,
    position,
    scale,
    rotation,
    lookAt,
    castShadow,
    receiveShadow,
    frustumCulled,
    renderOrder,
    visible,
    viewportAware,
    inViewport,
    color,
    intensity,
    light
  });
  $$self.$inject_state = ($$props2) => {
    if ("position" in $$props2)
      $$invalidate(1, position = $$props2.position);
    if ("scale" in $$props2)
      $$invalidate(2, scale = $$props2.scale);
    if ("rotation" in $$props2)
      $$invalidate(3, rotation = $$props2.rotation);
    if ("lookAt" in $$props2)
      $$invalidate(4, lookAt = $$props2.lookAt);
    if ("castShadow" in $$props2)
      $$invalidate(5, castShadow = $$props2.castShadow);
    if ("receiveShadow" in $$props2)
      $$invalidate(6, receiveShadow = $$props2.receiveShadow);
    if ("frustumCulled" in $$props2)
      $$invalidate(7, frustumCulled = $$props2.frustumCulled);
    if ("renderOrder" in $$props2)
      $$invalidate(8, renderOrder = $$props2.renderOrder);
    if ("visible" in $$props2)
      $$invalidate(9, visible = $$props2.visible);
    if ("viewportAware" in $$props2)
      $$invalidate(10, viewportAware = $$props2.viewportAware);
    if ("inViewport" in $$props2)
      $$invalidate(0, inViewport = $$props2.inViewport);
    if ("color" in $$props2)
      $$invalidate(11, color = $$props2.color);
    if ("intensity" in $$props2)
      $$invalidate(12, intensity = $$props2.intensity);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [
    inViewport,
    position,
    scale,
    rotation,
    lookAt,
    castShadow,
    receiveShadow,
    frustumCulled,
    renderOrder,
    visible,
    viewportAware,
    color,
    intensity,
    light,
    slots,
    lightinstance_inViewport_binding,
    viewportenter_handler,
    viewportleave_handler,
    $$scope
  ];
}
var AmbientLight2 = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance19, create_fragment19, safe_not_equal, {
      position: 1,
      scale: 2,
      rotation: 3,
      lookAt: 4,
      castShadow: 5,
      receiveShadow: 6,
      frustumCulled: 7,
      renderOrder: 8,
      visible: 9,
      viewportAware: 10,
      inViewport: 0,
      color: 11,
      intensity: 12,
      light: 13
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "AmbientLight",
      options,
      id: create_fragment19.name
    });
  }
  get position() {
    throw new Error("<AmbientLight>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set position(value) {
    throw new Error("<AmbientLight>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get scale() {
    throw new Error("<AmbientLight>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set scale(value) {
    throw new Error("<AmbientLight>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get rotation() {
    throw new Error("<AmbientLight>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set rotation(value) {
    throw new Error("<AmbientLight>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get lookAt() {
    throw new Error("<AmbientLight>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set lookAt(value) {
    throw new Error("<AmbientLight>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get castShadow() {
    throw new Error("<AmbientLight>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set castShadow(value) {
    throw new Error("<AmbientLight>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get receiveShadow() {
    throw new Error("<AmbientLight>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set receiveShadow(value) {
    throw new Error("<AmbientLight>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get frustumCulled() {
    throw new Error("<AmbientLight>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set frustumCulled(value) {
    throw new Error("<AmbientLight>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get renderOrder() {
    throw new Error("<AmbientLight>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set renderOrder(value) {
    throw new Error("<AmbientLight>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get visible() {
    throw new Error("<AmbientLight>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set visible(value) {
    throw new Error("<AmbientLight>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get viewportAware() {
    throw new Error("<AmbientLight>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set viewportAware(value) {
    throw new Error("<AmbientLight>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get inViewport() {
    throw new Error("<AmbientLight>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set inViewport(value) {
    throw new Error("<AmbientLight>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get color() {
    throw new Error("<AmbientLight>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set color(value) {
    throw new Error("<AmbientLight>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get intensity() {
    throw new Error("<AmbientLight>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set intensity(value) {
    throw new Error("<AmbientLight>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get light() {
    return this.$$.ctx[13];
  }
  set light(value) {
    throw new Error("<AmbientLight>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var AmbientLight_default = AmbientLight2;

// node_modules/threlte/lights/DirectionalLight.svelte
function create_if_block3(ctx) {
  let hierarchicalobject;
  let t2;
  let transformableobject;
  let current;
  hierarchicalobject = new HierarchicalObject_default({
    props: { object: (
      /*originalTarget*/
      ctx[14]
    ) },
    $$inline: true
  });
  transformableobject = new TransformableObject_default({
    props: {
      object: (
        /*originalTarget*/
        ctx[14]
      ),
      position: (
        /*target*/
        ctx[13]
      )
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(hierarchicalobject.$$.fragment);
      t2 = space();
      create_component(transformableobject.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(hierarchicalobject.$$.fragment, nodes);
      t2 = claim_space(nodes);
      claim_component(transformableobject.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(hierarchicalobject, target, anchor);
      insert_hydration_dev(target, t2, anchor);
      mount_component(transformableobject, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const transformableobject_changes = {};
      if (dirty & /*target*/
      8192)
        transformableobject_changes.position = /*target*/
        ctx2[13];
      transformableobject.$set(transformableobject_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(hierarchicalobject.$$.fragment, local);
      transition_in(transformableobject.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(hierarchicalobject.$$.fragment, local);
      transition_out(transformableobject.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(hierarchicalobject, detaching);
      if (detaching)
        detach_dev(t2);
      destroy_component(transformableobject, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block3.name,
    type: "if",
    source: "(58:0) {#if target && !(target instanceof Object3D)}",
    ctx
  });
  return block;
}
function create_default_slot11(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[16].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[20],
    null
  );
  const block = {
    c: function create() {
      if (default_slot)
        default_slot.c();
    },
    l: function claim(nodes) {
      if (default_slot)
        default_slot.l(nodes);
    },
    m: function mount(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        1048576)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[20],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[20]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[20],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot11.name,
    type: "slot",
    source: "(63:0) <LightInstance   {light}   {position}   {scale}   {rotation}   castShadow={shadow ? true : false}   {receiveShadow}   {frustumCulled}   {renderOrder}   {visible}   {viewportAware}   bind:inViewport   on:viewportenter   on:viewportleave   {color}   {intensity} >",
    ctx
  });
  return block;
}
function create_fragment20(ctx) {
  let t2;
  let lightinstance;
  let updating_inViewport;
  let current;
  let if_block = (
    /*target*/
    ctx[13] && !/*target*/
    (ctx[13] instanceof Object3D) && create_if_block3(ctx)
  );
  function lightinstance_inViewport_binding(value) {
    ctx[17](value);
  }
  let lightinstance_props = {
    light: (
      /*light*/
      ctx[1]
    ),
    position: (
      /*position*/
      ctx[2]
    ),
    scale: (
      /*scale*/
      ctx[3]
    ),
    rotation: (
      /*rotation*/
      ctx[4]
    ),
    castShadow: (
      /*shadow*/
      ctx[12] ? true : false
    ),
    receiveShadow: (
      /*receiveShadow*/
      ctx[5]
    ),
    frustumCulled: (
      /*frustumCulled*/
      ctx[6]
    ),
    renderOrder: (
      /*renderOrder*/
      ctx[7]
    ),
    visible: (
      /*visible*/
      ctx[8]
    ),
    viewportAware: (
      /*viewportAware*/
      ctx[9]
    ),
    color: (
      /*color*/
      ctx[10]
    ),
    intensity: (
      /*intensity*/
      ctx[11]
    ),
    $$slots: { default: [create_default_slot11] },
    $$scope: { ctx }
  };
  if (
    /*inViewport*/
    ctx[0] !== void 0
  ) {
    lightinstance_props.inViewport = /*inViewport*/
    ctx[0];
  }
  lightinstance = new LightInstance_default({
    props: lightinstance_props,
    $$inline: true
  });
  binding_callbacks.push(() => bind(lightinstance, "inViewport", lightinstance_inViewport_binding));
  lightinstance.$on(
    "viewportenter",
    /*viewportenter_handler*/
    ctx[18]
  );
  lightinstance.$on(
    "viewportleave",
    /*viewportleave_handler*/
    ctx[19]
  );
  const block = {
    c: function create() {
      if (if_block)
        if_block.c();
      t2 = space();
      create_component(lightinstance.$$.fragment);
    },
    l: function claim(nodes) {
      if (if_block)
        if_block.l(nodes);
      t2 = claim_space(nodes);
      claim_component(lightinstance.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      if (if_block)
        if_block.m(target, anchor);
      insert_hydration_dev(target, t2, anchor);
      mount_component(lightinstance, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      if (
        /*target*/
        ctx2[13] && !/*target*/
        (ctx2[13] instanceof Object3D)
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & /*target*/
          8192) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block3(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(t2.parentNode, t2);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
      const lightinstance_changes = {};
      if (dirty & /*light*/
      2)
        lightinstance_changes.light = /*light*/
        ctx2[1];
      if (dirty & /*position*/
      4)
        lightinstance_changes.position = /*position*/
        ctx2[2];
      if (dirty & /*scale*/
      8)
        lightinstance_changes.scale = /*scale*/
        ctx2[3];
      if (dirty & /*rotation*/
      16)
        lightinstance_changes.rotation = /*rotation*/
        ctx2[4];
      if (dirty & /*shadow*/
      4096)
        lightinstance_changes.castShadow = /*shadow*/
        ctx2[12] ? true : false;
      if (dirty & /*receiveShadow*/
      32)
        lightinstance_changes.receiveShadow = /*receiveShadow*/
        ctx2[5];
      if (dirty & /*frustumCulled*/
      64)
        lightinstance_changes.frustumCulled = /*frustumCulled*/
        ctx2[6];
      if (dirty & /*renderOrder*/
      128)
        lightinstance_changes.renderOrder = /*renderOrder*/
        ctx2[7];
      if (dirty & /*visible*/
      256)
        lightinstance_changes.visible = /*visible*/
        ctx2[8];
      if (dirty & /*viewportAware*/
      512)
        lightinstance_changes.viewportAware = /*viewportAware*/
        ctx2[9];
      if (dirty & /*color*/
      1024)
        lightinstance_changes.color = /*color*/
        ctx2[10];
      if (dirty & /*intensity*/
      2048)
        lightinstance_changes.intensity = /*intensity*/
        ctx2[11];
      if (dirty & /*$$scope*/
      1048576) {
        lightinstance_changes.$$scope = { dirty, ctx: ctx2 };
      }
      if (!updating_inViewport && dirty & /*inViewport*/
      1) {
        updating_inViewport = true;
        lightinstance_changes.inViewport = /*inViewport*/
        ctx2[0];
        add_flush_callback(() => updating_inViewport = false);
      }
      lightinstance.$set(lightinstance_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block);
      transition_in(lightinstance.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      transition_out(lightinstance.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (if_block)
        if_block.d(detaching);
      if (detaching)
        detach_dev(t2);
      destroy_component(lightinstance, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment20.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance20($$self, $$props, $$invalidate) {
  let $started;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("DirectionalLight", slots, ["default"]);
  let { position = void 0 } = $$props;
  let { scale = void 0 } = $$props;
  let { rotation = void 0 } = $$props;
  let { receiveShadow = void 0 } = $$props;
  let { frustumCulled = void 0 } = $$props;
  let { renderOrder = void 0 } = $$props;
  let { visible = void 0 } = $$props;
  let { viewportAware = false } = $$props;
  let { inViewport = false } = $$props;
  let { color = void 0 } = $$props;
  let { intensity = void 0 } = $$props;
  let { shadow = void 0 } = $$props;
  let { target = void 0 } = $$props;
  const light = new DirectionalLight(color, intensity);
  const { invalidate } = useThrelte();
  const originalTarget = light.target;
  const { start, stop, started } = useFrame(
    () => {
    },
    {
      autostart: false,
      debugFrameloopMessage: "DirectionalLight: tracking target"
    }
  );
  validate_store(started, "started");
  component_subscribe($$self, started, (value) => $$invalidate(21, $started = value));
  const updateLightTarget = (target2) => {
    if (target2 && target2 instanceof Object3D && !$started) {
      $$invalidate(1, light.target = target2, light);
      start();
      invalidate("DirectionalLight: target changed");
    } else if ((!target2 || !(target2 instanceof Object3D)) && $started) {
      $$invalidate(1, light.target = originalTarget, light);
      stop();
      invalidate("DirectionalLight: target changed");
    }
  };
  const updateLightShadow = (shadow2) => {
    if (shadow2) {
      const { mapSize = [512, 512], camera: { left = -5, bottom = -5, right = 5, top = 5, near = 0.5, far = 500 } = {}, bias = 0, radius = 1 } = shadow2 === true ? {} : shadow2;
      light.shadow.mapSize.set(mapSize[0], mapSize[1]);
      $$invalidate(1, light.shadow.camera.left = left, light);
      $$invalidate(1, light.shadow.camera.top = top, light);
      $$invalidate(1, light.shadow.camera.right = right, light);
      $$invalidate(1, light.shadow.camera.bottom = bottom, light);
      $$invalidate(1, light.shadow.camera.near = near, light);
      $$invalidate(1, light.shadow.camera.far = far, light);
      $$invalidate(1, light.shadow.bias = bias, light);
      $$invalidate(1, light.shadow.radius = radius, light);
    }
    invalidate("DirectionalLight: shadow changed");
  };
  const writable_props = [
    "position",
    "scale",
    "rotation",
    "receiveShadow",
    "frustumCulled",
    "renderOrder",
    "visible",
    "viewportAware",
    "inViewport",
    "color",
    "intensity",
    "shadow",
    "target"
  ];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<DirectionalLight> was created with unknown prop '${key}'`);
  });
  function lightinstance_inViewport_binding(value) {
    inViewport = value;
    $$invalidate(0, inViewport);
  }
  function viewportenter_handler(event) {
    bubble.call(this, $$self, event);
  }
  function viewportleave_handler(event) {
    bubble.call(this, $$self, event);
  }
  $$self.$$set = ($$props2) => {
    if ("position" in $$props2)
      $$invalidate(2, position = $$props2.position);
    if ("scale" in $$props2)
      $$invalidate(3, scale = $$props2.scale);
    if ("rotation" in $$props2)
      $$invalidate(4, rotation = $$props2.rotation);
    if ("receiveShadow" in $$props2)
      $$invalidate(5, receiveShadow = $$props2.receiveShadow);
    if ("frustumCulled" in $$props2)
      $$invalidate(6, frustumCulled = $$props2.frustumCulled);
    if ("renderOrder" in $$props2)
      $$invalidate(7, renderOrder = $$props2.renderOrder);
    if ("visible" in $$props2)
      $$invalidate(8, visible = $$props2.visible);
    if ("viewportAware" in $$props2)
      $$invalidate(9, viewportAware = $$props2.viewportAware);
    if ("inViewport" in $$props2)
      $$invalidate(0, inViewport = $$props2.inViewport);
    if ("color" in $$props2)
      $$invalidate(10, color = $$props2.color);
    if ("intensity" in $$props2)
      $$invalidate(11, intensity = $$props2.intensity);
    if ("shadow" in $$props2)
      $$invalidate(12, shadow = $$props2.shadow);
    if ("target" in $$props2)
      $$invalidate(13, target = $$props2.target);
    if ("$$scope" in $$props2)
      $$invalidate(20, $$scope = $$props2.$$scope);
  };
  $$self.$capture_state = () => ({
    useFrame,
    ThreeDirectionalLight: DirectionalLight,
    Object3D,
    useThrelte,
    LightInstance: LightInstance_default,
    HierarchicalObject: HierarchicalObject_default,
    TransformableObject: TransformableObject_default,
    position,
    scale,
    rotation,
    receiveShadow,
    frustumCulled,
    renderOrder,
    visible,
    viewportAware,
    inViewport,
    color,
    intensity,
    shadow,
    target,
    light,
    invalidate,
    originalTarget,
    start,
    stop,
    started,
    updateLightTarget,
    updateLightShadow,
    $started
  });
  $$self.$inject_state = ($$props2) => {
    if ("position" in $$props2)
      $$invalidate(2, position = $$props2.position);
    if ("scale" in $$props2)
      $$invalidate(3, scale = $$props2.scale);
    if ("rotation" in $$props2)
      $$invalidate(4, rotation = $$props2.rotation);
    if ("receiveShadow" in $$props2)
      $$invalidate(5, receiveShadow = $$props2.receiveShadow);
    if ("frustumCulled" in $$props2)
      $$invalidate(6, frustumCulled = $$props2.frustumCulled);
    if ("renderOrder" in $$props2)
      $$invalidate(7, renderOrder = $$props2.renderOrder);
    if ("visible" in $$props2)
      $$invalidate(8, visible = $$props2.visible);
    if ("viewportAware" in $$props2)
      $$invalidate(9, viewportAware = $$props2.viewportAware);
    if ("inViewport" in $$props2)
      $$invalidate(0, inViewport = $$props2.inViewport);
    if ("color" in $$props2)
      $$invalidate(10, color = $$props2.color);
    if ("intensity" in $$props2)
      $$invalidate(11, intensity = $$props2.intensity);
    if ("shadow" in $$props2)
      $$invalidate(12, shadow = $$props2.shadow);
    if ("target" in $$props2)
      $$invalidate(13, target = $$props2.target);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*target*/
    8192) {
      $:
        updateLightTarget(target);
    }
    if ($$self.$$.dirty & /*shadow*/
    4096) {
      $:
        updateLightShadow(shadow);
    }
  };
  return [
    inViewport,
    light,
    position,
    scale,
    rotation,
    receiveShadow,
    frustumCulled,
    renderOrder,
    visible,
    viewportAware,
    color,
    intensity,
    shadow,
    target,
    originalTarget,
    started,
    slots,
    lightinstance_inViewport_binding,
    viewportenter_handler,
    viewportleave_handler,
    $$scope
  ];
}
var DirectionalLight2 = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance20, create_fragment20, safe_not_equal, {
      position: 2,
      scale: 3,
      rotation: 4,
      receiveShadow: 5,
      frustumCulled: 6,
      renderOrder: 7,
      visible: 8,
      viewportAware: 9,
      inViewport: 0,
      color: 10,
      intensity: 11,
      shadow: 12,
      target: 13,
      light: 1
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "DirectionalLight",
      options,
      id: create_fragment20.name
    });
  }
  get position() {
    throw new Error("<DirectionalLight>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set position(value) {
    throw new Error("<DirectionalLight>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get scale() {
    throw new Error("<DirectionalLight>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set scale(value) {
    throw new Error("<DirectionalLight>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get rotation() {
    throw new Error("<DirectionalLight>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set rotation(value) {
    throw new Error("<DirectionalLight>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get receiveShadow() {
    throw new Error("<DirectionalLight>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set receiveShadow(value) {
    throw new Error("<DirectionalLight>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get frustumCulled() {
    throw new Error("<DirectionalLight>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set frustumCulled(value) {
    throw new Error("<DirectionalLight>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get renderOrder() {
    throw new Error("<DirectionalLight>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set renderOrder(value) {
    throw new Error("<DirectionalLight>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get visible() {
    throw new Error("<DirectionalLight>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set visible(value) {
    throw new Error("<DirectionalLight>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get viewportAware() {
    throw new Error("<DirectionalLight>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set viewportAware(value) {
    throw new Error("<DirectionalLight>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get inViewport() {
    throw new Error("<DirectionalLight>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set inViewport(value) {
    throw new Error("<DirectionalLight>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get color() {
    throw new Error("<DirectionalLight>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set color(value) {
    throw new Error("<DirectionalLight>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get intensity() {
    throw new Error("<DirectionalLight>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set intensity(value) {
    throw new Error("<DirectionalLight>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get shadow() {
    throw new Error("<DirectionalLight>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set shadow(value) {
    throw new Error("<DirectionalLight>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get target() {
    throw new Error("<DirectionalLight>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set target(value) {
    throw new Error("<DirectionalLight>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get light() {
    return this.$$.ctx[1];
  }
  set light(value) {
    throw new Error("<DirectionalLight>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var DirectionalLight_default = DirectionalLight2;

// node_modules/threlte/lights/PointLight.svelte
function create_default_slot12(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[17].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[21],
    null
  );
  const block = {
    c: function create() {
      if (default_slot)
        default_slot.c();
    },
    l: function claim(nodes) {
      if (default_slot)
        default_slot.l(nodes);
    },
    m: function mount(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        2097152)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[21],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[21]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[21],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot12.name,
    type: "slot",
    source: "(44:0) <LightInstance   {light}   {lookAt}   {position}   {scale}   {rotation}   castShadow={shadow ? true : false}   {receiveShadow}   {frustumCulled}   {renderOrder}   {visible}   {viewportAware}   bind:inViewport   on:viewportenter   on:viewportleave   {color}   {intensity} >",
    ctx
  });
  return block;
}
function create_fragment21(ctx) {
  let lightinstance;
  let updating_inViewport;
  let current;
  function lightinstance_inViewport_binding(value) {
    ctx[18](value);
  }
  let lightinstance_props = {
    light: (
      /*light*/
      ctx[0]
    ),
    lookAt: (
      /*lookAt*/
      ctx[5]
    ),
    position: (
      /*position*/
      ctx[2]
    ),
    scale: (
      /*scale*/
      ctx[3]
    ),
    rotation: (
      /*rotation*/
      ctx[4]
    ),
    castShadow: (
      /*shadow*/
      ctx[13] ? true : false
    ),
    receiveShadow: (
      /*receiveShadow*/
      ctx[6]
    ),
    frustumCulled: (
      /*frustumCulled*/
      ctx[8]
    ),
    renderOrder: (
      /*renderOrder*/
      ctx[9]
    ),
    visible: (
      /*visible*/
      ctx[10]
    ),
    viewportAware: (
      /*viewportAware*/
      ctx[7]
    ),
    color: (
      /*color*/
      ctx[12]
    ),
    intensity: (
      /*intensity*/
      ctx[11]
    ),
    $$slots: { default: [create_default_slot12] },
    $$scope: { ctx }
  };
  if (
    /*inViewport*/
    ctx[1] !== void 0
  ) {
    lightinstance_props.inViewport = /*inViewport*/
    ctx[1];
  }
  lightinstance = new LightInstance_default({
    props: lightinstance_props,
    $$inline: true
  });
  binding_callbacks.push(() => bind(lightinstance, "inViewport", lightinstance_inViewport_binding));
  lightinstance.$on(
    "viewportenter",
    /*viewportenter_handler*/
    ctx[19]
  );
  lightinstance.$on(
    "viewportleave",
    /*viewportleave_handler*/
    ctx[20]
  );
  const block = {
    c: function create() {
      create_component(lightinstance.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(lightinstance.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(lightinstance, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const lightinstance_changes = {};
      if (dirty & /*light*/
      1)
        lightinstance_changes.light = /*light*/
        ctx2[0];
      if (dirty & /*lookAt*/
      32)
        lightinstance_changes.lookAt = /*lookAt*/
        ctx2[5];
      if (dirty & /*position*/
      4)
        lightinstance_changes.position = /*position*/
        ctx2[2];
      if (dirty & /*scale*/
      8)
        lightinstance_changes.scale = /*scale*/
        ctx2[3];
      if (dirty & /*rotation*/
      16)
        lightinstance_changes.rotation = /*rotation*/
        ctx2[4];
      if (dirty & /*shadow*/
      8192)
        lightinstance_changes.castShadow = /*shadow*/
        ctx2[13] ? true : false;
      if (dirty & /*receiveShadow*/
      64)
        lightinstance_changes.receiveShadow = /*receiveShadow*/
        ctx2[6];
      if (dirty & /*frustumCulled*/
      256)
        lightinstance_changes.frustumCulled = /*frustumCulled*/
        ctx2[8];
      if (dirty & /*renderOrder*/
      512)
        lightinstance_changes.renderOrder = /*renderOrder*/
        ctx2[9];
      if (dirty & /*visible*/
      1024)
        lightinstance_changes.visible = /*visible*/
        ctx2[10];
      if (dirty & /*viewportAware*/
      128)
        lightinstance_changes.viewportAware = /*viewportAware*/
        ctx2[7];
      if (dirty & /*color*/
      4096)
        lightinstance_changes.color = /*color*/
        ctx2[12];
      if (dirty & /*intensity*/
      2048)
        lightinstance_changes.intensity = /*intensity*/
        ctx2[11];
      if (dirty & /*$$scope*/
      2097152) {
        lightinstance_changes.$$scope = { dirty, ctx: ctx2 };
      }
      if (!updating_inViewport && dirty & /*inViewport*/
      2) {
        updating_inViewport = true;
        lightinstance_changes.inViewport = /*inViewport*/
        ctx2[1];
        add_flush_callback(() => updating_inViewport = false);
      }
      lightinstance.$set(lightinstance_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(lightinstance.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(lightinstance.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(lightinstance, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment21.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance21($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("PointLight", slots, ["default"]);
  let { position = void 0 } = $$props;
  let { scale = void 0 } = $$props;
  let { rotation = void 0 } = $$props;
  let { lookAt = void 0 } = $$props;
  let { receiveShadow = void 0 } = $$props;
  let { viewportAware = false } = $$props;
  let { inViewport = false } = $$props;
  let { frustumCulled = void 0 } = $$props;
  let { renderOrder = void 0 } = $$props;
  let { visible = void 0 } = $$props;
  let { intensity = void 0 } = $$props;
  let { color = void 0 } = $$props;
  let { distance = void 0 } = $$props;
  let { decay = void 0 } = $$props;
  let { power = void 0 } = $$props;
  let { shadow = void 0 } = $$props;
  const light = new PointLight(color, intensity, distance, decay);
  const { invalidate } = useThrelte();
  const writable_props = [
    "position",
    "scale",
    "rotation",
    "lookAt",
    "receiveShadow",
    "viewportAware",
    "inViewport",
    "frustumCulled",
    "renderOrder",
    "visible",
    "intensity",
    "color",
    "distance",
    "decay",
    "power",
    "shadow"
  ];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<PointLight> was created with unknown prop '${key}'`);
  });
  function lightinstance_inViewport_binding(value) {
    inViewport = value;
    $$invalidate(1, inViewport);
  }
  function viewportenter_handler(event) {
    bubble.call(this, $$self, event);
  }
  function viewportleave_handler(event) {
    bubble.call(this, $$self, event);
  }
  $$self.$$set = ($$props2) => {
    if ("position" in $$props2)
      $$invalidate(2, position = $$props2.position);
    if ("scale" in $$props2)
      $$invalidate(3, scale = $$props2.scale);
    if ("rotation" in $$props2)
      $$invalidate(4, rotation = $$props2.rotation);
    if ("lookAt" in $$props2)
      $$invalidate(5, lookAt = $$props2.lookAt);
    if ("receiveShadow" in $$props2)
      $$invalidate(6, receiveShadow = $$props2.receiveShadow);
    if ("viewportAware" in $$props2)
      $$invalidate(7, viewportAware = $$props2.viewportAware);
    if ("inViewport" in $$props2)
      $$invalidate(1, inViewport = $$props2.inViewport);
    if ("frustumCulled" in $$props2)
      $$invalidate(8, frustumCulled = $$props2.frustumCulled);
    if ("renderOrder" in $$props2)
      $$invalidate(9, renderOrder = $$props2.renderOrder);
    if ("visible" in $$props2)
      $$invalidate(10, visible = $$props2.visible);
    if ("intensity" in $$props2)
      $$invalidate(11, intensity = $$props2.intensity);
    if ("color" in $$props2)
      $$invalidate(12, color = $$props2.color);
    if ("distance" in $$props2)
      $$invalidate(14, distance = $$props2.distance);
    if ("decay" in $$props2)
      $$invalidate(15, decay = $$props2.decay);
    if ("power" in $$props2)
      $$invalidate(16, power = $$props2.power);
    if ("shadow" in $$props2)
      $$invalidate(13, shadow = $$props2.shadow);
    if ("$$scope" in $$props2)
      $$invalidate(21, $$scope = $$props2.$$scope);
  };
  $$self.$capture_state = () => ({
    ThreePointLight: PointLight,
    useThrelte,
    LightInstance: LightInstance_default,
    position,
    scale,
    rotation,
    lookAt,
    receiveShadow,
    viewportAware,
    inViewport,
    frustumCulled,
    renderOrder,
    visible,
    intensity,
    color,
    distance,
    decay,
    power,
    shadow,
    light,
    invalidate
  });
  $$self.$inject_state = ($$props2) => {
    if ("position" in $$props2)
      $$invalidate(2, position = $$props2.position);
    if ("scale" in $$props2)
      $$invalidate(3, scale = $$props2.scale);
    if ("rotation" in $$props2)
      $$invalidate(4, rotation = $$props2.rotation);
    if ("lookAt" in $$props2)
      $$invalidate(5, lookAt = $$props2.lookAt);
    if ("receiveShadow" in $$props2)
      $$invalidate(6, receiveShadow = $$props2.receiveShadow);
    if ("viewportAware" in $$props2)
      $$invalidate(7, viewportAware = $$props2.viewportAware);
    if ("inViewport" in $$props2)
      $$invalidate(1, inViewport = $$props2.inViewport);
    if ("frustumCulled" in $$props2)
      $$invalidate(8, frustumCulled = $$props2.frustumCulled);
    if ("renderOrder" in $$props2)
      $$invalidate(9, renderOrder = $$props2.renderOrder);
    if ("visible" in $$props2)
      $$invalidate(10, visible = $$props2.visible);
    if ("intensity" in $$props2)
      $$invalidate(11, intensity = $$props2.intensity);
    if ("color" in $$props2)
      $$invalidate(12, color = $$props2.color);
    if ("distance" in $$props2)
      $$invalidate(14, distance = $$props2.distance);
    if ("decay" in $$props2)
      $$invalidate(15, decay = $$props2.decay);
    if ("power" in $$props2)
      $$invalidate(16, power = $$props2.power);
    if ("shadow" in $$props2)
      $$invalidate(13, shadow = $$props2.shadow);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*distance, decay, power*/
    114688) {
      $: {
        if (distance !== void 0)
          $$invalidate(0, light.distance = distance, light);
        if (decay !== void 0)
          $$invalidate(0, light.decay = decay, light);
        if (power !== void 0)
          $$invalidate(0, light.power = power, light);
        invalidate("PointLight: props changed");
      }
    }
    if ($$self.$$.dirty & /*shadow, light*/
    8193) {
      $: {
        if (shadow) {
          const { mapSize = [512, 512], camera: { near = 0.5, far = 500 } = {}, bias = 0, radius = 1 } = shadow === true ? {} : shadow;
          light.shadow.mapSize.set(mapSize[0], mapSize[1]);
          $$invalidate(0, light.shadow.camera.near = near, light);
          $$invalidate(0, light.shadow.camera.far = far, light);
          $$invalidate(0, light.shadow.bias = bias, light);
          $$invalidate(0, light.shadow.radius = radius, light);
        }
        invalidate("PointLight: shadow changed");
      }
    }
  };
  return [
    light,
    inViewport,
    position,
    scale,
    rotation,
    lookAt,
    receiveShadow,
    viewportAware,
    frustumCulled,
    renderOrder,
    visible,
    intensity,
    color,
    shadow,
    distance,
    decay,
    power,
    slots,
    lightinstance_inViewport_binding,
    viewportenter_handler,
    viewportleave_handler,
    $$scope
  ];
}
var PointLight2 = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance21, create_fragment21, safe_not_equal, {
      position: 2,
      scale: 3,
      rotation: 4,
      lookAt: 5,
      receiveShadow: 6,
      viewportAware: 7,
      inViewport: 1,
      frustumCulled: 8,
      renderOrder: 9,
      visible: 10,
      intensity: 11,
      color: 12,
      distance: 14,
      decay: 15,
      power: 16,
      shadow: 13,
      light: 0
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "PointLight",
      options,
      id: create_fragment21.name
    });
  }
  get position() {
    throw new Error("<PointLight>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set position(value) {
    throw new Error("<PointLight>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get scale() {
    throw new Error("<PointLight>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set scale(value) {
    throw new Error("<PointLight>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get rotation() {
    throw new Error("<PointLight>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set rotation(value) {
    throw new Error("<PointLight>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get lookAt() {
    throw new Error("<PointLight>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set lookAt(value) {
    throw new Error("<PointLight>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get receiveShadow() {
    throw new Error("<PointLight>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set receiveShadow(value) {
    throw new Error("<PointLight>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get viewportAware() {
    throw new Error("<PointLight>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set viewportAware(value) {
    throw new Error("<PointLight>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get inViewport() {
    throw new Error("<PointLight>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set inViewport(value) {
    throw new Error("<PointLight>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get frustumCulled() {
    throw new Error("<PointLight>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set frustumCulled(value) {
    throw new Error("<PointLight>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get renderOrder() {
    throw new Error("<PointLight>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set renderOrder(value) {
    throw new Error("<PointLight>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get visible() {
    throw new Error("<PointLight>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set visible(value) {
    throw new Error("<PointLight>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get intensity() {
    throw new Error("<PointLight>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set intensity(value) {
    throw new Error("<PointLight>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get color() {
    throw new Error("<PointLight>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set color(value) {
    throw new Error("<PointLight>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get distance() {
    throw new Error("<PointLight>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set distance(value) {
    throw new Error("<PointLight>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get decay() {
    throw new Error("<PointLight>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set decay(value) {
    throw new Error("<PointLight>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get power() {
    throw new Error("<PointLight>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set power(value) {
    throw new Error("<PointLight>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get shadow() {
    throw new Error("<PointLight>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set shadow(value) {
    throw new Error("<PointLight>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get light() {
    return this.$$.ctx[0];
  }
  set light(value) {
    throw new Error("<PointLight>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var PointLight_default = PointLight2;

// node_modules/threlte/lights/HemisphereLight.svelte
function create_default_slot13(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[17].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[21],
    null
  );
  const block = {
    c: function create() {
      if (default_slot)
        default_slot.c();
    },
    l: function claim(nodes) {
      if (default_slot)
        default_slot.l(nodes);
    },
    m: function mount(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        2097152)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[21],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[21]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[21],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot13.name,
    type: "slot",
    source: "(31:0) <LightInstance   {light}   {lookAt}   {position}   {scale}   {rotation}   {castShadow}   {receiveShadow}   {frustumCulled}   {renderOrder}   {visible}   {viewportAware}   bind:inViewport   on:viewportenter   on:viewportleave   color={skyColor}   {intensity} >",
    ctx
  });
  return block;
}
function create_fragment22(ctx) {
  let lightinstance;
  let updating_inViewport;
  let current;
  function lightinstance_inViewport_binding(value) {
    ctx[18](value);
  }
  let lightinstance_props = {
    light: (
      /*light*/
      ctx[1]
    ),
    lookAt: (
      /*lookAt*/
      ctx[5]
    ),
    position: (
      /*position*/
      ctx[2]
    ),
    scale: (
      /*scale*/
      ctx[3]
    ),
    rotation: (
      /*rotation*/
      ctx[4]
    ),
    castShadow: (
      /*castShadow*/
      ctx[6]
    ),
    receiveShadow: (
      /*receiveShadow*/
      ctx[7]
    ),
    frustumCulled: (
      /*frustumCulled*/
      ctx[9]
    ),
    renderOrder: (
      /*renderOrder*/
      ctx[10]
    ),
    visible: (
      /*visible*/
      ctx[11]
    ),
    viewportAware: (
      /*viewportAware*/
      ctx[8]
    ),
    color: (
      /*skyColor*/
      ctx[13]
    ),
    intensity: (
      /*intensity*/
      ctx[12]
    ),
    $$slots: { default: [create_default_slot13] },
    $$scope: { ctx }
  };
  if (
    /*inViewport*/
    ctx[0] !== void 0
  ) {
    lightinstance_props.inViewport = /*inViewport*/
    ctx[0];
  }
  lightinstance = new LightInstance_default({
    props: lightinstance_props,
    $$inline: true
  });
  binding_callbacks.push(() => bind(lightinstance, "inViewport", lightinstance_inViewport_binding));
  lightinstance.$on(
    "viewportenter",
    /*viewportenter_handler*/
    ctx[19]
  );
  lightinstance.$on(
    "viewportleave",
    /*viewportleave_handler*/
    ctx[20]
  );
  const block = {
    c: function create() {
      create_component(lightinstance.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(lightinstance.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(lightinstance, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const lightinstance_changes = {};
      if (dirty & /*light*/
      2)
        lightinstance_changes.light = /*light*/
        ctx2[1];
      if (dirty & /*lookAt*/
      32)
        lightinstance_changes.lookAt = /*lookAt*/
        ctx2[5];
      if (dirty & /*position*/
      4)
        lightinstance_changes.position = /*position*/
        ctx2[2];
      if (dirty & /*scale*/
      8)
        lightinstance_changes.scale = /*scale*/
        ctx2[3];
      if (dirty & /*rotation*/
      16)
        lightinstance_changes.rotation = /*rotation*/
        ctx2[4];
      if (dirty & /*castShadow*/
      64)
        lightinstance_changes.castShadow = /*castShadow*/
        ctx2[6];
      if (dirty & /*receiveShadow*/
      128)
        lightinstance_changes.receiveShadow = /*receiveShadow*/
        ctx2[7];
      if (dirty & /*frustumCulled*/
      512)
        lightinstance_changes.frustumCulled = /*frustumCulled*/
        ctx2[9];
      if (dirty & /*renderOrder*/
      1024)
        lightinstance_changes.renderOrder = /*renderOrder*/
        ctx2[10];
      if (dirty & /*visible*/
      2048)
        lightinstance_changes.visible = /*visible*/
        ctx2[11];
      if (dirty & /*viewportAware*/
      256)
        lightinstance_changes.viewportAware = /*viewportAware*/
        ctx2[8];
      if (dirty & /*skyColor*/
      8192)
        lightinstance_changes.color = /*skyColor*/
        ctx2[13];
      if (dirty & /*intensity*/
      4096)
        lightinstance_changes.intensity = /*intensity*/
        ctx2[12];
      if (dirty & /*$$scope*/
      2097152) {
        lightinstance_changes.$$scope = { dirty, ctx: ctx2 };
      }
      if (!updating_inViewport && dirty & /*inViewport*/
      1) {
        updating_inViewport = true;
        lightinstance_changes.inViewport = /*inViewport*/
        ctx2[0];
        add_flush_callback(() => updating_inViewport = false);
      }
      lightinstance.$set(lightinstance_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(lightinstance.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(lightinstance.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(lightinstance, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment22.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance22($$self, $$props, $$invalidate) {
  let $linear;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("HemisphereLight", slots, ["default"]);
  let { position = void 0 } = $$props;
  let { scale = void 0 } = $$props;
  let { rotation = void 0 } = $$props;
  let { lookAt = void 0 } = $$props;
  let { castShadow = void 0 } = $$props;
  let { receiveShadow = void 0 } = $$props;
  let { viewportAware = false } = $$props;
  let { inViewport = false } = $$props;
  let { frustumCulled = void 0 } = $$props;
  let { renderOrder = void 0 } = $$props;
  let { visible = void 0 } = $$props;
  let { intensity = void 0 } = $$props;
  let { skyColor = void 0 } = $$props;
  let { groundColor = void 0 } = $$props;
  const light = new HemisphereLight(skyColor, groundColor, intensity);
  const { invalidate } = useThrelte();
  const { linear } = useThrelteRoot();
  validate_store(linear, "linear");
  component_subscribe($$self, linear, (value) => $$invalidate(16, $linear = value));
  const writable_props = [
    "position",
    "scale",
    "rotation",
    "lookAt",
    "castShadow",
    "receiveShadow",
    "viewportAware",
    "inViewport",
    "frustumCulled",
    "renderOrder",
    "visible",
    "intensity",
    "skyColor",
    "groundColor"
  ];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<HemisphereLight> was created with unknown prop '${key}'`);
  });
  function lightinstance_inViewport_binding(value) {
    inViewport = value;
    $$invalidate(0, inViewport);
  }
  function viewportenter_handler(event) {
    bubble.call(this, $$self, event);
  }
  function viewportleave_handler(event) {
    bubble.call(this, $$self, event);
  }
  $$self.$$set = ($$props2) => {
    if ("position" in $$props2)
      $$invalidate(2, position = $$props2.position);
    if ("scale" in $$props2)
      $$invalidate(3, scale = $$props2.scale);
    if ("rotation" in $$props2)
      $$invalidate(4, rotation = $$props2.rotation);
    if ("lookAt" in $$props2)
      $$invalidate(5, lookAt = $$props2.lookAt);
    if ("castShadow" in $$props2)
      $$invalidate(6, castShadow = $$props2.castShadow);
    if ("receiveShadow" in $$props2)
      $$invalidate(7, receiveShadow = $$props2.receiveShadow);
    if ("viewportAware" in $$props2)
      $$invalidate(8, viewportAware = $$props2.viewportAware);
    if ("inViewport" in $$props2)
      $$invalidate(0, inViewport = $$props2.inViewport);
    if ("frustumCulled" in $$props2)
      $$invalidate(9, frustumCulled = $$props2.frustumCulled);
    if ("renderOrder" in $$props2)
      $$invalidate(10, renderOrder = $$props2.renderOrder);
    if ("visible" in $$props2)
      $$invalidate(11, visible = $$props2.visible);
    if ("intensity" in $$props2)
      $$invalidate(12, intensity = $$props2.intensity);
    if ("skyColor" in $$props2)
      $$invalidate(13, skyColor = $$props2.skyColor);
    if ("groundColor" in $$props2)
      $$invalidate(15, groundColor = $$props2.groundColor);
    if ("$$scope" in $$props2)
      $$invalidate(21, $$scope = $$props2.$$scope);
  };
  $$self.$capture_state = () => ({
    ThreeHemisphereLight: HemisphereLight,
    useThrelte,
    useThrelteRoot,
    LightInstance: LightInstance_default,
    convertColorRepresentationToColor,
    position,
    scale,
    rotation,
    lookAt,
    castShadow,
    receiveShadow,
    viewportAware,
    inViewport,
    frustumCulled,
    renderOrder,
    visible,
    intensity,
    skyColor,
    groundColor,
    light,
    invalidate,
    linear,
    $linear
  });
  $$self.$inject_state = ($$props2) => {
    if ("position" in $$props2)
      $$invalidate(2, position = $$props2.position);
    if ("scale" in $$props2)
      $$invalidate(3, scale = $$props2.scale);
    if ("rotation" in $$props2)
      $$invalidate(4, rotation = $$props2.rotation);
    if ("lookAt" in $$props2)
      $$invalidate(5, lookAt = $$props2.lookAt);
    if ("castShadow" in $$props2)
      $$invalidate(6, castShadow = $$props2.castShadow);
    if ("receiveShadow" in $$props2)
      $$invalidate(7, receiveShadow = $$props2.receiveShadow);
    if ("viewportAware" in $$props2)
      $$invalidate(8, viewportAware = $$props2.viewportAware);
    if ("inViewport" in $$props2)
      $$invalidate(0, inViewport = $$props2.inViewport);
    if ("frustumCulled" in $$props2)
      $$invalidate(9, frustumCulled = $$props2.frustumCulled);
    if ("renderOrder" in $$props2)
      $$invalidate(10, renderOrder = $$props2.renderOrder);
    if ("visible" in $$props2)
      $$invalidate(11, visible = $$props2.visible);
    if ("intensity" in $$props2)
      $$invalidate(12, intensity = $$props2.intensity);
    if ("skyColor" in $$props2)
      $$invalidate(13, skyColor = $$props2.skyColor);
    if ("groundColor" in $$props2)
      $$invalidate(15, groundColor = $$props2.groundColor);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*groundColor, $linear*/
    98304) {
      $: {
        if (groundColor !== void 0) {
          $$invalidate(1, light.groundColor = convertColorRepresentationToColor(groundColor, $linear), light);
          invalidate("HemisphereLight: props changed");
        }
      }
    }
  };
  return [
    inViewport,
    light,
    position,
    scale,
    rotation,
    lookAt,
    castShadow,
    receiveShadow,
    viewportAware,
    frustumCulled,
    renderOrder,
    visible,
    intensity,
    skyColor,
    linear,
    groundColor,
    $linear,
    slots,
    lightinstance_inViewport_binding,
    viewportenter_handler,
    viewportleave_handler,
    $$scope
  ];
}
var HemisphereLight2 = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance22, create_fragment22, safe_not_equal, {
      position: 2,
      scale: 3,
      rotation: 4,
      lookAt: 5,
      castShadow: 6,
      receiveShadow: 7,
      viewportAware: 8,
      inViewport: 0,
      frustumCulled: 9,
      renderOrder: 10,
      visible: 11,
      intensity: 12,
      skyColor: 13,
      groundColor: 15,
      light: 1
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "HemisphereLight",
      options,
      id: create_fragment22.name
    });
  }
  get position() {
    throw new Error("<HemisphereLight>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set position(value) {
    throw new Error("<HemisphereLight>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get scale() {
    throw new Error("<HemisphereLight>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set scale(value) {
    throw new Error("<HemisphereLight>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get rotation() {
    throw new Error("<HemisphereLight>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set rotation(value) {
    throw new Error("<HemisphereLight>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get lookAt() {
    throw new Error("<HemisphereLight>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set lookAt(value) {
    throw new Error("<HemisphereLight>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get castShadow() {
    throw new Error("<HemisphereLight>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set castShadow(value) {
    throw new Error("<HemisphereLight>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get receiveShadow() {
    throw new Error("<HemisphereLight>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set receiveShadow(value) {
    throw new Error("<HemisphereLight>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get viewportAware() {
    throw new Error("<HemisphereLight>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set viewportAware(value) {
    throw new Error("<HemisphereLight>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get inViewport() {
    throw new Error("<HemisphereLight>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set inViewport(value) {
    throw new Error("<HemisphereLight>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get frustumCulled() {
    throw new Error("<HemisphereLight>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set frustumCulled(value) {
    throw new Error("<HemisphereLight>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get renderOrder() {
    throw new Error("<HemisphereLight>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set renderOrder(value) {
    throw new Error("<HemisphereLight>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get visible() {
    throw new Error("<HemisphereLight>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set visible(value) {
    throw new Error("<HemisphereLight>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get intensity() {
    throw new Error("<HemisphereLight>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set intensity(value) {
    throw new Error("<HemisphereLight>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get skyColor() {
    throw new Error("<HemisphereLight>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set skyColor(value) {
    throw new Error("<HemisphereLight>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get groundColor() {
    throw new Error("<HemisphereLight>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set groundColor(value) {
    throw new Error("<HemisphereLight>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get light() {
    return this.$$.ctx[1];
  }
  set light(value) {
    throw new Error("<HemisphereLight>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var HemisphereLight_default = HemisphereLight2;

// node_modules/threlte/lights/SpotLight.svelte
function create_if_block4(ctx) {
  let hierarchicalobject;
  let t2;
  let transformableobject;
  let current;
  hierarchicalobject = new HierarchicalObject_default({
    props: { object: (
      /*originalTarget*/
      ctx[14]
    ) },
    $$inline: true
  });
  transformableobject = new TransformableObject_default({
    props: {
      object: (
        /*originalTarget*/
        ctx[14]
      ),
      position: (
        /*target*/
        ctx[12]
      )
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(hierarchicalobject.$$.fragment);
      t2 = space();
      create_component(transformableobject.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(hierarchicalobject.$$.fragment, nodes);
      t2 = claim_space(nodes);
      claim_component(transformableobject.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(hierarchicalobject, target, anchor);
      insert_hydration_dev(target, t2, anchor);
      mount_component(transformableobject, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const transformableobject_changes = {};
      if (dirty[0] & /*target*/
      4096)
        transformableobject_changes.position = /*target*/
        ctx2[12];
      transformableobject.$set(transformableobject_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(hierarchicalobject.$$.fragment, local);
      transition_in(transformableobject.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(hierarchicalobject.$$.fragment, local);
      transition_out(transformableobject.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(hierarchicalobject, detaching);
      if (detaching)
        detach_dev(t2);
      destroy_component(transformableobject, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block4.name,
    type: "if",
    source: "(74:0) {#if target && !(target instanceof Object3D)}",
    ctx
  });
  return block;
}
function create_default_slot14(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[21].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[25],
    null
  );
  const block = {
    c: function create() {
      if (default_slot)
        default_slot.c();
    },
    l: function claim(nodes) {
      if (default_slot)
        default_slot.l(nodes);
    },
    m: function mount(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty[0] & /*$$scope*/
        33554432)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[25],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[25]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[25],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot14.name,
    type: "slot",
    source: "(79:0) <LightInstance   {light}   {position}   {scale}   {rotation}   castShadow={shadow ? true : false}   {receiveShadow}   {frustumCulled}   {renderOrder}   {visible}   {viewportAware}   bind:inViewport   on:viewportenter   on:viewportleave   {color}   {intensity} >",
    ctx
  });
  return block;
}
function create_fragment23(ctx) {
  let t2;
  let lightinstance;
  let updating_inViewport;
  let current;
  let if_block = (
    /*target*/
    ctx[12] && !/*target*/
    (ctx[12] instanceof Object3D) && create_if_block4(ctx)
  );
  function lightinstance_inViewport_binding(value) {
    ctx[22](value);
  }
  let lightinstance_props = {
    light: (
      /*light*/
      ctx[1]
    ),
    position: (
      /*position*/
      ctx[2]
    ),
    scale: (
      /*scale*/
      ctx[3]
    ),
    rotation: (
      /*rotation*/
      ctx[4]
    ),
    castShadow: (
      /*shadow*/
      ctx[13] ? true : false
    ),
    receiveShadow: (
      /*receiveShadow*/
      ctx[7]
    ),
    frustumCulled: (
      /*frustumCulled*/
      ctx[6]
    ),
    renderOrder: (
      /*renderOrder*/
      ctx[8]
    ),
    visible: (
      /*visible*/
      ctx[9]
    ),
    viewportAware: (
      /*viewportAware*/
      ctx[5]
    ),
    color: (
      /*color*/
      ctx[10]
    ),
    intensity: (
      /*intensity*/
      ctx[11]
    ),
    $$slots: { default: [create_default_slot14] },
    $$scope: { ctx }
  };
  if (
    /*inViewport*/
    ctx[0] !== void 0
  ) {
    lightinstance_props.inViewport = /*inViewport*/
    ctx[0];
  }
  lightinstance = new LightInstance_default({
    props: lightinstance_props,
    $$inline: true
  });
  binding_callbacks.push(() => bind(lightinstance, "inViewport", lightinstance_inViewport_binding));
  lightinstance.$on(
    "viewportenter",
    /*viewportenter_handler*/
    ctx[23]
  );
  lightinstance.$on(
    "viewportleave",
    /*viewportleave_handler*/
    ctx[24]
  );
  const block = {
    c: function create() {
      if (if_block)
        if_block.c();
      t2 = space();
      create_component(lightinstance.$$.fragment);
    },
    l: function claim(nodes) {
      if (if_block)
        if_block.l(nodes);
      t2 = claim_space(nodes);
      claim_component(lightinstance.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      if (if_block)
        if_block.m(target, anchor);
      insert_hydration_dev(target, t2, anchor);
      mount_component(lightinstance, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (
        /*target*/
        ctx2[12] && !/*target*/
        (ctx2[12] instanceof Object3D)
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty[0] & /*target*/
          4096) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block4(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(t2.parentNode, t2);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
      const lightinstance_changes = {};
      if (dirty[0] & /*light*/
      2)
        lightinstance_changes.light = /*light*/
        ctx2[1];
      if (dirty[0] & /*position*/
      4)
        lightinstance_changes.position = /*position*/
        ctx2[2];
      if (dirty[0] & /*scale*/
      8)
        lightinstance_changes.scale = /*scale*/
        ctx2[3];
      if (dirty[0] & /*rotation*/
      16)
        lightinstance_changes.rotation = /*rotation*/
        ctx2[4];
      if (dirty[0] & /*shadow*/
      8192)
        lightinstance_changes.castShadow = /*shadow*/
        ctx2[13] ? true : false;
      if (dirty[0] & /*receiveShadow*/
      128)
        lightinstance_changes.receiveShadow = /*receiveShadow*/
        ctx2[7];
      if (dirty[0] & /*frustumCulled*/
      64)
        lightinstance_changes.frustumCulled = /*frustumCulled*/
        ctx2[6];
      if (dirty[0] & /*renderOrder*/
      256)
        lightinstance_changes.renderOrder = /*renderOrder*/
        ctx2[8];
      if (dirty[0] & /*visible*/
      512)
        lightinstance_changes.visible = /*visible*/
        ctx2[9];
      if (dirty[0] & /*viewportAware*/
      32)
        lightinstance_changes.viewportAware = /*viewportAware*/
        ctx2[5];
      if (dirty[0] & /*color*/
      1024)
        lightinstance_changes.color = /*color*/
        ctx2[10];
      if (dirty[0] & /*intensity*/
      2048)
        lightinstance_changes.intensity = /*intensity*/
        ctx2[11];
      if (dirty[0] & /*$$scope*/
      33554432) {
        lightinstance_changes.$$scope = { dirty, ctx: ctx2 };
      }
      if (!updating_inViewport && dirty[0] & /*inViewport*/
      1) {
        updating_inViewport = true;
        lightinstance_changes.inViewport = /*inViewport*/
        ctx2[0];
        add_flush_callback(() => updating_inViewport = false);
      }
      lightinstance.$set(lightinstance_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block);
      transition_in(lightinstance.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      transition_out(lightinstance.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (if_block)
        if_block.d(detaching);
      if (detaching)
        detach_dev(t2);
      destroy_component(lightinstance, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment23.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance23($$self, $$props, $$invalidate) {
  let $started;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("SpotLight", slots, ["default"]);
  let { position = void 0 } = $$props;
  let { scale = void 0 } = $$props;
  let { rotation = void 0 } = $$props;
  let { viewportAware = false } = $$props;
  let { inViewport = false } = $$props;
  let { frustumCulled = void 0 } = $$props;
  let { receiveShadow = void 0 } = $$props;
  let { renderOrder = void 0 } = $$props;
  let { visible = void 0 } = $$props;
  let { color = void 0 } = $$props;
  let { intensity = void 0 } = $$props;
  let { angle = void 0 } = $$props;
  let { decay = void 0 } = $$props;
  let { distance = void 0 } = $$props;
  let { penumbra = void 0 } = $$props;
  let { power = void 0 } = $$props;
  let { target = void 0 } = $$props;
  let { shadow = void 0 } = $$props;
  const { invalidate } = useThrelte();
  const light = new SpotLight(color, intensity);
  const originalTarget = light.target;
  const { start, stop, started } = useFrame(
    () => {
    },
    {
      autostart: false,
      debugFrameloopMessage: "SpotLight: tracking target"
    }
  );
  validate_store(started, "started");
  component_subscribe($$self, started, (value) => $$invalidate(26, $started = value));
  const updateLightTarget = (target2) => {
    if (target2 && target2 instanceof Object3D && !$started) {
      $$invalidate(1, light.target = target2, light);
      start();
      invalidate("SpotLight: target changed");
    } else if ((!target2 || !(target2 instanceof Object3D)) && $started) {
      $$invalidate(1, light.target = originalTarget, light);
      stop();
      invalidate("SpotLight: target changed");
    }
  };
  const updateLightShadow = (shadow2) => {
    if (shadow2) {
      const { mapSize = [512, 512], camera: { near = 0.5, far = 500 } = {}, bias = 0, radius = 1 } = shadow2 === true ? {} : shadow2;
      light.shadow.mapSize.set(mapSize[0], mapSize[1]);
      $$invalidate(1, light.shadow.camera.near = near, light);
      $$invalidate(1, light.shadow.camera.far = far, light);
      $$invalidate(1, light.shadow.bias = bias, light);
      $$invalidate(1, light.shadow.radius = radius, light);
    }
    invalidate("SpotLight: shadow changed");
  };
  const writable_props = [
    "position",
    "scale",
    "rotation",
    "viewportAware",
    "inViewport",
    "frustumCulled",
    "receiveShadow",
    "renderOrder",
    "visible",
    "color",
    "intensity",
    "angle",
    "decay",
    "distance",
    "penumbra",
    "power",
    "target",
    "shadow"
  ];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<SpotLight> was created with unknown prop '${key}'`);
  });
  function lightinstance_inViewport_binding(value) {
    inViewport = value;
    $$invalidate(0, inViewport);
  }
  function viewportenter_handler(event) {
    bubble.call(this, $$self, event);
  }
  function viewportleave_handler(event) {
    bubble.call(this, $$self, event);
  }
  $$self.$$set = ($$props2) => {
    if ("position" in $$props2)
      $$invalidate(2, position = $$props2.position);
    if ("scale" in $$props2)
      $$invalidate(3, scale = $$props2.scale);
    if ("rotation" in $$props2)
      $$invalidate(4, rotation = $$props2.rotation);
    if ("viewportAware" in $$props2)
      $$invalidate(5, viewportAware = $$props2.viewportAware);
    if ("inViewport" in $$props2)
      $$invalidate(0, inViewport = $$props2.inViewport);
    if ("frustumCulled" in $$props2)
      $$invalidate(6, frustumCulled = $$props2.frustumCulled);
    if ("receiveShadow" in $$props2)
      $$invalidate(7, receiveShadow = $$props2.receiveShadow);
    if ("renderOrder" in $$props2)
      $$invalidate(8, renderOrder = $$props2.renderOrder);
    if ("visible" in $$props2)
      $$invalidate(9, visible = $$props2.visible);
    if ("color" in $$props2)
      $$invalidate(10, color = $$props2.color);
    if ("intensity" in $$props2)
      $$invalidate(11, intensity = $$props2.intensity);
    if ("angle" in $$props2)
      $$invalidate(16, angle = $$props2.angle);
    if ("decay" in $$props2)
      $$invalidate(17, decay = $$props2.decay);
    if ("distance" in $$props2)
      $$invalidate(18, distance = $$props2.distance);
    if ("penumbra" in $$props2)
      $$invalidate(19, penumbra = $$props2.penumbra);
    if ("power" in $$props2)
      $$invalidate(20, power = $$props2.power);
    if ("target" in $$props2)
      $$invalidate(12, target = $$props2.target);
    if ("shadow" in $$props2)
      $$invalidate(13, shadow = $$props2.shadow);
    if ("$$scope" in $$props2)
      $$invalidate(25, $$scope = $$props2.$$scope);
  };
  $$self.$capture_state = () => ({
    Object3D,
    ThreeSpotLight: SpotLight,
    useFrame,
    useThrelte,
    LightInstance: LightInstance_default,
    HierarchicalObject: HierarchicalObject_default,
    TransformableObject: TransformableObject_default,
    position,
    scale,
    rotation,
    viewportAware,
    inViewport,
    frustumCulled,
    receiveShadow,
    renderOrder,
    visible,
    color,
    intensity,
    angle,
    decay,
    distance,
    penumbra,
    power,
    target,
    shadow,
    invalidate,
    light,
    originalTarget,
    start,
    stop,
    started,
    updateLightTarget,
    updateLightShadow,
    $started
  });
  $$self.$inject_state = ($$props2) => {
    if ("position" in $$props2)
      $$invalidate(2, position = $$props2.position);
    if ("scale" in $$props2)
      $$invalidate(3, scale = $$props2.scale);
    if ("rotation" in $$props2)
      $$invalidate(4, rotation = $$props2.rotation);
    if ("viewportAware" in $$props2)
      $$invalidate(5, viewportAware = $$props2.viewportAware);
    if ("inViewport" in $$props2)
      $$invalidate(0, inViewport = $$props2.inViewport);
    if ("frustumCulled" in $$props2)
      $$invalidate(6, frustumCulled = $$props2.frustumCulled);
    if ("receiveShadow" in $$props2)
      $$invalidate(7, receiveShadow = $$props2.receiveShadow);
    if ("renderOrder" in $$props2)
      $$invalidate(8, renderOrder = $$props2.renderOrder);
    if ("visible" in $$props2)
      $$invalidate(9, visible = $$props2.visible);
    if ("color" in $$props2)
      $$invalidate(10, color = $$props2.color);
    if ("intensity" in $$props2)
      $$invalidate(11, intensity = $$props2.intensity);
    if ("angle" in $$props2)
      $$invalidate(16, angle = $$props2.angle);
    if ("decay" in $$props2)
      $$invalidate(17, decay = $$props2.decay);
    if ("distance" in $$props2)
      $$invalidate(18, distance = $$props2.distance);
    if ("penumbra" in $$props2)
      $$invalidate(19, penumbra = $$props2.penumbra);
    if ("power" in $$props2)
      $$invalidate(20, power = $$props2.power);
    if ("target" in $$props2)
      $$invalidate(12, target = $$props2.target);
    if ("shadow" in $$props2)
      $$invalidate(13, shadow = $$props2.shadow);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty[0] & /*target*/
    4096) {
      $:
        updateLightTarget(target);
    }
    if ($$self.$$.dirty[0] & /*shadow*/
    8192) {
      $:
        updateLightShadow(shadow);
    }
    if ($$self.$$.dirty[0] & /*distance, decay, angle, penumbra, power*/
    2031616) {
      $: {
        if (distance !== void 0)
          $$invalidate(1, light.distance = distance, light);
        if (decay !== void 0)
          $$invalidate(1, light.decay = decay, light);
        if (angle !== void 0)
          $$invalidate(1, light.angle = angle, light);
        if (penumbra !== void 0)
          $$invalidate(1, light.penumbra = penumbra, light);
        if (power !== void 0)
          $$invalidate(1, light.power = power, light);
        invalidate("SpotLight: props changed");
      }
    }
  };
  return [
    inViewport,
    light,
    position,
    scale,
    rotation,
    viewportAware,
    frustumCulled,
    receiveShadow,
    renderOrder,
    visible,
    color,
    intensity,
    target,
    shadow,
    originalTarget,
    started,
    angle,
    decay,
    distance,
    penumbra,
    power,
    slots,
    lightinstance_inViewport_binding,
    viewportenter_handler,
    viewportleave_handler,
    $$scope
  ];
}
var SpotLight2 = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(
      this,
      options,
      instance23,
      create_fragment23,
      safe_not_equal,
      {
        position: 2,
        scale: 3,
        rotation: 4,
        viewportAware: 5,
        inViewport: 0,
        frustumCulled: 6,
        receiveShadow: 7,
        renderOrder: 8,
        visible: 9,
        color: 10,
        intensity: 11,
        angle: 16,
        decay: 17,
        distance: 18,
        penumbra: 19,
        power: 20,
        target: 12,
        shadow: 13,
        light: 1
      },
      null,
      [-1, -1]
    );
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "SpotLight",
      options,
      id: create_fragment23.name
    });
  }
  get position() {
    throw new Error("<SpotLight>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set position(value) {
    throw new Error("<SpotLight>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get scale() {
    throw new Error("<SpotLight>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set scale(value) {
    throw new Error("<SpotLight>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get rotation() {
    throw new Error("<SpotLight>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set rotation(value) {
    throw new Error("<SpotLight>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get viewportAware() {
    throw new Error("<SpotLight>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set viewportAware(value) {
    throw new Error("<SpotLight>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get inViewport() {
    throw new Error("<SpotLight>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set inViewport(value) {
    throw new Error("<SpotLight>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get frustumCulled() {
    throw new Error("<SpotLight>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set frustumCulled(value) {
    throw new Error("<SpotLight>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get receiveShadow() {
    throw new Error("<SpotLight>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set receiveShadow(value) {
    throw new Error("<SpotLight>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get renderOrder() {
    throw new Error("<SpotLight>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set renderOrder(value) {
    throw new Error("<SpotLight>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get visible() {
    throw new Error("<SpotLight>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set visible(value) {
    throw new Error("<SpotLight>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get color() {
    throw new Error("<SpotLight>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set color(value) {
    throw new Error("<SpotLight>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get intensity() {
    throw new Error("<SpotLight>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set intensity(value) {
    throw new Error("<SpotLight>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get angle() {
    throw new Error("<SpotLight>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set angle(value) {
    throw new Error("<SpotLight>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get decay() {
    throw new Error("<SpotLight>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set decay(value) {
    throw new Error("<SpotLight>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get distance() {
    throw new Error("<SpotLight>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set distance(value) {
    throw new Error("<SpotLight>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get penumbra() {
    throw new Error("<SpotLight>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set penumbra(value) {
    throw new Error("<SpotLight>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get power() {
    throw new Error("<SpotLight>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set power(value) {
    throw new Error("<SpotLight>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get target() {
    throw new Error("<SpotLight>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set target(value) {
    throw new Error("<SpotLight>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get shadow() {
    throw new Error("<SpotLight>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set shadow(value) {
    throw new Error("<SpotLight>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get light() {
    return this.$$.ctx[1];
  }
  set light(value) {
    throw new Error("<SpotLight>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var SpotLight_default = SpotLight2;

// node_modules/threlte/misc/Fog.svelte
function create_fragment24(ctx) {
  const block = {
    c: noop,
    l: noop,
    m: noop,
    p: noop,
    i: noop,
    o: noop,
    d: noop
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment24.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance24($$self, $$props, $$invalidate) {
  let $linear;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Fog", slots, []);
  let { color = 16777215 } = $$props;
  let { near = void 0 } = $$props;
  let { far = void 0 } = $$props;
  const { linear } = useThrelteRoot();
  validate_store(linear, "linear");
  component_subscribe($$self, linear, (value) => $$invalidate(5, $linear = value));
  const { scene, invalidate } = useThrelte();
  const fog = new Fog(convertColorRepresentationToColor(color, $linear), near, far);
  scene.fog = fog;
  invalidate("Fog: added");
  onDestroy(() => {
    scene.fog = null;
    invalidate("Fog: removed");
  });
  const writable_props = ["color", "near", "far"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<Fog> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("color" in $$props2)
      $$invalidate(2, color = $$props2.color);
    if ("near" in $$props2)
      $$invalidate(3, near = $$props2.near);
    if ("far" in $$props2)
      $$invalidate(4, far = $$props2.far);
  };
  $$self.$capture_state = () => ({
    onDestroy,
    ThreeFog: Fog,
    useThrelte,
    useThrelteRoot,
    convertColorRepresentationToColor,
    color,
    near,
    far,
    linear,
    scene,
    invalidate,
    fog,
    $linear
  });
  $$self.$inject_state = ($$props2) => {
    if ("color" in $$props2)
      $$invalidate(2, color = $$props2.color);
    if ("near" in $$props2)
      $$invalidate(3, near = $$props2.near);
    if ("far" in $$props2)
      $$invalidate(4, far = $$props2.far);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*color, $linear, near, far*/
    60) {
      $: {
        if (color !== void 0)
          $$invalidate(1, fog.color = convertColorRepresentationToColor(color, $linear), fog);
        if (near !== void 0)
          $$invalidate(1, fog.near = near, fog);
        if (far !== void 0)
          $$invalidate(1, fog.far = far, fog);
        invalidate("Fog: props changed");
      }
    }
  };
  return [linear, fog, color, near, far, $linear];
}
var Fog2 = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance24, create_fragment24, safe_not_equal, { color: 2, near: 3, far: 4, fog: 1 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Fog",
      options,
      id: create_fragment24.name
    });
  }
  get color() {
    throw new Error("<Fog>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set color(value) {
    throw new Error("<Fog>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get near() {
    throw new Error("<Fog>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set near(value) {
    throw new Error("<Fog>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get far() {
    throw new Error("<Fog>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set far(value) {
    throw new Error("<Fog>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get fog() {
    return this.$$.ctx[1];
  }
  set fog(value) {
    throw new Error("<Fog>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Fog_default = Fog2;

// node_modules/threlte/misc/FogExp2.svelte
function create_fragment25(ctx) {
  const block = {
    c: noop,
    l: noop,
    m: noop,
    p: noop,
    i: noop,
    o: noop,
    d: noop
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment25.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance25($$self, $$props, $$invalidate) {
  let $linear;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("FogExp2", slots, []);
  let { color = 16777215 } = $$props;
  let { density = void 0 } = $$props;
  const { linear } = useThrelteRoot();
  validate_store(linear, "linear");
  component_subscribe($$self, linear, (value) => $$invalidate(4, $linear = value));
  const { scene, invalidate } = useThrelte();
  const fog = new FogExp2(convertColorRepresentationToColor(color, $linear), density);
  scene.fog = fog;
  invalidate("FogExp2: added");
  onDestroy(() => {
    scene.fog = null;
    invalidate("FogExp2: removed");
  });
  const writable_props = ["color", "density"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<FogExp2> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("color" in $$props2)
      $$invalidate(2, color = $$props2.color);
    if ("density" in $$props2)
      $$invalidate(3, density = $$props2.density);
  };
  $$self.$capture_state = () => ({
    onDestroy,
    ThreeFogExp2: FogExp2,
    useThrelte,
    useThrelteRoot,
    convertColorRepresentationToColor,
    color,
    density,
    linear,
    scene,
    invalidate,
    fog,
    $linear
  });
  $$self.$inject_state = ($$props2) => {
    if ("color" in $$props2)
      $$invalidate(2, color = $$props2.color);
    if ("density" in $$props2)
      $$invalidate(3, density = $$props2.density);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*color, $linear, density*/
    28) {
      $: {
        $$invalidate(1, fog.color = convertColorRepresentationToColor(color, $linear), fog);
        if (density !== void 0)
          $$invalidate(1, fog.density = density, fog);
        invalidate("FogExp2: props changed");
      }
    }
  };
  return [linear, fog, color, density, $linear];
}
var FogExp22 = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance25, create_fragment25, safe_not_equal, { color: 2, density: 3, fog: 1 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "FogExp2",
      options,
      id: create_fragment25.name
    });
  }
  get color() {
    throw new Error("<FogExp2>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set color(value) {
    throw new Error("<FogExp2>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get density() {
    throw new Error("<FogExp2>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set density(value) {
    throw new Error("<FogExp2>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get fog() {
    return this.$$.ctx[1];
  }
  set fog(value) {
    throw new Error("<FogExp2>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var FogExp2_default = FogExp22;

// node_modules/threlte/misc/Layers.svelte
function create_fragment26(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[2].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[1],
    null
  );
  const block = {
    c: function create() {
      if (default_slot)
        default_slot.c();
    },
    l: function claim(nodes) {
      if (default_slot)
        default_slot.l(nodes);
    },
    m: function mount(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        2)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[1],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[1]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[1],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment26.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance26($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Layers", slots, ["default"]);
  let { layers } = $$props;
  const layerStore = writable(layers);
  setContext("threlte-layers", layerStore);
  $$self.$$.on_mount.push(function() {
    if (layers === void 0 && !("layers" in $$props || $$self.$$.bound[$$self.$$.props["layers"]])) {
      console.warn("<Layers> was created without expected prop 'layers'");
    }
  });
  const writable_props = ["layers"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<Layers> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("layers" in $$props2)
      $$invalidate(0, layers = $$props2.layers);
    if ("$$scope" in $$props2)
      $$invalidate(1, $$scope = $$props2.$$scope);
  };
  $$self.$capture_state = () => ({ setContext, writable, layers, layerStore });
  $$self.$inject_state = ($$props2) => {
    if ("layers" in $$props2)
      $$invalidate(0, layers = $$props2.layers);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*layers*/
    1) {
      $:
        layerStore.set(layers);
    }
  };
  return [layers, $$scope, slots];
}
var Layers = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance26, create_fragment26, safe_not_equal, { layers: 0 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Layers",
      options,
      id: create_fragment26.name
    });
  }
  get layers() {
    throw new Error("<Layers>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set layers(value) {
    throw new Error("<Layers>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Layers_default = Layers;

// node_modules/threlte/misc/ContextBridge.svelte
function create_fragment27(ctx) {
  const block = {
    c: noop,
    l: noop,
    m: noop,
    p: noop,
    i: noop,
    o: noop,
    d: noop
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment27.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance27($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("ContextBridge", slots, []);
  const ctx = useThrelte();
  const rootCtx = useThrelteRoot();
  const writable_props = [];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<ContextBridge> was created with unknown prop '${key}'`);
  });
  $$self.$capture_state = () => ({ useThrelte, useThrelteRoot, ctx, rootCtx });
  return [ctx, rootCtx];
}
var ContextBridge = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance27, create_fragment27, safe_not_equal, { ctx: 0, rootCtx: 1 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "ContextBridge",
      options,
      id: create_fragment27.name
    });
  }
  get ctx() {
    return this.$$.ctx[0];
  }
  set ctx(value) {
    throw new Error("<ContextBridge>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get rootCtx() {
    return this.$$.ctx[1];
  }
  set rootCtx(value) {
    throw new Error("<ContextBridge>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var ContextBridge_default = ContextBridge;

// node_modules/threlte/internal/InteractiveObject.svelte
function create_fragment28(ctx) {
  const block = {
    c: noop,
    l: noop,
    m: noop,
    p: noop,
    i: noop,
    o: noop,
    d: noop
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment28.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance28($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("InteractiveObject", slots, []);
  let { object } = $$props;
  let previousObject = object;
  let { interactive = false } = $$props;
  let { ignorePointer = false } = $$props;
  const eventDispatcher = createEventDispatcher();
  const { addInteractiveObject, removeInteractiveObject, addRaycastableObject, removeRaycastableObject } = useThrelteRoot();
  const { invalidate } = useThrelte();
  const removeObjectInteractivity = (object2) => {
    removeRaycastableObject(object2);
    removeInteractiveObject(object2);
    delete getThrelteUserData(object2).eventDispatcher;
  };
  const setupObjectInteractivity = (object2, ignorePointer2, interactive2) => {
    getThrelteUserData(object2).eventDispatcher = eventDispatcher;
    if (ignorePointer2) {
      removeRaycastableObject(object2);
      removeInteractiveObject(object2);
    } else {
      addRaycastableObject(object2);
      if (interactive2) {
        addInteractiveObject(object2);
      } else {
        removeInteractiveObject(object2);
      }
    }
  };
  onDestroy(() => {
    removeObjectInteractivity(object);
    invalidate("InteractiveObject: object removed");
  });
  $$self.$$.on_mount.push(function() {
    if (object === void 0 && !("object" in $$props || $$self.$$.bound[$$self.$$.props["object"]])) {
      console.warn("<InteractiveObject> was created without expected prop 'object'");
    }
  });
  const writable_props = ["object", "interactive", "ignorePointer"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<InteractiveObject> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("object" in $$props2)
      $$invalidate(0, object = $$props2.object);
    if ("interactive" in $$props2)
      $$invalidate(1, interactive = $$props2.interactive);
    if ("ignorePointer" in $$props2)
      $$invalidate(2, ignorePointer = $$props2.ignorePointer);
  };
  $$self.$capture_state = () => ({
    createEventDispatcher,
    onDestroy,
    useThrelte,
    useThrelteRoot,
    getThrelteUserData,
    object,
    previousObject,
    interactive,
    ignorePointer,
    eventDispatcher,
    addInteractiveObject,
    removeInteractiveObject,
    addRaycastableObject,
    removeRaycastableObject,
    invalidate,
    removeObjectInteractivity,
    setupObjectInteractivity
  });
  $$self.$inject_state = ($$props2) => {
    if ("object" in $$props2)
      $$invalidate(0, object = $$props2.object);
    if ("previousObject" in $$props2)
      $$invalidate(3, previousObject = $$props2.previousObject);
    if ("interactive" in $$props2)
      $$invalidate(1, interactive = $$props2.interactive);
    if ("ignorePointer" in $$props2)
      $$invalidate(2, ignorePointer = $$props2.ignorePointer);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*object, previousObject, ignorePointer, interactive*/
    15) {
      $: {
        if (object !== previousObject) {
          removeObjectInteractivity(previousObject);
          setupObjectInteractivity(object, ignorePointer, interactive);
          invalidate("InteractiveObject: object changed");
          $$invalidate(3, previousObject = object);
        } else if (object === previousObject) {
          setupObjectInteractivity(object, ignorePointer, interactive);
          invalidate("InteractiveObject: props changed");
        }
      }
    }
  };
  return [object, interactive, ignorePointer, previousObject];
}
var InteractiveObject = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance28, create_fragment28, safe_not_equal, {
      object: 0,
      interactive: 1,
      ignorePointer: 2
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "InteractiveObject",
      options,
      id: create_fragment28.name
    });
  }
  get object() {
    throw new Error("<InteractiveObject>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set object(value) {
    throw new Error("<InteractiveObject>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get interactive() {
    throw new Error("<InteractiveObject>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set interactive(value) {
    throw new Error("<InteractiveObject>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get ignorePointer() {
    throw new Error("<InteractiveObject>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set ignorePointer(value) {
    throw new Error("<InteractiveObject>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var InteractiveObject_default = InteractiveObject;

// node_modules/threlte/instances/MeshInstance.svelte
function create_default_slot15(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[14].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[25],
    null
  );
  const block = {
    c: function create() {
      if (default_slot)
        default_slot.c();
    },
    l: function claim(nodes) {
      if (default_slot)
        default_slot.l(nodes);
    },
    m: function mount(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        33554432)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[25],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[25]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[25],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot15.name,
    type: "slot",
    source: "(19:0) <Object3DInstance   object={mesh}   {lookAt}   {position}   {scale}   {rotation}   {castShadow}   {receiveShadow}   {frustumCulled}   {renderOrder}   {visible}   {viewportAware}   on:viewportenter   on:viewportleave   bind:inViewport >",
    ctx
  });
  return block;
}
function create_fragment29(ctx) {
  let object3dinstance;
  let updating_inViewport;
  let t2;
  let interactiveobject;
  let current;
  function object3dinstance_inViewport_binding(value) {
    ctx[15](value);
  }
  let object3dinstance_props = {
    object: (
      /*mesh*/
      ctx[1]
    ),
    lookAt: (
      /*lookAt*/
      ctx[5]
    ),
    position: (
      /*position*/
      ctx[2]
    ),
    scale: (
      /*scale*/
      ctx[3]
    ),
    rotation: (
      /*rotation*/
      ctx[4]
    ),
    castShadow: (
      /*castShadow*/
      ctx[7]
    ),
    receiveShadow: (
      /*receiveShadow*/
      ctx[8]
    ),
    frustumCulled: (
      /*frustumCulled*/
      ctx[9]
    ),
    renderOrder: (
      /*renderOrder*/
      ctx[10]
    ),
    visible: (
      /*visible*/
      ctx[11]
    ),
    viewportAware: (
      /*viewportAware*/
      ctx[6]
    ),
    $$slots: { default: [create_default_slot15] },
    $$scope: { ctx }
  };
  if (
    /*inViewport*/
    ctx[0] !== void 0
  ) {
    object3dinstance_props.inViewport = /*inViewport*/
    ctx[0];
  }
  object3dinstance = new Object3DInstance_default({
    props: object3dinstance_props,
    $$inline: true
  });
  binding_callbacks.push(() => bind(object3dinstance, "inViewport", object3dinstance_inViewport_binding));
  object3dinstance.$on(
    "viewportenter",
    /*viewportenter_handler*/
    ctx[16]
  );
  object3dinstance.$on(
    "viewportleave",
    /*viewportleave_handler*/
    ctx[17]
  );
  interactiveobject = new InteractiveObject_default({
    props: {
      object: (
        /*mesh*/
        ctx[1]
      ),
      interactive: (
        /*interactive*/
        ctx[12]
      ),
      ignorePointer: (
        /*ignorePointer*/
        ctx[13]
      )
    },
    $$inline: true
  });
  interactiveobject.$on(
    "click",
    /*click_handler*/
    ctx[18]
  );
  interactiveobject.$on(
    "contextmenu",
    /*contextmenu_handler*/
    ctx[19]
  );
  interactiveobject.$on(
    "pointerup",
    /*pointerup_handler*/
    ctx[20]
  );
  interactiveobject.$on(
    "pointerdown",
    /*pointerdown_handler*/
    ctx[21]
  );
  interactiveobject.$on(
    "pointerenter",
    /*pointerenter_handler*/
    ctx[22]
  );
  interactiveobject.$on(
    "pointerleave",
    /*pointerleave_handler*/
    ctx[23]
  );
  interactiveobject.$on(
    "pointermove",
    /*pointermove_handler*/
    ctx[24]
  );
  const block = {
    c: function create() {
      create_component(object3dinstance.$$.fragment);
      t2 = space();
      create_component(interactiveobject.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(object3dinstance.$$.fragment, nodes);
      t2 = claim_space(nodes);
      claim_component(interactiveobject.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(object3dinstance, target, anchor);
      insert_hydration_dev(target, t2, anchor);
      mount_component(interactiveobject, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const object3dinstance_changes = {};
      if (dirty & /*mesh*/
      2)
        object3dinstance_changes.object = /*mesh*/
        ctx2[1];
      if (dirty & /*lookAt*/
      32)
        object3dinstance_changes.lookAt = /*lookAt*/
        ctx2[5];
      if (dirty & /*position*/
      4)
        object3dinstance_changes.position = /*position*/
        ctx2[2];
      if (dirty & /*scale*/
      8)
        object3dinstance_changes.scale = /*scale*/
        ctx2[3];
      if (dirty & /*rotation*/
      16)
        object3dinstance_changes.rotation = /*rotation*/
        ctx2[4];
      if (dirty & /*castShadow*/
      128)
        object3dinstance_changes.castShadow = /*castShadow*/
        ctx2[7];
      if (dirty & /*receiveShadow*/
      256)
        object3dinstance_changes.receiveShadow = /*receiveShadow*/
        ctx2[8];
      if (dirty & /*frustumCulled*/
      512)
        object3dinstance_changes.frustumCulled = /*frustumCulled*/
        ctx2[9];
      if (dirty & /*renderOrder*/
      1024)
        object3dinstance_changes.renderOrder = /*renderOrder*/
        ctx2[10];
      if (dirty & /*visible*/
      2048)
        object3dinstance_changes.visible = /*visible*/
        ctx2[11];
      if (dirty & /*viewportAware*/
      64)
        object3dinstance_changes.viewportAware = /*viewportAware*/
        ctx2[6];
      if (dirty & /*$$scope*/
      33554432) {
        object3dinstance_changes.$$scope = { dirty, ctx: ctx2 };
      }
      if (!updating_inViewport && dirty & /*inViewport*/
      1) {
        updating_inViewport = true;
        object3dinstance_changes.inViewport = /*inViewport*/
        ctx2[0];
        add_flush_callback(() => updating_inViewport = false);
      }
      object3dinstance.$set(object3dinstance_changes);
      const interactiveobject_changes = {};
      if (dirty & /*mesh*/
      2)
        interactiveobject_changes.object = /*mesh*/
        ctx2[1];
      if (dirty & /*interactive*/
      4096)
        interactiveobject_changes.interactive = /*interactive*/
        ctx2[12];
      if (dirty & /*ignorePointer*/
      8192)
        interactiveobject_changes.ignorePointer = /*ignorePointer*/
        ctx2[13];
      interactiveobject.$set(interactiveobject_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(object3dinstance.$$.fragment, local);
      transition_in(interactiveobject.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(object3dinstance.$$.fragment, local);
      transition_out(interactiveobject.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(object3dinstance, detaching);
      if (detaching)
        detach_dev(t2);
      destroy_component(interactiveobject, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment29.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance29($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MeshInstance", slots, ["default"]);
  let { mesh } = $$props;
  let { position = void 0 } = $$props;
  let { scale = void 0 } = $$props;
  let { rotation = void 0 } = $$props;
  let { lookAt = void 0 } = $$props;
  let { viewportAware = false } = $$props;
  let { inViewport = false } = $$props;
  let { castShadow = void 0 } = $$props;
  let { receiveShadow = void 0 } = $$props;
  let { frustumCulled = void 0 } = $$props;
  let { renderOrder = void 0 } = $$props;
  let { visible = void 0 } = $$props;
  let { interactive = false } = $$props;
  let { ignorePointer = false } = $$props;
  $$self.$$.on_mount.push(function() {
    if (mesh === void 0 && !("mesh" in $$props || $$self.$$.bound[$$self.$$.props["mesh"]])) {
      console.warn("<MeshInstance> was created without expected prop 'mesh'");
    }
  });
  const writable_props = [
    "mesh",
    "position",
    "scale",
    "rotation",
    "lookAt",
    "viewportAware",
    "inViewport",
    "castShadow",
    "receiveShadow",
    "frustumCulled",
    "renderOrder",
    "visible",
    "interactive",
    "ignorePointer"
  ];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<MeshInstance> was created with unknown prop '${key}'`);
  });
  function object3dinstance_inViewport_binding(value) {
    inViewport = value;
    $$invalidate(0, inViewport);
  }
  function viewportenter_handler(event) {
    bubble.call(this, $$self, event);
  }
  function viewportleave_handler(event) {
    bubble.call(this, $$self, event);
  }
  function click_handler(event) {
    bubble.call(this, $$self, event);
  }
  function contextmenu_handler(event) {
    bubble.call(this, $$self, event);
  }
  function pointerup_handler(event) {
    bubble.call(this, $$self, event);
  }
  function pointerdown_handler(event) {
    bubble.call(this, $$self, event);
  }
  function pointerenter_handler(event) {
    bubble.call(this, $$self, event);
  }
  function pointerleave_handler(event) {
    bubble.call(this, $$self, event);
  }
  function pointermove_handler(event) {
    bubble.call(this, $$self, event);
  }
  $$self.$$set = ($$props2) => {
    if ("mesh" in $$props2)
      $$invalidate(1, mesh = $$props2.mesh);
    if ("position" in $$props2)
      $$invalidate(2, position = $$props2.position);
    if ("scale" in $$props2)
      $$invalidate(3, scale = $$props2.scale);
    if ("rotation" in $$props2)
      $$invalidate(4, rotation = $$props2.rotation);
    if ("lookAt" in $$props2)
      $$invalidate(5, lookAt = $$props2.lookAt);
    if ("viewportAware" in $$props2)
      $$invalidate(6, viewportAware = $$props2.viewportAware);
    if ("inViewport" in $$props2)
      $$invalidate(0, inViewport = $$props2.inViewport);
    if ("castShadow" in $$props2)
      $$invalidate(7, castShadow = $$props2.castShadow);
    if ("receiveShadow" in $$props2)
      $$invalidate(8, receiveShadow = $$props2.receiveShadow);
    if ("frustumCulled" in $$props2)
      $$invalidate(9, frustumCulled = $$props2.frustumCulled);
    if ("renderOrder" in $$props2)
      $$invalidate(10, renderOrder = $$props2.renderOrder);
    if ("visible" in $$props2)
      $$invalidate(11, visible = $$props2.visible);
    if ("interactive" in $$props2)
      $$invalidate(12, interactive = $$props2.interactive);
    if ("ignorePointer" in $$props2)
      $$invalidate(13, ignorePointer = $$props2.ignorePointer);
    if ("$$scope" in $$props2)
      $$invalidate(25, $$scope = $$props2.$$scope);
  };
  $$self.$capture_state = () => ({
    InteractiveObject: InteractiveObject_default,
    Object3DInstance: Object3DInstance_default,
    mesh,
    position,
    scale,
    rotation,
    lookAt,
    viewportAware,
    inViewport,
    castShadow,
    receiveShadow,
    frustumCulled,
    renderOrder,
    visible,
    interactive,
    ignorePointer
  });
  $$self.$inject_state = ($$props2) => {
    if ("mesh" in $$props2)
      $$invalidate(1, mesh = $$props2.mesh);
    if ("position" in $$props2)
      $$invalidate(2, position = $$props2.position);
    if ("scale" in $$props2)
      $$invalidate(3, scale = $$props2.scale);
    if ("rotation" in $$props2)
      $$invalidate(4, rotation = $$props2.rotation);
    if ("lookAt" in $$props2)
      $$invalidate(5, lookAt = $$props2.lookAt);
    if ("viewportAware" in $$props2)
      $$invalidate(6, viewportAware = $$props2.viewportAware);
    if ("inViewport" in $$props2)
      $$invalidate(0, inViewport = $$props2.inViewport);
    if ("castShadow" in $$props2)
      $$invalidate(7, castShadow = $$props2.castShadow);
    if ("receiveShadow" in $$props2)
      $$invalidate(8, receiveShadow = $$props2.receiveShadow);
    if ("frustumCulled" in $$props2)
      $$invalidate(9, frustumCulled = $$props2.frustumCulled);
    if ("renderOrder" in $$props2)
      $$invalidate(10, renderOrder = $$props2.renderOrder);
    if ("visible" in $$props2)
      $$invalidate(11, visible = $$props2.visible);
    if ("interactive" in $$props2)
      $$invalidate(12, interactive = $$props2.interactive);
    if ("ignorePointer" in $$props2)
      $$invalidate(13, ignorePointer = $$props2.ignorePointer);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [
    inViewport,
    mesh,
    position,
    scale,
    rotation,
    lookAt,
    viewportAware,
    castShadow,
    receiveShadow,
    frustumCulled,
    renderOrder,
    visible,
    interactive,
    ignorePointer,
    slots,
    object3dinstance_inViewport_binding,
    viewportenter_handler,
    viewportleave_handler,
    click_handler,
    contextmenu_handler,
    pointerup_handler,
    pointerdown_handler,
    pointerenter_handler,
    pointerleave_handler,
    pointermove_handler,
    $$scope
  ];
}
var MeshInstance = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance29, create_fragment29, safe_not_equal, {
      mesh: 1,
      position: 2,
      scale: 3,
      rotation: 4,
      lookAt: 5,
      viewportAware: 6,
      inViewport: 0,
      castShadow: 7,
      receiveShadow: 8,
      frustumCulled: 9,
      renderOrder: 10,
      visible: 11,
      interactive: 12,
      ignorePointer: 13
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MeshInstance",
      options,
      id: create_fragment29.name
    });
  }
  get mesh() {
    throw new Error("<MeshInstance>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set mesh(value) {
    throw new Error("<MeshInstance>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get position() {
    throw new Error("<MeshInstance>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set position(value) {
    throw new Error("<MeshInstance>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get scale() {
    throw new Error("<MeshInstance>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set scale(value) {
    throw new Error("<MeshInstance>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get rotation() {
    throw new Error("<MeshInstance>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set rotation(value) {
    throw new Error("<MeshInstance>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get lookAt() {
    throw new Error("<MeshInstance>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set lookAt(value) {
    throw new Error("<MeshInstance>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get viewportAware() {
    throw new Error("<MeshInstance>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set viewportAware(value) {
    throw new Error("<MeshInstance>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get inViewport() {
    throw new Error("<MeshInstance>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set inViewport(value) {
    throw new Error("<MeshInstance>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get castShadow() {
    throw new Error("<MeshInstance>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set castShadow(value) {
    throw new Error("<MeshInstance>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get receiveShadow() {
    throw new Error("<MeshInstance>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set receiveShadow(value) {
    throw new Error("<MeshInstance>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get frustumCulled() {
    throw new Error("<MeshInstance>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set frustumCulled(value) {
    throw new Error("<MeshInstance>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get renderOrder() {
    throw new Error("<MeshInstance>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set renderOrder(value) {
    throw new Error("<MeshInstance>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get visible() {
    throw new Error("<MeshInstance>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set visible(value) {
    throw new Error("<MeshInstance>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get interactive() {
    throw new Error("<MeshInstance>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set interactive(value) {
    throw new Error("<MeshInstance>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get ignorePointer() {
    throw new Error("<MeshInstance>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set ignorePointer(value) {
    throw new Error("<MeshInstance>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var MeshInstance_default = MeshInstance;

// node_modules/threlte/objects/Mesh.svelte
function create_default_slot16(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[18].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[29],
    null
  );
  const block = {
    c: function create() {
      if (default_slot)
        default_slot.c();
    },
    l: function claim(nodes) {
      if (default_slot)
        default_slot.l(nodes);
    },
    m: function mount(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty[0] & /*$$scope*/
        536870912)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[29],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[29]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[29],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot16.name,
    type: "slot",
    source: "(48:0) <MeshInstance   {mesh}   {position}   {scale}   {rotation}   {lookAt}   {castShadow}   {receiveShadow}   {frustumCulled}   {renderOrder}   {visible}   {interactive}   {ignorePointer}   on:click   on:contextmenu   on:pointerup   on:pointerdown   on:pointerenter   on:pointerleave   on:pointermove   {viewportAware}   bind:inViewport   on:viewportenter   on:viewportleave >",
    ctx
  });
  return block;
}
function create_fragment30(ctx) {
  let meshinstance;
  let updating_inViewport;
  let current;
  function meshinstance_inViewport_binding(value) {
    ctx[19](value);
  }
  let meshinstance_props = {
    mesh: (
      /*mesh*/
      ctx[13]
    ),
    position: (
      /*position*/
      ctx[1]
    ),
    scale: (
      /*scale*/
      ctx[2]
    ),
    rotation: (
      /*rotation*/
      ctx[3]
    ),
    lookAt: (
      /*lookAt*/
      ctx[12]
    ),
    castShadow: (
      /*castShadow*/
      ctx[5]
    ),
    receiveShadow: (
      /*receiveShadow*/
      ctx[6]
    ),
    frustumCulled: (
      /*frustumCulled*/
      ctx[7]
    ),
    renderOrder: (
      /*renderOrder*/
      ctx[8]
    ),
    visible: (
      /*visible*/
      ctx[9]
    ),
    interactive: (
      /*interactive*/
      ctx[10]
    ),
    ignorePointer: (
      /*ignorePointer*/
      ctx[11]
    ),
    viewportAware: (
      /*viewportAware*/
      ctx[4]
    ),
    $$slots: { default: [create_default_slot16] },
    $$scope: { ctx }
  };
  if (
    /*inViewport*/
    ctx[0] !== void 0
  ) {
    meshinstance_props.inViewport = /*inViewport*/
    ctx[0];
  }
  meshinstance = new MeshInstance_default({
    props: meshinstance_props,
    $$inline: true
  });
  binding_callbacks.push(() => bind(meshinstance, "inViewport", meshinstance_inViewport_binding));
  meshinstance.$on(
    "click",
    /*click_handler*/
    ctx[20]
  );
  meshinstance.$on(
    "contextmenu",
    /*contextmenu_handler*/
    ctx[21]
  );
  meshinstance.$on(
    "pointerup",
    /*pointerup_handler*/
    ctx[22]
  );
  meshinstance.$on(
    "pointerdown",
    /*pointerdown_handler*/
    ctx[23]
  );
  meshinstance.$on(
    "pointerenter",
    /*pointerenter_handler*/
    ctx[24]
  );
  meshinstance.$on(
    "pointerleave",
    /*pointerleave_handler*/
    ctx[25]
  );
  meshinstance.$on(
    "pointermove",
    /*pointermove_handler*/
    ctx[26]
  );
  meshinstance.$on(
    "viewportenter",
    /*viewportenter_handler*/
    ctx[27]
  );
  meshinstance.$on(
    "viewportleave",
    /*viewportleave_handler*/
    ctx[28]
  );
  const block = {
    c: function create() {
      create_component(meshinstance.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(meshinstance.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(meshinstance, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const meshinstance_changes = {};
      if (dirty[0] & /*position*/
      2)
        meshinstance_changes.position = /*position*/
        ctx2[1];
      if (dirty[0] & /*scale*/
      4)
        meshinstance_changes.scale = /*scale*/
        ctx2[2];
      if (dirty[0] & /*rotation*/
      8)
        meshinstance_changes.rotation = /*rotation*/
        ctx2[3];
      if (dirty[0] & /*lookAt*/
      4096)
        meshinstance_changes.lookAt = /*lookAt*/
        ctx2[12];
      if (dirty[0] & /*castShadow*/
      32)
        meshinstance_changes.castShadow = /*castShadow*/
        ctx2[5];
      if (dirty[0] & /*receiveShadow*/
      64)
        meshinstance_changes.receiveShadow = /*receiveShadow*/
        ctx2[6];
      if (dirty[0] & /*frustumCulled*/
      128)
        meshinstance_changes.frustumCulled = /*frustumCulled*/
        ctx2[7];
      if (dirty[0] & /*renderOrder*/
      256)
        meshinstance_changes.renderOrder = /*renderOrder*/
        ctx2[8];
      if (dirty[0] & /*visible*/
      512)
        meshinstance_changes.visible = /*visible*/
        ctx2[9];
      if (dirty[0] & /*interactive*/
      1024)
        meshinstance_changes.interactive = /*interactive*/
        ctx2[10];
      if (dirty[0] & /*ignorePointer*/
      2048)
        meshinstance_changes.ignorePointer = /*ignorePointer*/
        ctx2[11];
      if (dirty[0] & /*viewportAware*/
      16)
        meshinstance_changes.viewportAware = /*viewportAware*/
        ctx2[4];
      if (dirty[0] & /*$$scope*/
      536870912) {
        meshinstance_changes.$$scope = { dirty, ctx: ctx2 };
      }
      if (!updating_inViewport && dirty[0] & /*inViewport*/
      1) {
        updating_inViewport = true;
        meshinstance_changes.inViewport = /*inViewport*/
        ctx2[0];
        add_flush_callback(() => updating_inViewport = false);
      }
      meshinstance.$set(meshinstance_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(meshinstance.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(meshinstance.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(meshinstance, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment30.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance30($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Mesh", slots, ["default"]);
  let { position = void 0 } = $$props;
  let { scale = void 0 } = $$props;
  let { rotation = void 0 } = $$props;
  let { viewportAware = false } = $$props;
  let { inViewport = false } = $$props;
  let { castShadow = void 0 } = $$props;
  let { receiveShadow = void 0 } = $$props;
  let { frustumCulled = void 0 } = $$props;
  let { renderOrder = void 0 } = $$props;
  let { visible = void 0 } = $$props;
  let { interactive = false } = $$props;
  let { ignorePointer = false } = $$props;
  let { lookAt = void 0 } = $$props;
  let { geometry } = $$props;
  let { material } = $$props;
  let previousMaterial = material;
  let previousGeometry = geometry;
  const { invalidate } = useThrelte();
  const mesh = new Mesh(geometry, material);
  const getMesh = () => mesh;
  $$self.$$.on_mount.push(function() {
    if (geometry === void 0 && !("geometry" in $$props || $$self.$$.bound[$$self.$$.props["geometry"]])) {
      console.warn("<Mesh> was created without expected prop 'geometry'");
    }
    if (material === void 0 && !("material" in $$props || $$self.$$.bound[$$self.$$.props["material"]])) {
      console.warn("<Mesh> was created without expected prop 'material'");
    }
  });
  const writable_props = [
    "position",
    "scale",
    "rotation",
    "viewportAware",
    "inViewport",
    "castShadow",
    "receiveShadow",
    "frustumCulled",
    "renderOrder",
    "visible",
    "interactive",
    "ignorePointer",
    "lookAt",
    "geometry",
    "material"
  ];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<Mesh> was created with unknown prop '${key}'`);
  });
  function meshinstance_inViewport_binding(value) {
    inViewport = value;
    $$invalidate(0, inViewport);
  }
  function click_handler(event) {
    bubble.call(this, $$self, event);
  }
  function contextmenu_handler(event) {
    bubble.call(this, $$self, event);
  }
  function pointerup_handler(event) {
    bubble.call(this, $$self, event);
  }
  function pointerdown_handler(event) {
    bubble.call(this, $$self, event);
  }
  function pointerenter_handler(event) {
    bubble.call(this, $$self, event);
  }
  function pointerleave_handler(event) {
    bubble.call(this, $$self, event);
  }
  function pointermove_handler(event) {
    bubble.call(this, $$self, event);
  }
  function viewportenter_handler(event) {
    bubble.call(this, $$self, event);
  }
  function viewportleave_handler(event) {
    bubble.call(this, $$self, event);
  }
  $$self.$$set = ($$props2) => {
    if ("position" in $$props2)
      $$invalidate(1, position = $$props2.position);
    if ("scale" in $$props2)
      $$invalidate(2, scale = $$props2.scale);
    if ("rotation" in $$props2)
      $$invalidate(3, rotation = $$props2.rotation);
    if ("viewportAware" in $$props2)
      $$invalidate(4, viewportAware = $$props2.viewportAware);
    if ("inViewport" in $$props2)
      $$invalidate(0, inViewport = $$props2.inViewport);
    if ("castShadow" in $$props2)
      $$invalidate(5, castShadow = $$props2.castShadow);
    if ("receiveShadow" in $$props2)
      $$invalidate(6, receiveShadow = $$props2.receiveShadow);
    if ("frustumCulled" in $$props2)
      $$invalidate(7, frustumCulled = $$props2.frustumCulled);
    if ("renderOrder" in $$props2)
      $$invalidate(8, renderOrder = $$props2.renderOrder);
    if ("visible" in $$props2)
      $$invalidate(9, visible = $$props2.visible);
    if ("interactive" in $$props2)
      $$invalidate(10, interactive = $$props2.interactive);
    if ("ignorePointer" in $$props2)
      $$invalidate(11, ignorePointer = $$props2.ignorePointer);
    if ("lookAt" in $$props2)
      $$invalidate(12, lookAt = $$props2.lookAt);
    if ("geometry" in $$props2)
      $$invalidate(14, geometry = $$props2.geometry);
    if ("material" in $$props2)
      $$invalidate(15, material = $$props2.material);
    if ("$$scope" in $$props2)
      $$invalidate(29, $$scope = $$props2.$$scope);
  };
  $$self.$capture_state = () => ({
    ThreeMesh: Mesh,
    useThrelte,
    MeshInstance: MeshInstance_default,
    position,
    scale,
    rotation,
    viewportAware,
    inViewport,
    castShadow,
    receiveShadow,
    frustumCulled,
    renderOrder,
    visible,
    interactive,
    ignorePointer,
    lookAt,
    geometry,
    material,
    previousMaterial,
    previousGeometry,
    invalidate,
    mesh,
    getMesh
  });
  $$self.$inject_state = ($$props2) => {
    if ("position" in $$props2)
      $$invalidate(1, position = $$props2.position);
    if ("scale" in $$props2)
      $$invalidate(2, scale = $$props2.scale);
    if ("rotation" in $$props2)
      $$invalidate(3, rotation = $$props2.rotation);
    if ("viewportAware" in $$props2)
      $$invalidate(4, viewportAware = $$props2.viewportAware);
    if ("inViewport" in $$props2)
      $$invalidate(0, inViewport = $$props2.inViewport);
    if ("castShadow" in $$props2)
      $$invalidate(5, castShadow = $$props2.castShadow);
    if ("receiveShadow" in $$props2)
      $$invalidate(6, receiveShadow = $$props2.receiveShadow);
    if ("frustumCulled" in $$props2)
      $$invalidate(7, frustumCulled = $$props2.frustumCulled);
    if ("renderOrder" in $$props2)
      $$invalidate(8, renderOrder = $$props2.renderOrder);
    if ("visible" in $$props2)
      $$invalidate(9, visible = $$props2.visible);
    if ("interactive" in $$props2)
      $$invalidate(10, interactive = $$props2.interactive);
    if ("ignorePointer" in $$props2)
      $$invalidate(11, ignorePointer = $$props2.ignorePointer);
    if ("lookAt" in $$props2)
      $$invalidate(12, lookAt = $$props2.lookAt);
    if ("geometry" in $$props2)
      $$invalidate(14, geometry = $$props2.geometry);
    if ("material" in $$props2)
      $$invalidate(15, material = $$props2.material);
    if ("previousMaterial" in $$props2)
      $$invalidate(16, previousMaterial = $$props2.previousMaterial);
    if ("previousGeometry" in $$props2)
      $$invalidate(17, previousGeometry = $$props2.previousGeometry);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty[0] & /*material, previousMaterial*/
    98304) {
      $: {
        if (material !== previousMaterial) {
          getMesh().material = material;
          invalidate("Mesh: material changed");
        } else {
          invalidate("Mesh: material props changed");
        }
        $$invalidate(16, previousMaterial = material);
      }
    }
    if ($$self.$$.dirty[0] & /*geometry, previousGeometry*/
    147456) {
      $: {
        if (geometry !== previousGeometry) {
          getMesh().geometry = geometry;
          invalidate("Mesh: geometry changed");
        } else {
          invalidate("Mesh: geometry props changed");
        }
        $$invalidate(17, previousGeometry = geometry);
      }
    }
  };
  return [
    inViewport,
    position,
    scale,
    rotation,
    viewportAware,
    castShadow,
    receiveShadow,
    frustumCulled,
    renderOrder,
    visible,
    interactive,
    ignorePointer,
    lookAt,
    mesh,
    geometry,
    material,
    previousMaterial,
    previousGeometry,
    slots,
    meshinstance_inViewport_binding,
    click_handler,
    contextmenu_handler,
    pointerup_handler,
    pointerdown_handler,
    pointerenter_handler,
    pointerleave_handler,
    pointermove_handler,
    viewportenter_handler,
    viewportleave_handler,
    $$scope
  ];
}
var Mesh2 = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(
      this,
      options,
      instance30,
      create_fragment30,
      safe_not_equal,
      {
        position: 1,
        scale: 2,
        rotation: 3,
        viewportAware: 4,
        inViewport: 0,
        castShadow: 5,
        receiveShadow: 6,
        frustumCulled: 7,
        renderOrder: 8,
        visible: 9,
        interactive: 10,
        ignorePointer: 11,
        lookAt: 12,
        geometry: 14,
        material: 15,
        mesh: 13
      },
      null,
      [-1, -1]
    );
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Mesh",
      options,
      id: create_fragment30.name
    });
  }
  get position() {
    throw new Error("<Mesh>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set position(value) {
    throw new Error("<Mesh>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get scale() {
    throw new Error("<Mesh>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set scale(value) {
    throw new Error("<Mesh>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get rotation() {
    throw new Error("<Mesh>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set rotation(value) {
    throw new Error("<Mesh>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get viewportAware() {
    throw new Error("<Mesh>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set viewportAware(value) {
    throw new Error("<Mesh>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get inViewport() {
    throw new Error("<Mesh>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set inViewport(value) {
    throw new Error("<Mesh>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get castShadow() {
    throw new Error("<Mesh>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set castShadow(value) {
    throw new Error("<Mesh>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get receiveShadow() {
    throw new Error("<Mesh>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set receiveShadow(value) {
    throw new Error("<Mesh>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get frustumCulled() {
    throw new Error("<Mesh>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set frustumCulled(value) {
    throw new Error("<Mesh>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get renderOrder() {
    throw new Error("<Mesh>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set renderOrder(value) {
    throw new Error("<Mesh>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get visible() {
    throw new Error("<Mesh>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set visible(value) {
    throw new Error("<Mesh>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get interactive() {
    throw new Error("<Mesh>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set interactive(value) {
    throw new Error("<Mesh>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get ignorePointer() {
    throw new Error("<Mesh>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set ignorePointer(value) {
    throw new Error("<Mesh>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get lookAt() {
    throw new Error("<Mesh>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set lookAt(value) {
    throw new Error("<Mesh>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get geometry() {
    throw new Error("<Mesh>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set geometry(value) {
    throw new Error("<Mesh>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get material() {
    throw new Error("<Mesh>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set material(value) {
    throw new Error("<Mesh>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get mesh() {
    return this.$$.ctx[13];
  }
  set mesh(value) {
    throw new Error("<Mesh>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Mesh_default = Mesh2;

// node_modules/threlte/lib/usePropChange.js
var usePropChange = (prop, equalityFn) => {
  let oldValue = prop;
  const onChange = (newValue, callback) => {
    if (equalityFn && !equalityFn(newValue, oldValue)) {
      callback(newValue, oldValue);
      oldValue = newValue;
    } else if (!equalityFn && newValue !== oldValue) {
      callback(newValue, oldValue);
      oldValue = newValue;
    }
  };
  return {
    onChange
  };
};

// node_modules/threlte/objects/InstancedMesh.svelte
var { console: console_13 } = globals;
function create_key_block(ctx) {
  let meshinstance;
  let updating_inViewport;
  let current;
  function meshinstance_inViewport_binding(value) {
    ctx[22](value);
  }
  let meshinstance_props = {
    mesh: (
      /*$instancedMesh*/
      ctx[13]
    ),
    castShadow: (
      /*castShadow*/
      ctx[5]
    ),
    receiveShadow: (
      /*receiveShadow*/
      ctx[6]
    ),
    frustumCulled: void 0,
    renderOrder: (
      /*renderOrder*/
      ctx[7]
    ),
    visible: (
      /*visible*/
      ctx[8]
    ),
    interactive: (
      /*interactive*/
      ctx[9]
    ),
    ignorePointer: (
      /*ignorePointer*/
      ctx[10]
    ),
    viewportAware: (
      /*viewportAware*/
      ctx[4]
    )
  };
  if (
    /*inViewport*/
    ctx[0] !== void 0
  ) {
    meshinstance_props.inViewport = /*inViewport*/
    ctx[0];
  }
  meshinstance = new MeshInstance_default({
    props: meshinstance_props,
    $$inline: true
  });
  binding_callbacks.push(() => bind(meshinstance, "inViewport", meshinstance_inViewport_binding));
  meshinstance.$on(
    "click",
    /*onEvent*/
    ctx[16]
  );
  meshinstance.$on(
    "contextmenu",
    /*onEvent*/
    ctx[16]
  );
  meshinstance.$on(
    "pointerup",
    /*onEvent*/
    ctx[16]
  );
  meshinstance.$on(
    "pointerdown",
    /*onEvent*/
    ctx[16]
  );
  meshinstance.$on(
    "pointerenter",
    /*onEvent*/
    ctx[16]
  );
  meshinstance.$on(
    "pointerleave",
    /*onEvent*/
    ctx[16]
  );
  meshinstance.$on(
    "pointermove",
    /*onEvent*/
    ctx[16]
  );
  meshinstance.$on(
    "viewportenter",
    /*viewportenter_handler*/
    ctx[23]
  );
  meshinstance.$on(
    "viewportleave",
    /*viewportleave_handler*/
    ctx[24]
  );
  const block = {
    c: function create() {
      create_component(meshinstance.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(meshinstance.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(meshinstance, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const meshinstance_changes = {};
      if (dirty[0] & /*$instancedMesh*/
      8192)
        meshinstance_changes.mesh = /*$instancedMesh*/
        ctx2[13];
      if (dirty[0] & /*castShadow*/
      32)
        meshinstance_changes.castShadow = /*castShadow*/
        ctx2[5];
      if (dirty[0] & /*receiveShadow*/
      64)
        meshinstance_changes.receiveShadow = /*receiveShadow*/
        ctx2[6];
      if (dirty[0] & /*renderOrder*/
      128)
        meshinstance_changes.renderOrder = /*renderOrder*/
        ctx2[7];
      if (dirty[0] & /*visible*/
      256)
        meshinstance_changes.visible = /*visible*/
        ctx2[8];
      if (dirty[0] & /*interactive*/
      512)
        meshinstance_changes.interactive = /*interactive*/
        ctx2[9];
      if (dirty[0] & /*ignorePointer*/
      1024)
        meshinstance_changes.ignorePointer = /*ignorePointer*/
        ctx2[10];
      if (dirty[0] & /*viewportAware*/
      16)
        meshinstance_changes.viewportAware = /*viewportAware*/
        ctx2[4];
      if (!updating_inViewport && dirty[0] & /*inViewport*/
      1) {
        updating_inViewport = true;
        meshinstance_changes.inViewport = /*inViewport*/
        ctx2[0];
        add_flush_callback(() => updating_inViewport = false);
      }
      meshinstance.$set(meshinstance_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(meshinstance.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(meshinstance.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(meshinstance, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_key_block.name,
    type: "key",
    source: "(179:2) {#key $instancedMesh.uuid}",
    ctx
  });
  return block;
}
function create_default_slot17(ctx) {
  let previous_key = (
    /*$instancedMesh*/
    ctx[13].uuid
  );
  let t2;
  let current;
  let key_block = create_key_block(ctx);
  const default_slot_template = (
    /*#slots*/
    ctx[21].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[25],
    null
  );
  const block = {
    c: function create() {
      key_block.c();
      t2 = space();
      if (default_slot)
        default_slot.c();
    },
    l: function claim(nodes) {
      key_block.l(nodes);
      t2 = claim_space(nodes);
      if (default_slot)
        default_slot.l(nodes);
    },
    m: function mount(target, anchor) {
      key_block.m(target, anchor);
      insert_hydration_dev(target, t2, anchor);
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (dirty[0] & /*$instancedMesh*/
      8192 && safe_not_equal(previous_key, previous_key = /*$instancedMesh*/
      ctx2[13].uuid)) {
        group_outros();
        transition_out(key_block, 1, 1, noop);
        check_outros();
        key_block = create_key_block(ctx2);
        key_block.c();
        transition_in(key_block, 1);
        key_block.m(t2.parentNode, t2);
      } else {
        key_block.p(ctx2, dirty);
      }
      if (default_slot) {
        if (default_slot.p && (!current || dirty[0] & /*$$scope*/
        33554432)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[25],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[25]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[25],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(key_block);
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(key_block);
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      key_block.d(detaching);
      if (detaching)
        detach_dev(t2);
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot17.name,
    type: "slot",
    source: "(178:0) <Object3DInstance object={parentObject} {position} {scale} {rotation} {lookAt}>",
    ctx
  });
  return block;
}
function create_fragment31(ctx) {
  let object3dinstance;
  let current;
  object3dinstance = new Object3DInstance_default({
    props: {
      object: (
        /*parentObject*/
        ctx[14]
      ),
      position: (
        /*position*/
        ctx[1]
      ),
      scale: (
        /*scale*/
        ctx[2]
      ),
      rotation: (
        /*rotation*/
        ctx[3]
      ),
      lookAt: (
        /*lookAt*/
        ctx[11]
      ),
      $$slots: { default: [create_default_slot17] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(object3dinstance.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(object3dinstance.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(object3dinstance, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const object3dinstance_changes = {};
      if (dirty[0] & /*position*/
      2)
        object3dinstance_changes.position = /*position*/
        ctx2[1];
      if (dirty[0] & /*scale*/
      4)
        object3dinstance_changes.scale = /*scale*/
        ctx2[2];
      if (dirty[0] & /*rotation*/
      8)
        object3dinstance_changes.rotation = /*rotation*/
        ctx2[3];
      if (dirty[0] & /*lookAt*/
      2048)
        object3dinstance_changes.lookAt = /*lookAt*/
        ctx2[11];
      if (dirty[0] & /*$$scope, $instancedMesh, castShadow, receiveShadow, renderOrder, visible, interactive, ignorePointer, viewportAware, inViewport*/
      33564657) {
        object3dinstance_changes.$$scope = { dirty, ctx: ctx2 };
      }
      object3dinstance.$set(object3dinstance_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(object3dinstance.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(object3dinstance.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(object3dinstance, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment31.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
var placeholderObject3D = new Object3D();
placeholderObject3D.scale.set(0, 0, 0);
var placeholderInstance = {
  matrix: placeholderObject3D.matrix,
  color: null
};
var emptyM4 = new Matrix4().fromArray(new Array(16).fill(0));
var defaultColor = new Color(16777215);
var instancedMeshContextName = "threlte-instanced-mesh-context";
var useInstancedMesh = (id) => {
  return getContext(instancedMeshContextName + id);
};
function instance31($$self, $$props, $$invalidate) {
  let $instancedMesh, $$unsubscribe_instancedMesh = noop, $$subscribe_instancedMesh = () => ($$unsubscribe_instancedMesh(), $$unsubscribe_instancedMesh = subscribe(instancedMesh, ($$value) => $$invalidate(13, $instancedMesh = $$value)), instancedMesh);
  let $instanceCountChangeHandlerQueued;
  $$self.$$.on_destroy.push(() => $$unsubscribe_instancedMesh());
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("InstancedMesh", slots, ["default"]);
  let { position = void 0 } = $$props;
  let { scale = void 0 } = $$props;
  let { rotation = void 0 } = $$props;
  let { viewportAware = false } = $$props;
  let { inViewport = false } = $$props;
  let { castShadow = void 0 } = $$props;
  let { receiveShadow = void 0 } = $$props;
  let { renderOrder = void 0 } = $$props;
  let { visible = void 0 } = $$props;
  let { interactive = false } = $$props;
  let { ignorePointer = false } = $$props;
  let { lookAt = void 0 } = $$props;
  let { geometry } = $$props;
  let { material } = $$props;
  let { count = void 0 } = $$props;
  let { id = "" } = $$props;
  const { onChange } = usePropChange(material);
  let autoCount = count === void 0;
  const instancedMesh = writable(new InstancedMesh(geometry, material, autoCount ? 0 : count));
  validate_store(instancedMesh, "instancedMesh");
  $$subscribe_instancedMesh();
  const parentObject = new Object3D();
  const instances = [];
  const { invalidate } = useThrelte();
  const useInstanceIndex = (instance40, callback) => {
    const index = instances.findIndex((i) => i === instance40);
    if (index === -1) {
      console.warn("Instanced Mesh: Instance not found");
      return;
    }
    callback(index);
  };
  const { start: queueHandleInstanceCountChange, stop, started: instanceCountChangeHandlerQueued } = useFrame(
    () => {
      $instancedMesh.dispose();
      set_store_value(instancedMesh, $instancedMesh = new InstancedMesh(geometry, material, instances.length), $instancedMesh);
      instances.forEach((instance40, index) => {
        setInstanceMatrixByIndex(instance40, index);
        if (instance40.color) {
          $instancedMesh.setColorAt(index, instance40.color);
        } else {
          $instancedMesh.setColorAt(index, defaultColor);
        }
      });
      set_store_value(instancedMesh, $instancedMesh.instanceMatrix.needsUpdate = true, $instancedMesh);
      if ($instancedMesh.instanceColor) {
        set_store_value(instancedMesh, $instancedMesh.instanceColor.needsUpdate = true, $instancedMesh);
      }
      stop();
    },
    {
      autostart: false,
      debugFrameloopMessage: "Instanced Mesh: auto instance count change queued"
    }
  );
  validate_store(instanceCountChangeHandlerQueued, "instanceCountChangeHandlerQueued");
  component_subscribe($$self, instanceCountChangeHandlerQueued, (value) => $$invalidate(28, $instanceCountChangeHandlerQueued = value));
  const registerInstance = (instance40) => {
    if (autoCount) {
      instances.push(instance40);
      if (!$instanceCountChangeHandlerQueued)
        queueHandleInstanceCountChange();
    } else {
      const firstPlaceholderInstanceIndex = instances.findIndex((i) => i === placeholderInstance);
      if (firstPlaceholderInstanceIndex !== -1) {
        instances[firstPlaceholderInstanceIndex] = instance40;
      } else {
        instances.push(instance40);
      }
      if (instances.length > count) {
        console.warn("Instanced Mesh: More instances requested than allocated, increase count on <");
      }
    }
    setDefaultInstanceColor(instance40);
    invalidate("Instanced Mesh: Instance added");
  };
  const removeInstance = (instance40) => {
    if (autoCount) {
      const index = instances.findIndex((i) => i === instance40);
      instances.splice(index, 1);
      if (!$instanceCountChangeHandlerQueued)
        queueHandleInstanceCountChange();
    } else {
      resetInstanceMatrix(instance40);
      const index = instances.findIndex((i) => i === instance40);
      if (index >= count) {
        instances.splice(index, 1);
      } else {
        instances.splice(index, 1, placeholderInstance);
      }
    }
    invalidate("Instanced Mesh: Instance removed");
  };
  const setDefaultInstanceColor = (instance40) => {
    if (instance40.color)
      return;
    useInstanceIndex(instance40, (index) => {
      $instancedMesh.setColorAt(index, defaultColor);
      if ($instancedMesh.instanceColor)
        set_store_value(instancedMesh, $instancedMesh.instanceColor.needsUpdate = true, $instancedMesh);
    });
  };
  const resetInstanceMatrix = (instance40) => {
    useInstanceIndex(instance40, (index) => {
      $instancedMesh.setMatrixAt(index, emptyM4);
      set_store_value(instancedMesh, $instancedMesh.instanceMatrix.needsUpdate = true, $instancedMesh);
      invalidate("Instanced Mesh: instance matrix resetted");
    });
  };
  const setInstanceMatrixByIndex = (instance40, index) => {
    $instancedMesh.setMatrixAt(index, instance40.matrix);
    set_store_value(instancedMesh, $instancedMesh.instanceMatrix.needsUpdate = true, $instancedMesh);
    invalidate("Instanced Mesh: instance matrix set");
  };
  const setInstanceMatrix = (instance40) => {
    useInstanceIndex(instance40, (index) => {
      setInstanceMatrixByIndex(instance40, index);
    });
  };
  const setInstanceColor = (instance40) => {
    useInstanceIndex(instance40, (index) => {
      $instancedMesh.setColorAt(index, instance40.color ?? defaultColor);
      if ($instancedMesh.instanceColor)
        set_store_value(instancedMesh, $instancedMesh.instanceColor.needsUpdate = true, $instancedMesh);
      invalidate("Instanced Mesh: instance color set");
    });
  };
  setContext(instancedMeshContextName + id, {
    registerInstance,
    removeInstance,
    setInstanceMatrix,
    setInstanceColor,
    parentObject
  });
  const onEvent = (e) => {
    const instance40 = instances[e.detail.instanceId];
    if (instance40 && instance40.pointerEventDispatcher) {
      instance40.pointerEventDispatcher(e.type, e.detail);
    }
  };
  $$self.$$.on_mount.push(function() {
    if (geometry === void 0 && !("geometry" in $$props || $$self.$$.bound[$$self.$$.props["geometry"]])) {
      console_13.warn("<InstancedMesh> was created without expected prop 'geometry'");
    }
    if (material === void 0 && !("material" in $$props || $$self.$$.bound[$$self.$$.props["material"]])) {
      console_13.warn("<InstancedMesh> was created without expected prop 'material'");
    }
  });
  const writable_props = [
    "position",
    "scale",
    "rotation",
    "viewportAware",
    "inViewport",
    "castShadow",
    "receiveShadow",
    "renderOrder",
    "visible",
    "interactive",
    "ignorePointer",
    "lookAt",
    "geometry",
    "material",
    "count",
    "id"
  ];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console_13.warn(`<InstancedMesh> was created with unknown prop '${key}'`);
  });
  function meshinstance_inViewport_binding(value) {
    inViewport = value;
    $$invalidate(0, inViewport);
  }
  function viewportenter_handler(event) {
    bubble.call(this, $$self, event);
  }
  function viewportleave_handler(event) {
    bubble.call(this, $$self, event);
  }
  $$self.$$set = ($$props2) => {
    if ("position" in $$props2)
      $$invalidate(1, position = $$props2.position);
    if ("scale" in $$props2)
      $$invalidate(2, scale = $$props2.scale);
    if ("rotation" in $$props2)
      $$invalidate(3, rotation = $$props2.rotation);
    if ("viewportAware" in $$props2)
      $$invalidate(4, viewportAware = $$props2.viewportAware);
    if ("inViewport" in $$props2)
      $$invalidate(0, inViewport = $$props2.inViewport);
    if ("castShadow" in $$props2)
      $$invalidate(5, castShadow = $$props2.castShadow);
    if ("receiveShadow" in $$props2)
      $$invalidate(6, receiveShadow = $$props2.receiveShadow);
    if ("renderOrder" in $$props2)
      $$invalidate(7, renderOrder = $$props2.renderOrder);
    if ("visible" in $$props2)
      $$invalidate(8, visible = $$props2.visible);
    if ("interactive" in $$props2)
      $$invalidate(9, interactive = $$props2.interactive);
    if ("ignorePointer" in $$props2)
      $$invalidate(10, ignorePointer = $$props2.ignorePointer);
    if ("lookAt" in $$props2)
      $$invalidate(11, lookAt = $$props2.lookAt);
    if ("geometry" in $$props2)
      $$invalidate(17, geometry = $$props2.geometry);
    if ("material" in $$props2)
      $$invalidate(18, material = $$props2.material);
    if ("count" in $$props2)
      $$invalidate(19, count = $$props2.count);
    if ("id" in $$props2)
      $$invalidate(20, id = $$props2.id);
    if ("$$scope" in $$props2)
      $$invalidate(25, $$scope = $$props2.$$scope);
  };
  $$self.$capture_state = () => ({
    getContext,
    setContext,
    Color,
    ThreeInstancedMesh: InstancedMesh,
    Matrix4,
    Object3D,
    useThrelte,
    useFrame,
    MeshInstance: MeshInstance_default,
    usePropChange,
    Object3DInstance: Object3DInstance_default,
    writable,
    placeholderObject3D,
    placeholderInstance,
    emptyM4,
    defaultColor,
    instancedMeshContextName,
    useInstancedMesh,
    position,
    scale,
    rotation,
    viewportAware,
    inViewport,
    castShadow,
    receiveShadow,
    renderOrder,
    visible,
    interactive,
    ignorePointer,
    lookAt,
    geometry,
    material,
    count,
    id,
    onChange,
    autoCount,
    instancedMesh,
    parentObject,
    instances,
    invalidate,
    useInstanceIndex,
    queueHandleInstanceCountChange,
    stop,
    instanceCountChangeHandlerQueued,
    registerInstance,
    removeInstance,
    setDefaultInstanceColor,
    resetInstanceMatrix,
    setInstanceMatrixByIndex,
    setInstanceMatrix,
    setInstanceColor,
    onEvent,
    $instancedMesh,
    $instanceCountChangeHandlerQueued
  });
  $$self.$inject_state = ($$props2) => {
    if ("position" in $$props2)
      $$invalidate(1, position = $$props2.position);
    if ("scale" in $$props2)
      $$invalidate(2, scale = $$props2.scale);
    if ("rotation" in $$props2)
      $$invalidate(3, rotation = $$props2.rotation);
    if ("viewportAware" in $$props2)
      $$invalidate(4, viewportAware = $$props2.viewportAware);
    if ("inViewport" in $$props2)
      $$invalidate(0, inViewport = $$props2.inViewport);
    if ("castShadow" in $$props2)
      $$invalidate(5, castShadow = $$props2.castShadow);
    if ("receiveShadow" in $$props2)
      $$invalidate(6, receiveShadow = $$props2.receiveShadow);
    if ("renderOrder" in $$props2)
      $$invalidate(7, renderOrder = $$props2.renderOrder);
    if ("visible" in $$props2)
      $$invalidate(8, visible = $$props2.visible);
    if ("interactive" in $$props2)
      $$invalidate(9, interactive = $$props2.interactive);
    if ("ignorePointer" in $$props2)
      $$invalidate(10, ignorePointer = $$props2.ignorePointer);
    if ("lookAt" in $$props2)
      $$invalidate(11, lookAt = $$props2.lookAt);
    if ("geometry" in $$props2)
      $$invalidate(17, geometry = $$props2.geometry);
    if ("material" in $$props2)
      $$invalidate(18, material = $$props2.material);
    if ("count" in $$props2)
      $$invalidate(19, count = $$props2.count);
    if ("id" in $$props2)
      $$invalidate(20, id = $$props2.id);
    if ("autoCount" in $$props2)
      autoCount = $$props2.autoCount;
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty[0] & /*material*/
    262144) {
      $:
        onChange(material, (newMaterial) => {
          set_store_value(instancedMesh, $instancedMesh.material = newMaterial, $instancedMesh);
        });
    }
    if ($$self.$$.dirty[0] & /*count*/
    524288) {
      $:
        autoCount = count === void 0;
    }
  };
  return [
    inViewport,
    position,
    scale,
    rotation,
    viewportAware,
    castShadow,
    receiveShadow,
    renderOrder,
    visible,
    interactive,
    ignorePointer,
    lookAt,
    instancedMesh,
    $instancedMesh,
    parentObject,
    instanceCountChangeHandlerQueued,
    onEvent,
    geometry,
    material,
    count,
    id,
    slots,
    meshinstance_inViewport_binding,
    viewportenter_handler,
    viewportleave_handler,
    $$scope
  ];
}
var InstancedMesh2 = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(
      this,
      options,
      instance31,
      create_fragment31,
      safe_not_equal,
      {
        position: 1,
        scale: 2,
        rotation: 3,
        viewportAware: 4,
        inViewport: 0,
        castShadow: 5,
        receiveShadow: 6,
        renderOrder: 7,
        visible: 8,
        interactive: 9,
        ignorePointer: 10,
        lookAt: 11,
        geometry: 17,
        material: 18,
        count: 19,
        id: 20,
        instancedMesh: 12
      },
      null,
      [-1, -1]
    );
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "InstancedMesh",
      options,
      id: create_fragment31.name
    });
  }
  get position() {
    throw new Error("<InstancedMesh>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set position(value) {
    throw new Error("<InstancedMesh>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get scale() {
    throw new Error("<InstancedMesh>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set scale(value) {
    throw new Error("<InstancedMesh>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get rotation() {
    throw new Error("<InstancedMesh>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set rotation(value) {
    throw new Error("<InstancedMesh>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get viewportAware() {
    throw new Error("<InstancedMesh>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set viewportAware(value) {
    throw new Error("<InstancedMesh>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get inViewport() {
    throw new Error("<InstancedMesh>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set inViewport(value) {
    throw new Error("<InstancedMesh>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get castShadow() {
    throw new Error("<InstancedMesh>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set castShadow(value) {
    throw new Error("<InstancedMesh>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get receiveShadow() {
    throw new Error("<InstancedMesh>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set receiveShadow(value) {
    throw new Error("<InstancedMesh>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get renderOrder() {
    throw new Error("<InstancedMesh>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set renderOrder(value) {
    throw new Error("<InstancedMesh>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get visible() {
    throw new Error("<InstancedMesh>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set visible(value) {
    throw new Error("<InstancedMesh>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get interactive() {
    throw new Error("<InstancedMesh>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set interactive(value) {
    throw new Error("<InstancedMesh>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get ignorePointer() {
    throw new Error("<InstancedMesh>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set ignorePointer(value) {
    throw new Error("<InstancedMesh>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get lookAt() {
    throw new Error("<InstancedMesh>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set lookAt(value) {
    throw new Error("<InstancedMesh>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get geometry() {
    throw new Error("<InstancedMesh>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set geometry(value) {
    throw new Error("<InstancedMesh>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get material() {
    throw new Error("<InstancedMesh>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set material(value) {
    throw new Error("<InstancedMesh>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get count() {
    throw new Error("<InstancedMesh>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set count(value) {
    throw new Error("<InstancedMesh>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get id() {
    throw new Error("<InstancedMesh>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set id(value) {
    throw new Error("<InstancedMesh>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get instancedMesh() {
    return this.$$.ctx[12];
  }
  set instancedMesh(value) {
    throw new Error("<InstancedMesh>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var InstancedMesh_default = InstancedMesh2;

// node_modules/threlte/objects/Instance.svelte
function create_default_slot18(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[8].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[9],
    null
  );
  const block = {
    c: function create() {
      if (default_slot)
        default_slot.c();
    },
    l: function claim(nodes) {
      if (default_slot)
        default_slot.l(nodes);
    },
    m: function mount(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        512)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[9],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[9]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[9],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot18.name,
    type: "slot",
    source: "(85:0) <HierarchicalObject object={object3d}>",
    ctx
  });
  return block;
}
function create_fragment32(ctx) {
  let hierarchicalobject;
  let t2;
  let transformableobject;
  let current;
  hierarchicalobject = new HierarchicalObject_default({
    props: {
      object: (
        /*object3d*/
        ctx[4]
      ),
      $$slots: { default: [create_default_slot18] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  transformableobject = new TransformableObject_default({
    props: {
      object: (
        /*object3d*/
        ctx[4]
      ),
      position: (
        /*position*/
        ctx[0]
      ),
      scale: (
        /*scale*/
        ctx[1]
      ),
      rotation: (
        /*rotation*/
        ctx[2]
      ),
      lookAt: (
        /*lookAt*/
        ctx[3]
      )
    },
    $$inline: true
  });
  transformableobject.$on(
    "transform",
    /*onTransform*/
    ctx[5]
  );
  const block = {
    c: function create() {
      create_component(hierarchicalobject.$$.fragment);
      t2 = space();
      create_component(transformableobject.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(hierarchicalobject.$$.fragment, nodes);
      t2 = claim_space(nodes);
      claim_component(transformableobject.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(hierarchicalobject, target, anchor);
      insert_hydration_dev(target, t2, anchor);
      mount_component(transformableobject, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const hierarchicalobject_changes = {};
      if (dirty & /*$$scope*/
      512) {
        hierarchicalobject_changes.$$scope = { dirty, ctx: ctx2 };
      }
      hierarchicalobject.$set(hierarchicalobject_changes);
      const transformableobject_changes = {};
      if (dirty & /*position*/
      1)
        transformableobject_changes.position = /*position*/
        ctx2[0];
      if (dirty & /*scale*/
      2)
        transformableobject_changes.scale = /*scale*/
        ctx2[1];
      if (dirty & /*rotation*/
      4)
        transformableobject_changes.rotation = /*rotation*/
        ctx2[2];
      if (dirty & /*lookAt*/
      8)
        transformableobject_changes.lookAt = /*lookAt*/
        ctx2[3];
      transformableobject.$set(transformableobject_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(hierarchicalobject.$$.fragment, local);
      transition_in(transformableobject.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(hierarchicalobject.$$.fragment, local);
      transition_out(transformableobject.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(hierarchicalobject, detaching);
      if (detaching)
        detach_dev(t2);
      destroy_component(transformableobject, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment32.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance_1($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Instance", slots, ["default"]);
  let { position = void 0 } = $$props;
  let { scale = void 0 } = $$props;
  let { rotation = void 0 } = $$props;
  let { lookAt = void 0 } = $$props;
  let { color = void 0 } = $$props;
  let { id = "" } = $$props;
  const { registerInstance, setInstanceMatrix, removeInstance, setInstanceColor, parentObject } = useInstancedMesh(id);
  const object3d = new Object3D();
  const m4 = new Matrix4();
  const pointerEventDispatcher = createEventDispatcher();
  const isDirectChild = () => {
    var _a;
    return parentObject.uuid === ((_a = object3d.parent) == null ? void 0 : _a.uuid);
  };
  const parseColor = (color2) => {
    return color2 !== void 0 ? color2 instanceof Color ? color2 : new Color(color2) : null;
  };
  const instance40 = {
    color: parseColor(color),
    matrix: object3d.matrix,
    pointerEventDispatcher
  };
  const setColor = (color2) => {
    instance40.color = parseColor(color2);
    setInstanceColor(instance40);
  };
  const prepareNonDirectChildMatrix = () => {
    let currentObj = object3d.parent;
    const interjacentObjects = [];
    while (currentObj && parentObject && currentObj.uuid !== parentObject.uuid) {
      interjacentObjects.push(currentObj);
      if (!currentObj.parent)
        break;
      currentObj = currentObj.parent;
    }
    object3d.updateMatrix();
    m4.copy(object3d.matrix);
    interjacentObjects.forEach((obj) => {
      obj.updateMatrix();
      m4.premultiply(obj.matrix);
    });
    instance40.matrix = m4;
  };
  const prepareDirectChildMatrix = () => {
    object3d.updateMatrix();
    instance40.matrix = object3d.matrix;
  };
  const setDirectChildInstanceTransform = () => {
    prepareDirectChildMatrix();
    setInstanceMatrix(instance40);
  };
  const { start: trackNonDirectChildInstanceTransform } = useFrame(
    () => {
      prepareNonDirectChildMatrix();
      setInstanceMatrix(instance40);
    },
    {
      autostart: false,
      debugFrameloopMessage: "Instance: tracking non-direct child instance"
    }
  );
  registerInstance(instance40);
  onMount(() => {
    if (isDirectChild())
      setDirectChildInstanceTransform();
    else
      trackNonDirectChildInstanceTransform();
    setColor(color);
  });
  const onTransform = () => {
    if (isDirectChild())
      setDirectChildInstanceTransform();
  };
  onDestroy(() => {
    removeInstance(instance40);
  });
  const writable_props = ["position", "scale", "rotation", "lookAt", "color", "id"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<Instance> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("position" in $$props2)
      $$invalidate(0, position = $$props2.position);
    if ("scale" in $$props2)
      $$invalidate(1, scale = $$props2.scale);
    if ("rotation" in $$props2)
      $$invalidate(2, rotation = $$props2.rotation);
    if ("lookAt" in $$props2)
      $$invalidate(3, lookAt = $$props2.lookAt);
    if ("color" in $$props2)
      $$invalidate(6, color = $$props2.color);
    if ("id" in $$props2)
      $$invalidate(7, id = $$props2.id);
    if ("$$scope" in $$props2)
      $$invalidate(9, $$scope = $$props2.$$scope);
  };
  $$self.$capture_state = () => ({
    createEventDispatcher,
    onDestroy,
    onMount,
    Color,
    Matrix4,
    Object3D,
    useFrame,
    HierarchicalObject: HierarchicalObject_default,
    TransformableObject: TransformableObject_default,
    useInstancedMesh,
    position,
    scale,
    rotation,
    lookAt,
    color,
    id,
    registerInstance,
    setInstanceMatrix,
    removeInstance,
    setInstanceColor,
    parentObject,
    object3d,
    m4,
    pointerEventDispatcher,
    isDirectChild,
    parseColor,
    instance: instance40,
    setColor,
    prepareNonDirectChildMatrix,
    prepareDirectChildMatrix,
    setDirectChildInstanceTransform,
    trackNonDirectChildInstanceTransform,
    onTransform
  });
  $$self.$inject_state = ($$props2) => {
    if ("position" in $$props2)
      $$invalidate(0, position = $$props2.position);
    if ("scale" in $$props2)
      $$invalidate(1, scale = $$props2.scale);
    if ("rotation" in $$props2)
      $$invalidate(2, rotation = $$props2.rotation);
    if ("lookAt" in $$props2)
      $$invalidate(3, lookAt = $$props2.lookAt);
    if ("color" in $$props2)
      $$invalidate(6, color = $$props2.color);
    if ("id" in $$props2)
      $$invalidate(7, id = $$props2.id);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*color*/
    64) {
      $:
        setColor(color);
    }
  };
  return [
    position,
    scale,
    rotation,
    lookAt,
    object3d,
    onTransform,
    color,
    id,
    slots,
    $$scope
  ];
}
var Instance = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance_1, create_fragment32, safe_not_equal, {
      position: 0,
      scale: 1,
      rotation: 2,
      lookAt: 3,
      color: 6,
      id: 7
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Instance",
      options,
      id: create_fragment32.name
    });
  }
  get position() {
    throw new Error("<Instance>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set position(value) {
    throw new Error("<Instance>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get scale() {
    throw new Error("<Instance>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set scale(value) {
    throw new Error("<Instance>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get rotation() {
    throw new Error("<Instance>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set rotation(value) {
    throw new Error("<Instance>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get lookAt() {
    throw new Error("<Instance>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set lookAt(value) {
    throw new Error("<Instance>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get color() {
    throw new Error("<Instance>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set color(value) {
    throw new Error("<Instance>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get id() {
    throw new Error("<Instance>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set id(value) {
    throw new Error("<Instance>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Instance_default = Instance;

// node_modules/threlte/objects/Group.svelte
function create_default_slot19(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[12].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[16],
    null
  );
  const block = {
    c: function create() {
      if (default_slot)
        default_slot.c();
    },
    l: function claim(nodes) {
      if (default_slot)
        default_slot.l(nodes);
    },
    m: function mount(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        65536)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[16],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[16]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[16],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot19.name,
    type: "slot",
    source: "(17:0) <Object3DInstance   object={group}   {position}   {scale}   {rotation}   {lookAt}   {frustumCulled}   {renderOrder}   {visible}   {castShadow}   {receiveShadow}   {viewportAware}   bind:inViewport   on:viewportenter   on:viewportleave >",
    ctx
  });
  return block;
}
function create_fragment33(ctx) {
  let object3dinstance;
  let updating_inViewport;
  let current;
  function object3dinstance_inViewport_binding(value) {
    ctx[13](value);
  }
  let object3dinstance_props = {
    object: (
      /*group*/
      ctx[11]
    ),
    position: (
      /*position*/
      ctx[1]
    ),
    scale: (
      /*scale*/
      ctx[2]
    ),
    rotation: (
      /*rotation*/
      ctx[3]
    ),
    lookAt: (
      /*lookAt*/
      ctx[4]
    ),
    frustumCulled: (
      /*frustumCulled*/
      ctx[8]
    ),
    renderOrder: (
      /*renderOrder*/
      ctx[9]
    ),
    visible: (
      /*visible*/
      ctx[10]
    ),
    castShadow: (
      /*castShadow*/
      ctx[6]
    ),
    receiveShadow: (
      /*receiveShadow*/
      ctx[7]
    ),
    viewportAware: (
      /*viewportAware*/
      ctx[5]
    ),
    $$slots: { default: [create_default_slot19] },
    $$scope: { ctx }
  };
  if (
    /*inViewport*/
    ctx[0] !== void 0
  ) {
    object3dinstance_props.inViewport = /*inViewport*/
    ctx[0];
  }
  object3dinstance = new Object3DInstance_default({
    props: object3dinstance_props,
    $$inline: true
  });
  binding_callbacks.push(() => bind(object3dinstance, "inViewport", object3dinstance_inViewport_binding));
  object3dinstance.$on(
    "viewportenter",
    /*viewportenter_handler*/
    ctx[14]
  );
  object3dinstance.$on(
    "viewportleave",
    /*viewportleave_handler*/
    ctx[15]
  );
  const block = {
    c: function create() {
      create_component(object3dinstance.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(object3dinstance.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(object3dinstance, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const object3dinstance_changes = {};
      if (dirty & /*position*/
      2)
        object3dinstance_changes.position = /*position*/
        ctx2[1];
      if (dirty & /*scale*/
      4)
        object3dinstance_changes.scale = /*scale*/
        ctx2[2];
      if (dirty & /*rotation*/
      8)
        object3dinstance_changes.rotation = /*rotation*/
        ctx2[3];
      if (dirty & /*lookAt*/
      16)
        object3dinstance_changes.lookAt = /*lookAt*/
        ctx2[4];
      if (dirty & /*frustumCulled*/
      256)
        object3dinstance_changes.frustumCulled = /*frustumCulled*/
        ctx2[8];
      if (dirty & /*renderOrder*/
      512)
        object3dinstance_changes.renderOrder = /*renderOrder*/
        ctx2[9];
      if (dirty & /*visible*/
      1024)
        object3dinstance_changes.visible = /*visible*/
        ctx2[10];
      if (dirty & /*castShadow*/
      64)
        object3dinstance_changes.castShadow = /*castShadow*/
        ctx2[6];
      if (dirty & /*receiveShadow*/
      128)
        object3dinstance_changes.receiveShadow = /*receiveShadow*/
        ctx2[7];
      if (dirty & /*viewportAware*/
      32)
        object3dinstance_changes.viewportAware = /*viewportAware*/
        ctx2[5];
      if (dirty & /*$$scope*/
      65536) {
        object3dinstance_changes.$$scope = { dirty, ctx: ctx2 };
      }
      if (!updating_inViewport && dirty & /*inViewport*/
      1) {
        updating_inViewport = true;
        object3dinstance_changes.inViewport = /*inViewport*/
        ctx2[0];
        add_flush_callback(() => updating_inViewport = false);
      }
      object3dinstance.$set(object3dinstance_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(object3dinstance.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(object3dinstance.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(object3dinstance, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment33.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance32($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Group", slots, ["default"]);
  let { position = void 0 } = $$props;
  let { scale = void 0 } = $$props;
  let { rotation = void 0 } = $$props;
  let { lookAt = void 0 } = $$props;
  let { viewportAware = false } = $$props;
  let { inViewport = false } = $$props;
  let { castShadow = void 0 } = $$props;
  let { receiveShadow = void 0 } = $$props;
  let { frustumCulled = void 0 } = $$props;
  let { renderOrder = void 0 } = $$props;
  let { visible = void 0 } = $$props;
  const group = new Group();
  const writable_props = [
    "position",
    "scale",
    "rotation",
    "lookAt",
    "viewportAware",
    "inViewport",
    "castShadow",
    "receiveShadow",
    "frustumCulled",
    "renderOrder",
    "visible"
  ];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<Group> was created with unknown prop '${key}'`);
  });
  function object3dinstance_inViewport_binding(value) {
    inViewport = value;
    $$invalidate(0, inViewport);
  }
  function viewportenter_handler(event) {
    bubble.call(this, $$self, event);
  }
  function viewportleave_handler(event) {
    bubble.call(this, $$self, event);
  }
  $$self.$$set = ($$props2) => {
    if ("position" in $$props2)
      $$invalidate(1, position = $$props2.position);
    if ("scale" in $$props2)
      $$invalidate(2, scale = $$props2.scale);
    if ("rotation" in $$props2)
      $$invalidate(3, rotation = $$props2.rotation);
    if ("lookAt" in $$props2)
      $$invalidate(4, lookAt = $$props2.lookAt);
    if ("viewportAware" in $$props2)
      $$invalidate(5, viewportAware = $$props2.viewportAware);
    if ("inViewport" in $$props2)
      $$invalidate(0, inViewport = $$props2.inViewport);
    if ("castShadow" in $$props2)
      $$invalidate(6, castShadow = $$props2.castShadow);
    if ("receiveShadow" in $$props2)
      $$invalidate(7, receiveShadow = $$props2.receiveShadow);
    if ("frustumCulled" in $$props2)
      $$invalidate(8, frustumCulled = $$props2.frustumCulled);
    if ("renderOrder" in $$props2)
      $$invalidate(9, renderOrder = $$props2.renderOrder);
    if ("visible" in $$props2)
      $$invalidate(10, visible = $$props2.visible);
    if ("$$scope" in $$props2)
      $$invalidate(16, $$scope = $$props2.$$scope);
  };
  $$self.$capture_state = () => ({
    ThreeGroup: Group,
    Object3DInstance: Object3DInstance_default,
    position,
    scale,
    rotation,
    lookAt,
    viewportAware,
    inViewport,
    castShadow,
    receiveShadow,
    frustumCulled,
    renderOrder,
    visible,
    group
  });
  $$self.$inject_state = ($$props2) => {
    if ("position" in $$props2)
      $$invalidate(1, position = $$props2.position);
    if ("scale" in $$props2)
      $$invalidate(2, scale = $$props2.scale);
    if ("rotation" in $$props2)
      $$invalidate(3, rotation = $$props2.rotation);
    if ("lookAt" in $$props2)
      $$invalidate(4, lookAt = $$props2.lookAt);
    if ("viewportAware" in $$props2)
      $$invalidate(5, viewportAware = $$props2.viewportAware);
    if ("inViewport" in $$props2)
      $$invalidate(0, inViewport = $$props2.inViewport);
    if ("castShadow" in $$props2)
      $$invalidate(6, castShadow = $$props2.castShadow);
    if ("receiveShadow" in $$props2)
      $$invalidate(7, receiveShadow = $$props2.receiveShadow);
    if ("frustumCulled" in $$props2)
      $$invalidate(8, frustumCulled = $$props2.frustumCulled);
    if ("renderOrder" in $$props2)
      $$invalidate(9, renderOrder = $$props2.renderOrder);
    if ("visible" in $$props2)
      $$invalidate(10, visible = $$props2.visible);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [
    inViewport,
    position,
    scale,
    rotation,
    lookAt,
    viewportAware,
    castShadow,
    receiveShadow,
    frustumCulled,
    renderOrder,
    visible,
    group,
    slots,
    object3dinstance_inViewport_binding,
    viewportenter_handler,
    viewportleave_handler,
    $$scope
  ];
}
var Group2 = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance32, create_fragment33, safe_not_equal, {
      position: 1,
      scale: 2,
      rotation: 3,
      lookAt: 4,
      viewportAware: 5,
      inViewport: 0,
      castShadow: 6,
      receiveShadow: 7,
      frustumCulled: 8,
      renderOrder: 9,
      visible: 10,
      group: 11
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Group",
      options,
      id: create_fragment33.name
    });
  }
  get position() {
    throw new Error("<Group>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set position(value) {
    throw new Error("<Group>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get scale() {
    throw new Error("<Group>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set scale(value) {
    throw new Error("<Group>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get rotation() {
    throw new Error("<Group>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set rotation(value) {
    throw new Error("<Group>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get lookAt() {
    throw new Error("<Group>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set lookAt(value) {
    throw new Error("<Group>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get viewportAware() {
    throw new Error("<Group>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set viewportAware(value) {
    throw new Error("<Group>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get inViewport() {
    throw new Error("<Group>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set inViewport(value) {
    throw new Error("<Group>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get castShadow() {
    throw new Error("<Group>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set castShadow(value) {
    throw new Error("<Group>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get receiveShadow() {
    throw new Error("<Group>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set receiveShadow(value) {
    throw new Error("<Group>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get frustumCulled() {
    throw new Error("<Group>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set frustumCulled(value) {
    throw new Error("<Group>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get renderOrder() {
    throw new Error("<Group>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set renderOrder(value) {
    throw new Error("<Group>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get visible() {
    throw new Error("<Group>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set visible(value) {
    throw new Error("<Group>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get group() {
    return this.$$.ctx[11];
  }
  set group(value) {
    throw new Error("<Group>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Group_default = Group2;

// node_modules/threlte/objects/Object3D.svelte
function create_default_slot20(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[12].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[16],
    null
  );
  const block = {
    c: function create() {
      if (default_slot)
        default_slot.c();
    },
    l: function claim(nodes) {
      if (default_slot)
        default_slot.l(nodes);
    },
    m: function mount(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        65536)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[16],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[16]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[16],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot20.name,
    type: "slot",
    source: "(18:0) <Object3DInstance   {object}   {position}   {scale}   {rotation}   {lookAt}   {frustumCulled}   {renderOrder}   {visible}   {castShadow}   {receiveShadow}   {viewportAware}   bind:inViewport   on:viewportenter   on:viewportleave >",
    ctx
  });
  return block;
}
function create_fragment34(ctx) {
  let object3dinstance;
  let updating_inViewport;
  let current;
  function object3dinstance_inViewport_binding(value) {
    ctx[13](value);
  }
  let object3dinstance_props = {
    object: (
      /*object*/
      ctx[11]
    ),
    position: (
      /*position*/
      ctx[1]
    ),
    scale: (
      /*scale*/
      ctx[2]
    ),
    rotation: (
      /*rotation*/
      ctx[3]
    ),
    lookAt: (
      /*lookAt*/
      ctx[4]
    ),
    frustumCulled: (
      /*frustumCulled*/
      ctx[8]
    ),
    renderOrder: (
      /*renderOrder*/
      ctx[9]
    ),
    visible: (
      /*visible*/
      ctx[10]
    ),
    castShadow: (
      /*castShadow*/
      ctx[6]
    ),
    receiveShadow: (
      /*receiveShadow*/
      ctx[7]
    ),
    viewportAware: (
      /*viewportAware*/
      ctx[5]
    ),
    $$slots: { default: [create_default_slot20] },
    $$scope: { ctx }
  };
  if (
    /*inViewport*/
    ctx[0] !== void 0
  ) {
    object3dinstance_props.inViewport = /*inViewport*/
    ctx[0];
  }
  object3dinstance = new Object3DInstance_default({
    props: object3dinstance_props,
    $$inline: true
  });
  binding_callbacks.push(() => bind(object3dinstance, "inViewport", object3dinstance_inViewport_binding));
  object3dinstance.$on(
    "viewportenter",
    /*viewportenter_handler*/
    ctx[14]
  );
  object3dinstance.$on(
    "viewportleave",
    /*viewportleave_handler*/
    ctx[15]
  );
  const block = {
    c: function create() {
      create_component(object3dinstance.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(object3dinstance.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(object3dinstance, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const object3dinstance_changes = {};
      if (dirty & /*position*/
      2)
        object3dinstance_changes.position = /*position*/
        ctx2[1];
      if (dirty & /*scale*/
      4)
        object3dinstance_changes.scale = /*scale*/
        ctx2[2];
      if (dirty & /*rotation*/
      8)
        object3dinstance_changes.rotation = /*rotation*/
        ctx2[3];
      if (dirty & /*lookAt*/
      16)
        object3dinstance_changes.lookAt = /*lookAt*/
        ctx2[4];
      if (dirty & /*frustumCulled*/
      256)
        object3dinstance_changes.frustumCulled = /*frustumCulled*/
        ctx2[8];
      if (dirty & /*renderOrder*/
      512)
        object3dinstance_changes.renderOrder = /*renderOrder*/
        ctx2[9];
      if (dirty & /*visible*/
      1024)
        object3dinstance_changes.visible = /*visible*/
        ctx2[10];
      if (dirty & /*castShadow*/
      64)
        object3dinstance_changes.castShadow = /*castShadow*/
        ctx2[6];
      if (dirty & /*receiveShadow*/
      128)
        object3dinstance_changes.receiveShadow = /*receiveShadow*/
        ctx2[7];
      if (dirty & /*viewportAware*/
      32)
        object3dinstance_changes.viewportAware = /*viewportAware*/
        ctx2[5];
      if (dirty & /*$$scope*/
      65536) {
        object3dinstance_changes.$$scope = { dirty, ctx: ctx2 };
      }
      if (!updating_inViewport && dirty & /*inViewport*/
      1) {
        updating_inViewport = true;
        object3dinstance_changes.inViewport = /*inViewport*/
        ctx2[0];
        add_flush_callback(() => updating_inViewport = false);
      }
      object3dinstance.$set(object3dinstance_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(object3dinstance.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(object3dinstance.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(object3dinstance, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment34.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance33($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Object3D", slots, ["default"]);
  let { position = void 0 } = $$props;
  let { scale = void 0 } = $$props;
  let { rotation = void 0 } = $$props;
  let { lookAt = void 0 } = $$props;
  let { viewportAware = false } = $$props;
  let { inViewport = false } = $$props;
  let { castShadow = void 0 } = $$props;
  let { receiveShadow = void 0 } = $$props;
  let { frustumCulled = void 0 } = $$props;
  let { renderOrder = void 0 } = $$props;
  let { visible = void 0 } = $$props;
  const object = new Object3D();
  const writable_props = [
    "position",
    "scale",
    "rotation",
    "lookAt",
    "viewportAware",
    "inViewport",
    "castShadow",
    "receiveShadow",
    "frustumCulled",
    "renderOrder",
    "visible"
  ];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<Object3D> was created with unknown prop '${key}'`);
  });
  function object3dinstance_inViewport_binding(value) {
    inViewport = value;
    $$invalidate(0, inViewport);
  }
  function viewportenter_handler(event) {
    bubble.call(this, $$self, event);
  }
  function viewportleave_handler(event) {
    bubble.call(this, $$self, event);
  }
  $$self.$$set = ($$props2) => {
    if ("position" in $$props2)
      $$invalidate(1, position = $$props2.position);
    if ("scale" in $$props2)
      $$invalidate(2, scale = $$props2.scale);
    if ("rotation" in $$props2)
      $$invalidate(3, rotation = $$props2.rotation);
    if ("lookAt" in $$props2)
      $$invalidate(4, lookAt = $$props2.lookAt);
    if ("viewportAware" in $$props2)
      $$invalidate(5, viewportAware = $$props2.viewportAware);
    if ("inViewport" in $$props2)
      $$invalidate(0, inViewport = $$props2.inViewport);
    if ("castShadow" in $$props2)
      $$invalidate(6, castShadow = $$props2.castShadow);
    if ("receiveShadow" in $$props2)
      $$invalidate(7, receiveShadow = $$props2.receiveShadow);
    if ("frustumCulled" in $$props2)
      $$invalidate(8, frustumCulled = $$props2.frustumCulled);
    if ("renderOrder" in $$props2)
      $$invalidate(9, renderOrder = $$props2.renderOrder);
    if ("visible" in $$props2)
      $$invalidate(10, visible = $$props2.visible);
    if ("$$scope" in $$props2)
      $$invalidate(16, $$scope = $$props2.$$scope);
  };
  $$self.$capture_state = () => ({
    ThreeObject3D: Object3D,
    Object3DInstance: Object3DInstance_default,
    position,
    scale,
    rotation,
    lookAt,
    viewportAware,
    inViewport,
    castShadow,
    receiveShadow,
    frustumCulled,
    renderOrder,
    visible,
    object
  });
  $$self.$inject_state = ($$props2) => {
    if ("position" in $$props2)
      $$invalidate(1, position = $$props2.position);
    if ("scale" in $$props2)
      $$invalidate(2, scale = $$props2.scale);
    if ("rotation" in $$props2)
      $$invalidate(3, rotation = $$props2.rotation);
    if ("lookAt" in $$props2)
      $$invalidate(4, lookAt = $$props2.lookAt);
    if ("viewportAware" in $$props2)
      $$invalidate(5, viewportAware = $$props2.viewportAware);
    if ("inViewport" in $$props2)
      $$invalidate(0, inViewport = $$props2.inViewport);
    if ("castShadow" in $$props2)
      $$invalidate(6, castShadow = $$props2.castShadow);
    if ("receiveShadow" in $$props2)
      $$invalidate(7, receiveShadow = $$props2.receiveShadow);
    if ("frustumCulled" in $$props2)
      $$invalidate(8, frustumCulled = $$props2.frustumCulled);
    if ("renderOrder" in $$props2)
      $$invalidate(9, renderOrder = $$props2.renderOrder);
    if ("visible" in $$props2)
      $$invalidate(10, visible = $$props2.visible);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [
    inViewport,
    position,
    scale,
    rotation,
    lookAt,
    viewportAware,
    castShadow,
    receiveShadow,
    frustumCulled,
    renderOrder,
    visible,
    object,
    slots,
    object3dinstance_inViewport_binding,
    viewportenter_handler,
    viewportleave_handler,
    $$scope
  ];
}
var Object3D2 = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance33, create_fragment34, safe_not_equal, {
      position: 1,
      scale: 2,
      rotation: 3,
      lookAt: 4,
      viewportAware: 5,
      inViewport: 0,
      castShadow: 6,
      receiveShadow: 7,
      frustumCulled: 8,
      renderOrder: 9,
      visible: 10,
      object: 11
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Object3D",
      options,
      id: create_fragment34.name
    });
  }
  get position() {
    throw new Error("<Object3D>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set position(value) {
    throw new Error("<Object3D>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get scale() {
    throw new Error("<Object3D>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set scale(value) {
    throw new Error("<Object3D>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get rotation() {
    throw new Error("<Object3D>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set rotation(value) {
    throw new Error("<Object3D>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get lookAt() {
    throw new Error("<Object3D>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set lookAt(value) {
    throw new Error("<Object3D>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get viewportAware() {
    throw new Error("<Object3D>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set viewportAware(value) {
    throw new Error("<Object3D>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get inViewport() {
    throw new Error("<Object3D>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set inViewport(value) {
    throw new Error("<Object3D>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get castShadow() {
    throw new Error("<Object3D>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set castShadow(value) {
    throw new Error("<Object3D>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get receiveShadow() {
    throw new Error("<Object3D>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set receiveShadow(value) {
    throw new Error("<Object3D>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get frustumCulled() {
    throw new Error("<Object3D>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set frustumCulled(value) {
    throw new Error("<Object3D>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get renderOrder() {
    throw new Error("<Object3D>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set renderOrder(value) {
    throw new Error("<Object3D>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get visible() {
    throw new Error("<Object3D>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set visible(value) {
    throw new Error("<Object3D>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get object() {
    return this.$$.ctx[11];
  }
  set object(value) {
    throw new Error("<Object3D>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Object3D_default = Object3D2;

// node_modules/three/examples/jsm/loaders/DRACOLoader.js
var _taskCache = /* @__PURE__ */ new WeakMap();
var DRACOLoader = class extends Loader {
  constructor(manager) {
    super(manager);
    this.decoderPath = "";
    this.decoderConfig = {};
    this.decoderBinary = null;
    this.decoderPending = null;
    this.workerLimit = 4;
    this.workerPool = [];
    this.workerNextTaskID = 1;
    this.workerSourceURL = "";
    this.defaultAttributeIDs = {
      position: "POSITION",
      normal: "NORMAL",
      color: "COLOR",
      uv: "TEX_COORD"
    };
    this.defaultAttributeTypes = {
      position: "Float32Array",
      normal: "Float32Array",
      color: "Float32Array",
      uv: "Float32Array"
    };
  }
  setDecoderPath(path) {
    this.decoderPath = path;
    return this;
  }
  setDecoderConfig(config) {
    this.decoderConfig = config;
    return this;
  }
  setWorkerLimit(workerLimit) {
    this.workerLimit = workerLimit;
    return this;
  }
  load(url, onLoad, onProgress, onError) {
    const loader2 = new FileLoader(this.manager);
    loader2.setPath(this.path);
    loader2.setResponseType("arraybuffer");
    loader2.setRequestHeader(this.requestHeader);
    loader2.setWithCredentials(this.withCredentials);
    loader2.load(url, (buffer) => {
      this.parse(buffer, onLoad, onError);
    }, onProgress, onError);
  }
  parse(buffer, onLoad, onError) {
    this.decodeDracoFile(buffer, onLoad, null, null, SRGBColorSpace).catch(onError);
  }
  decodeDracoFile(buffer, callback, attributeIDs, attributeTypes, vertexColorSpace = LinearSRGBColorSpace) {
    const taskConfig = {
      attributeIDs: attributeIDs || this.defaultAttributeIDs,
      attributeTypes: attributeTypes || this.defaultAttributeTypes,
      useUniqueIDs: !!attributeIDs,
      vertexColorSpace
    };
    return this.decodeGeometry(buffer, taskConfig).then(callback);
  }
  decodeGeometry(buffer, taskConfig) {
    const taskKey = JSON.stringify(taskConfig);
    if (_taskCache.has(buffer)) {
      const cachedTask = _taskCache.get(buffer);
      if (cachedTask.key === taskKey) {
        return cachedTask.promise;
      } else if (buffer.byteLength === 0) {
        throw new Error(
          "THREE.DRACOLoader: Unable to re-decode a buffer with different settings. Buffer has already been transferred."
        );
      }
    }
    let worker;
    const taskID = this.workerNextTaskID++;
    const taskCost = buffer.byteLength;
    const geometryPending = this._getWorker(taskID, taskCost).then((_worker) => {
      worker = _worker;
      return new Promise((resolve, reject) => {
        worker._callbacks[taskID] = { resolve, reject };
        worker.postMessage({ type: "decode", id: taskID, taskConfig, buffer }, [buffer]);
      });
    }).then((message) => this._createGeometry(message.geometry));
    geometryPending.catch(() => true).then(() => {
      if (worker && taskID) {
        this._releaseTask(worker, taskID);
      }
    });
    _taskCache.set(buffer, {
      key: taskKey,
      promise: geometryPending
    });
    return geometryPending;
  }
  _createGeometry(geometryData) {
    const geometry = new BufferGeometry();
    if (geometryData.index) {
      geometry.setIndex(new BufferAttribute(geometryData.index.array, 1));
    }
    for (let i = 0; i < geometryData.attributes.length; i++) {
      const result = geometryData.attributes[i];
      const name = result.name;
      const array = result.array;
      const itemSize = result.itemSize;
      const attribute = new BufferAttribute(array, itemSize);
      if (name === "color") {
        this._assignVertexColorSpace(attribute, result.vertexColorSpace);
        attribute.normalized = array instanceof Float32Array === false;
      }
      geometry.setAttribute(name, attribute);
    }
    return geometry;
  }
  _assignVertexColorSpace(attribute, inputColorSpace) {
    if (inputColorSpace !== SRGBColorSpace)
      return;
    const _color = new Color();
    for (let i = 0, il = attribute.count; i < il; i++) {
      _color.fromBufferAttribute(attribute, i).convertSRGBToLinear();
      attribute.setXYZ(i, _color.r, _color.g, _color.b);
    }
  }
  _loadLibrary(url, responseType) {
    const loader2 = new FileLoader(this.manager);
    loader2.setPath(this.decoderPath);
    loader2.setResponseType(responseType);
    loader2.setWithCredentials(this.withCredentials);
    return new Promise((resolve, reject) => {
      loader2.load(url, resolve, void 0, reject);
    });
  }
  preload() {
    this._initDecoder();
    return this;
  }
  _initDecoder() {
    if (this.decoderPending)
      return this.decoderPending;
    const useJS = typeof WebAssembly !== "object" || this.decoderConfig.type === "js";
    const librariesPending = [];
    if (useJS) {
      librariesPending.push(this._loadLibrary("draco_decoder.js", "text"));
    } else {
      librariesPending.push(this._loadLibrary("draco_wasm_wrapper.js", "text"));
      librariesPending.push(this._loadLibrary("draco_decoder.wasm", "arraybuffer"));
    }
    this.decoderPending = Promise.all(librariesPending).then((libraries) => {
      const jsContent = libraries[0];
      if (!useJS) {
        this.decoderConfig.wasmBinary = libraries[1];
      }
      const fn = DRACOWorker.toString();
      const body = [
        "/* draco decoder */",
        jsContent,
        "",
        "/* worker */",
        fn.substring(fn.indexOf("{") + 1, fn.lastIndexOf("}"))
      ].join("\n");
      this.workerSourceURL = URL.createObjectURL(new Blob([body]));
    });
    return this.decoderPending;
  }
  _getWorker(taskID, taskCost) {
    return this._initDecoder().then(() => {
      if (this.workerPool.length < this.workerLimit) {
        const worker2 = new Worker(this.workerSourceURL);
        worker2._callbacks = {};
        worker2._taskCosts = {};
        worker2._taskLoad = 0;
        worker2.postMessage({ type: "init", decoderConfig: this.decoderConfig });
        worker2.onmessage = function(e) {
          const message = e.data;
          switch (message.type) {
            case "decode":
              worker2._callbacks[message.id].resolve(message);
              break;
            case "error":
              worker2._callbacks[message.id].reject(message);
              break;
            default:
              console.error('THREE.DRACOLoader: Unexpected message, "' + message.type + '"');
          }
        };
        this.workerPool.push(worker2);
      } else {
        this.workerPool.sort(function(a, b) {
          return a._taskLoad > b._taskLoad ? -1 : 1;
        });
      }
      const worker = this.workerPool[this.workerPool.length - 1];
      worker._taskCosts[taskID] = taskCost;
      worker._taskLoad += taskCost;
      return worker;
    });
  }
  _releaseTask(worker, taskID) {
    worker._taskLoad -= worker._taskCosts[taskID];
    delete worker._callbacks[taskID];
    delete worker._taskCosts[taskID];
  }
  debug() {
    console.log("Task load: ", this.workerPool.map((worker) => worker._taskLoad));
  }
  dispose() {
    for (let i = 0; i < this.workerPool.length; ++i) {
      this.workerPool[i].terminate();
    }
    this.workerPool.length = 0;
    if (this.workerSourceURL !== "") {
      URL.revokeObjectURL(this.workerSourceURL);
    }
    return this;
  }
};
function DRACOWorker() {
  let decoderConfig;
  let decoderPending;
  onmessage = function(e) {
    const message = e.data;
    switch (message.type) {
      case "init":
        decoderConfig = message.decoderConfig;
        decoderPending = new Promise(function(resolve) {
          decoderConfig.onModuleLoaded = function(draco) {
            resolve({ draco });
          };
          DracoDecoderModule(decoderConfig);
        });
        break;
      case "decode":
        const buffer = message.buffer;
        const taskConfig = message.taskConfig;
        decoderPending.then((module) => {
          const draco = module.draco;
          const decoder = new draco.Decoder();
          try {
            const geometry = decodeGeometry(draco, decoder, new Int8Array(buffer), taskConfig);
            const buffers = geometry.attributes.map((attr) => attr.array.buffer);
            if (geometry.index)
              buffers.push(geometry.index.array.buffer);
            self.postMessage({ type: "decode", id: message.id, geometry }, buffers);
          } catch (error) {
            console.error(error);
            self.postMessage({ type: "error", id: message.id, error: error.message });
          } finally {
            draco.destroy(decoder);
          }
        });
        break;
    }
  };
  function decodeGeometry(draco, decoder, array, taskConfig) {
    const attributeIDs = taskConfig.attributeIDs;
    const attributeTypes = taskConfig.attributeTypes;
    let dracoGeometry;
    let decodingStatus;
    const geometryType = decoder.GetEncodedGeometryType(array);
    if (geometryType === draco.TRIANGULAR_MESH) {
      dracoGeometry = new draco.Mesh();
      decodingStatus = decoder.DecodeArrayToMesh(array, array.byteLength, dracoGeometry);
    } else if (geometryType === draco.POINT_CLOUD) {
      dracoGeometry = new draco.PointCloud();
      decodingStatus = decoder.DecodeArrayToPointCloud(array, array.byteLength, dracoGeometry);
    } else {
      throw new Error("THREE.DRACOLoader: Unexpected geometry type.");
    }
    if (!decodingStatus.ok() || dracoGeometry.ptr === 0) {
      throw new Error("THREE.DRACOLoader: Decoding failed: " + decodingStatus.error_msg());
    }
    const geometry = { index: null, attributes: [] };
    for (const attributeName in attributeIDs) {
      const attributeType = self[attributeTypes[attributeName]];
      let attribute;
      let attributeID;
      if (taskConfig.useUniqueIDs) {
        attributeID = attributeIDs[attributeName];
        attribute = decoder.GetAttributeByUniqueId(dracoGeometry, attributeID);
      } else {
        attributeID = decoder.GetAttributeId(dracoGeometry, draco[attributeIDs[attributeName]]);
        if (attributeID === -1)
          continue;
        attribute = decoder.GetAttribute(dracoGeometry, attributeID);
      }
      const attributeResult = decodeAttribute(draco, decoder, dracoGeometry, attributeName, attributeType, attribute);
      if (attributeName === "color") {
        attributeResult.vertexColorSpace = taskConfig.vertexColorSpace;
      }
      geometry.attributes.push(attributeResult);
    }
    if (geometryType === draco.TRIANGULAR_MESH) {
      geometry.index = decodeIndex(draco, decoder, dracoGeometry);
    }
    draco.destroy(dracoGeometry);
    return geometry;
  }
  function decodeIndex(draco, decoder, dracoGeometry) {
    const numFaces = dracoGeometry.num_faces();
    const numIndices = numFaces * 3;
    const byteLength = numIndices * 4;
    const ptr = draco._malloc(byteLength);
    decoder.GetTrianglesUInt32Array(dracoGeometry, byteLength, ptr);
    const index = new Uint32Array(draco.HEAPF32.buffer, ptr, numIndices).slice();
    draco._free(ptr);
    return { array: index, itemSize: 1 };
  }
  function decodeAttribute(draco, decoder, dracoGeometry, attributeName, attributeType, attribute) {
    const numComponents = attribute.num_components();
    const numPoints = dracoGeometry.num_points();
    const numValues = numPoints * numComponents;
    const byteLength = numValues * attributeType.BYTES_PER_ELEMENT;
    const dataType = getDracoDataType(draco, attributeType);
    const ptr = draco._malloc(byteLength);
    decoder.GetAttributeDataArrayForAllPoints(dracoGeometry, attribute, dataType, byteLength, ptr);
    const array = new attributeType(draco.HEAPF32.buffer, ptr, numValues).slice();
    draco._free(ptr);
    return {
      name: attributeName,
      array,
      itemSize: numComponents
    };
  }
  function getDracoDataType(draco, attributeType) {
    switch (attributeType) {
      case Float32Array:
        return draco.DT_FLOAT32;
      case Int8Array:
        return draco.DT_INT8;
      case Int16Array:
        return draco.DT_INT16;
      case Int32Array:
        return draco.DT_INT32;
      case Uint8Array:
        return draco.DT_UINT8;
      case Uint16Array:
        return draco.DT_UINT16;
      case Uint32Array:
        return draco.DT_UINT32;
    }
  }
}

// node_modules/three/examples/jsm/utils/BufferGeometryUtils.js
function toTrianglesDrawMode(geometry, drawMode) {
  if (drawMode === TrianglesDrawMode) {
    console.warn("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Geometry already defined as triangles.");
    return geometry;
  }
  if (drawMode === TriangleFanDrawMode || drawMode === TriangleStripDrawMode) {
    let index = geometry.getIndex();
    if (index === null) {
      const indices = [];
      const position = geometry.getAttribute("position");
      if (position !== void 0) {
        for (let i = 0; i < position.count; i++) {
          indices.push(i);
        }
        geometry.setIndex(indices);
        index = geometry.getIndex();
      } else {
        console.error("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Undefined position attribute. Processing not possible.");
        return geometry;
      }
    }
    const numberOfTriangles = index.count - 2;
    const newIndices = [];
    if (drawMode === TriangleFanDrawMode) {
      for (let i = 1; i <= numberOfTriangles; i++) {
        newIndices.push(index.getX(0));
        newIndices.push(index.getX(i));
        newIndices.push(index.getX(i + 1));
      }
    } else {
      for (let i = 0; i < numberOfTriangles; i++) {
        if (i % 2 === 0) {
          newIndices.push(index.getX(i));
          newIndices.push(index.getX(i + 1));
          newIndices.push(index.getX(i + 2));
        } else {
          newIndices.push(index.getX(i + 2));
          newIndices.push(index.getX(i + 1));
          newIndices.push(index.getX(i));
        }
      }
    }
    if (newIndices.length / 3 !== numberOfTriangles) {
      console.error("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Unable to generate correct amount of triangles.");
    }
    const newGeometry = geometry.clone();
    newGeometry.setIndex(newIndices);
    newGeometry.clearGroups();
    return newGeometry;
  } else {
    console.error("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Unknown draw mode:", drawMode);
    return geometry;
  }
}

// node_modules/three/examples/jsm/loaders/GLTFLoader.js
var GLTFLoader = class extends Loader {
  constructor(manager) {
    super(manager);
    this.dracoLoader = null;
    this.ktx2Loader = null;
    this.meshoptDecoder = null;
    this.pluginCallbacks = [];
    this.register(function(parser) {
      return new GLTFMaterialsClearcoatExtension(parser);
    });
    this.register(function(parser) {
      return new GLTFTextureBasisUExtension(parser);
    });
    this.register(function(parser) {
      return new GLTFTextureWebPExtension(parser);
    });
    this.register(function(parser) {
      return new GLTFTextureAVIFExtension(parser);
    });
    this.register(function(parser) {
      return new GLTFMaterialsSheenExtension(parser);
    });
    this.register(function(parser) {
      return new GLTFMaterialsTransmissionExtension(parser);
    });
    this.register(function(parser) {
      return new GLTFMaterialsVolumeExtension(parser);
    });
    this.register(function(parser) {
      return new GLTFMaterialsIorExtension(parser);
    });
    this.register(function(parser) {
      return new GLTFMaterialsEmissiveStrengthExtension(parser);
    });
    this.register(function(parser) {
      return new GLTFMaterialsSpecularExtension(parser);
    });
    this.register(function(parser) {
      return new GLTFMaterialsIridescenceExtension(parser);
    });
    this.register(function(parser) {
      return new GLTFMaterialsAnisotropyExtension(parser);
    });
    this.register(function(parser) {
      return new GLTFLightsExtension(parser);
    });
    this.register(function(parser) {
      return new GLTFMeshoptCompression(parser);
    });
    this.register(function(parser) {
      return new GLTFMeshGpuInstancing(parser);
    });
  }
  load(url, onLoad, onProgress, onError) {
    const scope = this;
    let resourcePath;
    if (this.resourcePath !== "") {
      resourcePath = this.resourcePath;
    } else if (this.path !== "") {
      resourcePath = this.path;
    } else {
      resourcePath = LoaderUtils.extractUrlBase(url);
    }
    this.manager.itemStart(url);
    const _onError = function(e) {
      if (onError) {
        onError(e);
      } else {
        console.error(e);
      }
      scope.manager.itemError(url);
      scope.manager.itemEnd(url);
    };
    const loader2 = new FileLoader(this.manager);
    loader2.setPath(this.path);
    loader2.setResponseType("arraybuffer");
    loader2.setRequestHeader(this.requestHeader);
    loader2.setWithCredentials(this.withCredentials);
    loader2.load(url, function(data) {
      try {
        scope.parse(data, resourcePath, function(gltf) {
          onLoad(gltf);
          scope.manager.itemEnd(url);
        }, _onError);
      } catch (e) {
        _onError(e);
      }
    }, onProgress, _onError);
  }
  setDRACOLoader(dracoLoader) {
    this.dracoLoader = dracoLoader;
    return this;
  }
  setDDSLoader() {
    throw new Error(
      'THREE.GLTFLoader: "MSFT_texture_dds" no longer supported. Please update to "KHR_texture_basisu".'
    );
  }
  setKTX2Loader(ktx2Loader) {
    this.ktx2Loader = ktx2Loader;
    return this;
  }
  setMeshoptDecoder(meshoptDecoder) {
    this.meshoptDecoder = meshoptDecoder;
    return this;
  }
  register(callback) {
    if (this.pluginCallbacks.indexOf(callback) === -1) {
      this.pluginCallbacks.push(callback);
    }
    return this;
  }
  unregister(callback) {
    if (this.pluginCallbacks.indexOf(callback) !== -1) {
      this.pluginCallbacks.splice(this.pluginCallbacks.indexOf(callback), 1);
    }
    return this;
  }
  parse(data, path, onLoad, onError) {
    let json;
    const extensions = {};
    const plugins = {};
    const textDecoder = new TextDecoder();
    if (typeof data === "string") {
      json = JSON.parse(data);
    } else if (data instanceof ArrayBuffer) {
      const magic = textDecoder.decode(new Uint8Array(data, 0, 4));
      if (magic === BINARY_EXTENSION_HEADER_MAGIC) {
        try {
          extensions[EXTENSIONS.KHR_BINARY_GLTF] = new GLTFBinaryExtension(data);
        } catch (error) {
          if (onError)
            onError(error);
          return;
        }
        json = JSON.parse(extensions[EXTENSIONS.KHR_BINARY_GLTF].content);
      } else {
        json = JSON.parse(textDecoder.decode(data));
      }
    } else {
      json = data;
    }
    if (json.asset === void 0 || json.asset.version[0] < 2) {
      if (onError)
        onError(new Error("THREE.GLTFLoader: Unsupported asset. glTF versions >=2.0 are supported."));
      return;
    }
    const parser = new GLTFParser(json, {
      path: path || this.resourcePath || "",
      crossOrigin: this.crossOrigin,
      requestHeader: this.requestHeader,
      manager: this.manager,
      ktx2Loader: this.ktx2Loader,
      meshoptDecoder: this.meshoptDecoder
    });
    parser.fileLoader.setRequestHeader(this.requestHeader);
    for (let i = 0; i < this.pluginCallbacks.length; i++) {
      const plugin = this.pluginCallbacks[i](parser);
      plugins[plugin.name] = plugin;
      extensions[plugin.name] = true;
    }
    if (json.extensionsUsed) {
      for (let i = 0; i < json.extensionsUsed.length; ++i) {
        const extensionName = json.extensionsUsed[i];
        const extensionsRequired = json.extensionsRequired || [];
        switch (extensionName) {
          case EXTENSIONS.KHR_MATERIALS_UNLIT:
            extensions[extensionName] = new GLTFMaterialsUnlitExtension();
            break;
          case EXTENSIONS.KHR_DRACO_MESH_COMPRESSION:
            extensions[extensionName] = new GLTFDracoMeshCompressionExtension(json, this.dracoLoader);
            break;
          case EXTENSIONS.KHR_TEXTURE_TRANSFORM:
            extensions[extensionName] = new GLTFTextureTransformExtension();
            break;
          case EXTENSIONS.KHR_MESH_QUANTIZATION:
            extensions[extensionName] = new GLTFMeshQuantizationExtension();
            break;
          default:
            if (extensionsRequired.indexOf(extensionName) >= 0 && plugins[extensionName] === void 0) {
              console.warn('THREE.GLTFLoader: Unknown extension "' + extensionName + '".');
            }
        }
      }
    }
    parser.setExtensions(extensions);
    parser.setPlugins(plugins);
    parser.parse(onLoad, onError);
  }
  parseAsync(data, path) {
    const scope = this;
    return new Promise(function(resolve, reject) {
      scope.parse(data, path, resolve, reject);
    });
  }
};
function GLTFRegistry() {
  let objects = {};
  return {
    get: function(key) {
      return objects[key];
    },
    add: function(key, object) {
      objects[key] = object;
    },
    remove: function(key) {
      delete objects[key];
    },
    removeAll: function() {
      objects = {};
    }
  };
}
var EXTENSIONS = {
  KHR_BINARY_GLTF: "KHR_binary_glTF",
  KHR_DRACO_MESH_COMPRESSION: "KHR_draco_mesh_compression",
  KHR_LIGHTS_PUNCTUAL: "KHR_lights_punctual",
  KHR_MATERIALS_CLEARCOAT: "KHR_materials_clearcoat",
  KHR_MATERIALS_IOR: "KHR_materials_ior",
  KHR_MATERIALS_SHEEN: "KHR_materials_sheen",
  KHR_MATERIALS_SPECULAR: "KHR_materials_specular",
  KHR_MATERIALS_TRANSMISSION: "KHR_materials_transmission",
  KHR_MATERIALS_IRIDESCENCE: "KHR_materials_iridescence",
  KHR_MATERIALS_ANISOTROPY: "KHR_materials_anisotropy",
  KHR_MATERIALS_UNLIT: "KHR_materials_unlit",
  KHR_MATERIALS_VOLUME: "KHR_materials_volume",
  KHR_TEXTURE_BASISU: "KHR_texture_basisu",
  KHR_TEXTURE_TRANSFORM: "KHR_texture_transform",
  KHR_MESH_QUANTIZATION: "KHR_mesh_quantization",
  KHR_MATERIALS_EMISSIVE_STRENGTH: "KHR_materials_emissive_strength",
  EXT_TEXTURE_WEBP: "EXT_texture_webp",
  EXT_TEXTURE_AVIF: "EXT_texture_avif",
  EXT_MESHOPT_COMPRESSION: "EXT_meshopt_compression",
  EXT_MESH_GPU_INSTANCING: "EXT_mesh_gpu_instancing"
};
var GLTFLightsExtension = class {
  constructor(parser) {
    this.parser = parser;
    this.name = EXTENSIONS.KHR_LIGHTS_PUNCTUAL;
    this.cache = { refs: {}, uses: {} };
  }
  _markDefs() {
    const parser = this.parser;
    const nodeDefs = this.parser.json.nodes || [];
    for (let nodeIndex = 0, nodeLength = nodeDefs.length; nodeIndex < nodeLength; nodeIndex++) {
      const nodeDef = nodeDefs[nodeIndex];
      if (nodeDef.extensions && nodeDef.extensions[this.name] && nodeDef.extensions[this.name].light !== void 0) {
        parser._addNodeRef(this.cache, nodeDef.extensions[this.name].light);
      }
    }
  }
  _loadLight(lightIndex) {
    const parser = this.parser;
    const cacheKey = "light:" + lightIndex;
    let dependency = parser.cache.get(cacheKey);
    if (dependency)
      return dependency;
    const json = parser.json;
    const extensions = json.extensions && json.extensions[this.name] || {};
    const lightDefs = extensions.lights || [];
    const lightDef = lightDefs[lightIndex];
    let lightNode;
    const color = new Color(16777215);
    if (lightDef.color !== void 0)
      color.fromArray(lightDef.color);
    const range = lightDef.range !== void 0 ? lightDef.range : 0;
    switch (lightDef.type) {
      case "directional":
        lightNode = new DirectionalLight(color);
        lightNode.target.position.set(0, 0, -1);
        lightNode.add(lightNode.target);
        break;
      case "point":
        lightNode = new PointLight(color);
        lightNode.distance = range;
        break;
      case "spot":
        lightNode = new SpotLight(color);
        lightNode.distance = range;
        lightDef.spot = lightDef.spot || {};
        lightDef.spot.innerConeAngle = lightDef.spot.innerConeAngle !== void 0 ? lightDef.spot.innerConeAngle : 0;
        lightDef.spot.outerConeAngle = lightDef.spot.outerConeAngle !== void 0 ? lightDef.spot.outerConeAngle : Math.PI / 4;
        lightNode.angle = lightDef.spot.outerConeAngle;
        lightNode.penumbra = 1 - lightDef.spot.innerConeAngle / lightDef.spot.outerConeAngle;
        lightNode.target.position.set(0, 0, -1);
        lightNode.add(lightNode.target);
        break;
      default:
        throw new Error("THREE.GLTFLoader: Unexpected light type: " + lightDef.type);
    }
    lightNode.position.set(0, 0, 0);
    lightNode.decay = 2;
    assignExtrasToUserData(lightNode, lightDef);
    if (lightDef.intensity !== void 0)
      lightNode.intensity = lightDef.intensity;
    lightNode.name = parser.createUniqueName(lightDef.name || "light_" + lightIndex);
    dependency = Promise.resolve(lightNode);
    parser.cache.add(cacheKey, dependency);
    return dependency;
  }
  getDependency(type, index) {
    if (type !== "light")
      return;
    return this._loadLight(index);
  }
  createNodeAttachment(nodeIndex) {
    const self2 = this;
    const parser = this.parser;
    const json = parser.json;
    const nodeDef = json.nodes[nodeIndex];
    const lightDef = nodeDef.extensions && nodeDef.extensions[this.name] || {};
    const lightIndex = lightDef.light;
    if (lightIndex === void 0)
      return null;
    return this._loadLight(lightIndex).then(function(light) {
      return parser._getNodeRef(self2.cache, lightIndex, light);
    });
  }
};
var GLTFMaterialsUnlitExtension = class {
  constructor() {
    this.name = EXTENSIONS.KHR_MATERIALS_UNLIT;
  }
  getMaterialType() {
    return MeshBasicMaterial;
  }
  extendParams(materialParams, materialDef, parser) {
    const pending = [];
    materialParams.color = new Color(1, 1, 1);
    materialParams.opacity = 1;
    const metallicRoughness = materialDef.pbrMetallicRoughness;
    if (metallicRoughness) {
      if (Array.isArray(metallicRoughness.baseColorFactor)) {
        const array = metallicRoughness.baseColorFactor;
        materialParams.color.fromArray(array);
        materialParams.opacity = array[3];
      }
      if (metallicRoughness.baseColorTexture !== void 0) {
        pending.push(parser.assignTexture(materialParams, "map", metallicRoughness.baseColorTexture, SRGBColorSpace));
      }
    }
    return Promise.all(pending);
  }
};
var GLTFMaterialsEmissiveStrengthExtension = class {
  constructor(parser) {
    this.parser = parser;
    this.name = EXTENSIONS.KHR_MATERIALS_EMISSIVE_STRENGTH;
  }
  extendMaterialParams(materialIndex, materialParams) {
    const parser = this.parser;
    const materialDef = parser.json.materials[materialIndex];
    if (!materialDef.extensions || !materialDef.extensions[this.name]) {
      return Promise.resolve();
    }
    const emissiveStrength = materialDef.extensions[this.name].emissiveStrength;
    if (emissiveStrength !== void 0) {
      materialParams.emissiveIntensity = emissiveStrength;
    }
    return Promise.resolve();
  }
};
var GLTFMaterialsClearcoatExtension = class {
  constructor(parser) {
    this.parser = parser;
    this.name = EXTENSIONS.KHR_MATERIALS_CLEARCOAT;
  }
  getMaterialType(materialIndex) {
    const parser = this.parser;
    const materialDef = parser.json.materials[materialIndex];
    if (!materialDef.extensions || !materialDef.extensions[this.name])
      return null;
    return MeshPhysicalMaterial;
  }
  extendMaterialParams(materialIndex, materialParams) {
    const parser = this.parser;
    const materialDef = parser.json.materials[materialIndex];
    if (!materialDef.extensions || !materialDef.extensions[this.name]) {
      return Promise.resolve();
    }
    const pending = [];
    const extension = materialDef.extensions[this.name];
    if (extension.clearcoatFactor !== void 0) {
      materialParams.clearcoat = extension.clearcoatFactor;
    }
    if (extension.clearcoatTexture !== void 0) {
      pending.push(parser.assignTexture(materialParams, "clearcoatMap", extension.clearcoatTexture));
    }
    if (extension.clearcoatRoughnessFactor !== void 0) {
      materialParams.clearcoatRoughness = extension.clearcoatRoughnessFactor;
    }
    if (extension.clearcoatRoughnessTexture !== void 0) {
      pending.push(parser.assignTexture(materialParams, "clearcoatRoughnessMap", extension.clearcoatRoughnessTexture));
    }
    if (extension.clearcoatNormalTexture !== void 0) {
      pending.push(parser.assignTexture(materialParams, "clearcoatNormalMap", extension.clearcoatNormalTexture));
      if (extension.clearcoatNormalTexture.scale !== void 0) {
        const scale = extension.clearcoatNormalTexture.scale;
        materialParams.clearcoatNormalScale = new Vector2(scale, scale);
      }
    }
    return Promise.all(pending);
  }
};
var GLTFMaterialsIridescenceExtension = class {
  constructor(parser) {
    this.parser = parser;
    this.name = EXTENSIONS.KHR_MATERIALS_IRIDESCENCE;
  }
  getMaterialType(materialIndex) {
    const parser = this.parser;
    const materialDef = parser.json.materials[materialIndex];
    if (!materialDef.extensions || !materialDef.extensions[this.name])
      return null;
    return MeshPhysicalMaterial;
  }
  extendMaterialParams(materialIndex, materialParams) {
    const parser = this.parser;
    const materialDef = parser.json.materials[materialIndex];
    if (!materialDef.extensions || !materialDef.extensions[this.name]) {
      return Promise.resolve();
    }
    const pending = [];
    const extension = materialDef.extensions[this.name];
    if (extension.iridescenceFactor !== void 0) {
      materialParams.iridescence = extension.iridescenceFactor;
    }
    if (extension.iridescenceTexture !== void 0) {
      pending.push(parser.assignTexture(materialParams, "iridescenceMap", extension.iridescenceTexture));
    }
    if (extension.iridescenceIor !== void 0) {
      materialParams.iridescenceIOR = extension.iridescenceIor;
    }
    if (materialParams.iridescenceThicknessRange === void 0) {
      materialParams.iridescenceThicknessRange = [100, 400];
    }
    if (extension.iridescenceThicknessMinimum !== void 0) {
      materialParams.iridescenceThicknessRange[0] = extension.iridescenceThicknessMinimum;
    }
    if (extension.iridescenceThicknessMaximum !== void 0) {
      materialParams.iridescenceThicknessRange[1] = extension.iridescenceThicknessMaximum;
    }
    if (extension.iridescenceThicknessTexture !== void 0) {
      pending.push(parser.assignTexture(materialParams, "iridescenceThicknessMap", extension.iridescenceThicknessTexture));
    }
    return Promise.all(pending);
  }
};
var GLTFMaterialsSheenExtension = class {
  constructor(parser) {
    this.parser = parser;
    this.name = EXTENSIONS.KHR_MATERIALS_SHEEN;
  }
  getMaterialType(materialIndex) {
    const parser = this.parser;
    const materialDef = parser.json.materials[materialIndex];
    if (!materialDef.extensions || !materialDef.extensions[this.name])
      return null;
    return MeshPhysicalMaterial;
  }
  extendMaterialParams(materialIndex, materialParams) {
    const parser = this.parser;
    const materialDef = parser.json.materials[materialIndex];
    if (!materialDef.extensions || !materialDef.extensions[this.name]) {
      return Promise.resolve();
    }
    const pending = [];
    materialParams.sheenColor = new Color(0, 0, 0);
    materialParams.sheenRoughness = 0;
    materialParams.sheen = 1;
    const extension = materialDef.extensions[this.name];
    if (extension.sheenColorFactor !== void 0) {
      materialParams.sheenColor.fromArray(extension.sheenColorFactor);
    }
    if (extension.sheenRoughnessFactor !== void 0) {
      materialParams.sheenRoughness = extension.sheenRoughnessFactor;
    }
    if (extension.sheenColorTexture !== void 0) {
      pending.push(parser.assignTexture(materialParams, "sheenColorMap", extension.sheenColorTexture, SRGBColorSpace));
    }
    if (extension.sheenRoughnessTexture !== void 0) {
      pending.push(parser.assignTexture(materialParams, "sheenRoughnessMap", extension.sheenRoughnessTexture));
    }
    return Promise.all(pending);
  }
};
var GLTFMaterialsTransmissionExtension = class {
  constructor(parser) {
    this.parser = parser;
    this.name = EXTENSIONS.KHR_MATERIALS_TRANSMISSION;
  }
  getMaterialType(materialIndex) {
    const parser = this.parser;
    const materialDef = parser.json.materials[materialIndex];
    if (!materialDef.extensions || !materialDef.extensions[this.name])
      return null;
    return MeshPhysicalMaterial;
  }
  extendMaterialParams(materialIndex, materialParams) {
    const parser = this.parser;
    const materialDef = parser.json.materials[materialIndex];
    if (!materialDef.extensions || !materialDef.extensions[this.name]) {
      return Promise.resolve();
    }
    const pending = [];
    const extension = materialDef.extensions[this.name];
    if (extension.transmissionFactor !== void 0) {
      materialParams.transmission = extension.transmissionFactor;
    }
    if (extension.transmissionTexture !== void 0) {
      pending.push(parser.assignTexture(materialParams, "transmissionMap", extension.transmissionTexture));
    }
    return Promise.all(pending);
  }
};
var GLTFMaterialsVolumeExtension = class {
  constructor(parser) {
    this.parser = parser;
    this.name = EXTENSIONS.KHR_MATERIALS_VOLUME;
  }
  getMaterialType(materialIndex) {
    const parser = this.parser;
    const materialDef = parser.json.materials[materialIndex];
    if (!materialDef.extensions || !materialDef.extensions[this.name])
      return null;
    return MeshPhysicalMaterial;
  }
  extendMaterialParams(materialIndex, materialParams) {
    const parser = this.parser;
    const materialDef = parser.json.materials[materialIndex];
    if (!materialDef.extensions || !materialDef.extensions[this.name]) {
      return Promise.resolve();
    }
    const pending = [];
    const extension = materialDef.extensions[this.name];
    materialParams.thickness = extension.thicknessFactor !== void 0 ? extension.thicknessFactor : 0;
    if (extension.thicknessTexture !== void 0) {
      pending.push(parser.assignTexture(materialParams, "thicknessMap", extension.thicknessTexture));
    }
    materialParams.attenuationDistance = extension.attenuationDistance || Infinity;
    const colorArray = extension.attenuationColor || [1, 1, 1];
    materialParams.attenuationColor = new Color(colorArray[0], colorArray[1], colorArray[2]);
    return Promise.all(pending);
  }
};
var GLTFMaterialsIorExtension = class {
  constructor(parser) {
    this.parser = parser;
    this.name = EXTENSIONS.KHR_MATERIALS_IOR;
  }
  getMaterialType(materialIndex) {
    const parser = this.parser;
    const materialDef = parser.json.materials[materialIndex];
    if (!materialDef.extensions || !materialDef.extensions[this.name])
      return null;
    return MeshPhysicalMaterial;
  }
  extendMaterialParams(materialIndex, materialParams) {
    const parser = this.parser;
    const materialDef = parser.json.materials[materialIndex];
    if (!materialDef.extensions || !materialDef.extensions[this.name]) {
      return Promise.resolve();
    }
    const extension = materialDef.extensions[this.name];
    materialParams.ior = extension.ior !== void 0 ? extension.ior : 1.5;
    return Promise.resolve();
  }
};
var GLTFMaterialsSpecularExtension = class {
  constructor(parser) {
    this.parser = parser;
    this.name = EXTENSIONS.KHR_MATERIALS_SPECULAR;
  }
  getMaterialType(materialIndex) {
    const parser = this.parser;
    const materialDef = parser.json.materials[materialIndex];
    if (!materialDef.extensions || !materialDef.extensions[this.name])
      return null;
    return MeshPhysicalMaterial;
  }
  extendMaterialParams(materialIndex, materialParams) {
    const parser = this.parser;
    const materialDef = parser.json.materials[materialIndex];
    if (!materialDef.extensions || !materialDef.extensions[this.name]) {
      return Promise.resolve();
    }
    const pending = [];
    const extension = materialDef.extensions[this.name];
    materialParams.specularIntensity = extension.specularFactor !== void 0 ? extension.specularFactor : 1;
    if (extension.specularTexture !== void 0) {
      pending.push(parser.assignTexture(materialParams, "specularIntensityMap", extension.specularTexture));
    }
    const colorArray = extension.specularColorFactor || [1, 1, 1];
    materialParams.specularColor = new Color(colorArray[0], colorArray[1], colorArray[2]);
    if (extension.specularColorTexture !== void 0) {
      pending.push(parser.assignTexture(materialParams, "specularColorMap", extension.specularColorTexture, SRGBColorSpace));
    }
    return Promise.all(pending);
  }
};
var GLTFMaterialsAnisotropyExtension = class {
  constructor(parser) {
    this.parser = parser;
    this.name = EXTENSIONS.KHR_MATERIALS_ANISOTROPY;
  }
  getMaterialType(materialIndex) {
    const parser = this.parser;
    const materialDef = parser.json.materials[materialIndex];
    if (!materialDef.extensions || !materialDef.extensions[this.name])
      return null;
    return MeshPhysicalMaterial;
  }
  extendMaterialParams(materialIndex, materialParams) {
    const parser = this.parser;
    const materialDef = parser.json.materials[materialIndex];
    if (!materialDef.extensions || !materialDef.extensions[this.name]) {
      return Promise.resolve();
    }
    const pending = [];
    const extension = materialDef.extensions[this.name];
    if (extension.anisotropyStrength !== void 0) {
      materialParams.anisotropy = extension.anisotropyStrength;
    }
    if (extension.anisotropyRotation !== void 0) {
      materialParams.anisotropyRotation = extension.anisotropyRotation;
    }
    if (extension.anisotropyTexture !== void 0) {
      pending.push(parser.assignTexture(materialParams, "anisotropyMap", extension.anisotropyTexture));
    }
    return Promise.all(pending);
  }
};
var GLTFTextureBasisUExtension = class {
  constructor(parser) {
    this.parser = parser;
    this.name = EXTENSIONS.KHR_TEXTURE_BASISU;
  }
  loadTexture(textureIndex) {
    const parser = this.parser;
    const json = parser.json;
    const textureDef = json.textures[textureIndex];
    if (!textureDef.extensions || !textureDef.extensions[this.name]) {
      return null;
    }
    const extension = textureDef.extensions[this.name];
    const loader2 = parser.options.ktx2Loader;
    if (!loader2) {
      if (json.extensionsRequired && json.extensionsRequired.indexOf(this.name) >= 0) {
        throw new Error("THREE.GLTFLoader: setKTX2Loader must be called before loading KTX2 textures");
      } else {
        return null;
      }
    }
    return parser.loadTextureImage(textureIndex, extension.source, loader2);
  }
};
var GLTFTextureWebPExtension = class {
  constructor(parser) {
    this.parser = parser;
    this.name = EXTENSIONS.EXT_TEXTURE_WEBP;
    this.isSupported = null;
  }
  loadTexture(textureIndex) {
    const name = this.name;
    const parser = this.parser;
    const json = parser.json;
    const textureDef = json.textures[textureIndex];
    if (!textureDef.extensions || !textureDef.extensions[name]) {
      return null;
    }
    const extension = textureDef.extensions[name];
    const source = json.images[extension.source];
    let loader2 = parser.textureLoader;
    if (source.uri) {
      const handler = parser.options.manager.getHandler(source.uri);
      if (handler !== null)
        loader2 = handler;
    }
    return this.detectSupport().then(function(isSupported) {
      if (isSupported)
        return parser.loadTextureImage(textureIndex, extension.source, loader2);
      if (json.extensionsRequired && json.extensionsRequired.indexOf(name) >= 0) {
        throw new Error("THREE.GLTFLoader: WebP required by asset but unsupported.");
      }
      return parser.loadTexture(textureIndex);
    });
  }
  detectSupport() {
    if (!this.isSupported) {
      this.isSupported = new Promise(function(resolve) {
        const image = new Image();
        image.src = "data:image/webp;base64,UklGRiIAAABXRUJQVlA4IBYAAAAwAQCdASoBAAEADsD+JaQAA3AAAAAA";
        image.onload = image.onerror = function() {
          resolve(image.height === 1);
        };
      });
    }
    return this.isSupported;
  }
};
var GLTFTextureAVIFExtension = class {
  constructor(parser) {
    this.parser = parser;
    this.name = EXTENSIONS.EXT_TEXTURE_AVIF;
    this.isSupported = null;
  }
  loadTexture(textureIndex) {
    const name = this.name;
    const parser = this.parser;
    const json = parser.json;
    const textureDef = json.textures[textureIndex];
    if (!textureDef.extensions || !textureDef.extensions[name]) {
      return null;
    }
    const extension = textureDef.extensions[name];
    const source = json.images[extension.source];
    let loader2 = parser.textureLoader;
    if (source.uri) {
      const handler = parser.options.manager.getHandler(source.uri);
      if (handler !== null)
        loader2 = handler;
    }
    return this.detectSupport().then(function(isSupported) {
      if (isSupported)
        return parser.loadTextureImage(textureIndex, extension.source, loader2);
      if (json.extensionsRequired && json.extensionsRequired.indexOf(name) >= 0) {
        throw new Error("THREE.GLTFLoader: AVIF required by asset but unsupported.");
      }
      return parser.loadTexture(textureIndex);
    });
  }
  detectSupport() {
    if (!this.isSupported) {
      this.isSupported = new Promise(function(resolve) {
        const image = new Image();
        image.src = "data:image/avif;base64,AAAAIGZ0eXBhdmlmAAAAAGF2aWZtaWYxbWlhZk1BMUIAAADybWV0YQAAAAAAAAAoaGRscgAAAAAAAAAAcGljdAAAAAAAAAAAAAAAAGxpYmF2aWYAAAAADnBpdG0AAAAAAAEAAAAeaWxvYwAAAABEAAABAAEAAAABAAABGgAAABcAAAAoaWluZgAAAAAAAQAAABppbmZlAgAAAAABAABhdjAxQ29sb3IAAAAAamlwcnAAAABLaXBjbwAAABRpc3BlAAAAAAAAAAEAAAABAAAAEHBpeGkAAAAAAwgICAAAAAxhdjFDgQAMAAAAABNjb2xybmNseAACAAIABoAAAAAXaXBtYQAAAAAAAAABAAEEAQKDBAAAAB9tZGF0EgAKCBgABogQEDQgMgkQAAAAB8dSLfI=";
        image.onload = image.onerror = function() {
          resolve(image.height === 1);
        };
      });
    }
    return this.isSupported;
  }
};
var GLTFMeshoptCompression = class {
  constructor(parser) {
    this.name = EXTENSIONS.EXT_MESHOPT_COMPRESSION;
    this.parser = parser;
  }
  loadBufferView(index) {
    const json = this.parser.json;
    const bufferView = json.bufferViews[index];
    if (bufferView.extensions && bufferView.extensions[this.name]) {
      const extensionDef = bufferView.extensions[this.name];
      const buffer = this.parser.getDependency("buffer", extensionDef.buffer);
      const decoder = this.parser.options.meshoptDecoder;
      if (!decoder || !decoder.supported) {
        if (json.extensionsRequired && json.extensionsRequired.indexOf(this.name) >= 0) {
          throw new Error("THREE.GLTFLoader: setMeshoptDecoder must be called before loading compressed files");
        } else {
          return null;
        }
      }
      return buffer.then(function(res) {
        const byteOffset = extensionDef.byteOffset || 0;
        const byteLength = extensionDef.byteLength || 0;
        const count = extensionDef.count;
        const stride = extensionDef.byteStride;
        const source = new Uint8Array(res, byteOffset, byteLength);
        if (decoder.decodeGltfBufferAsync) {
          return decoder.decodeGltfBufferAsync(count, stride, source, extensionDef.mode, extensionDef.filter).then(function(res2) {
            return res2.buffer;
          });
        } else {
          return decoder.ready.then(function() {
            const result = new ArrayBuffer(count * stride);
            decoder.decodeGltfBuffer(new Uint8Array(result), count, stride, source, extensionDef.mode, extensionDef.filter);
            return result;
          });
        }
      });
    } else {
      return null;
    }
  }
};
var GLTFMeshGpuInstancing = class {
  constructor(parser) {
    this.name = EXTENSIONS.EXT_MESH_GPU_INSTANCING;
    this.parser = parser;
  }
  createNodeMesh(nodeIndex) {
    const json = this.parser.json;
    const nodeDef = json.nodes[nodeIndex];
    if (!nodeDef.extensions || !nodeDef.extensions[this.name] || nodeDef.mesh === void 0) {
      return null;
    }
    const meshDef = json.meshes[nodeDef.mesh];
    for (const primitive of meshDef.primitives) {
      if (primitive.mode !== WEBGL_CONSTANTS.TRIANGLES && primitive.mode !== WEBGL_CONSTANTS.TRIANGLE_STRIP && primitive.mode !== WEBGL_CONSTANTS.TRIANGLE_FAN && primitive.mode !== void 0) {
        return null;
      }
    }
    const extensionDef = nodeDef.extensions[this.name];
    const attributesDef = extensionDef.attributes;
    const pending = [];
    const attributes = {};
    for (const key in attributesDef) {
      pending.push(this.parser.getDependency("accessor", attributesDef[key]).then((accessor) => {
        attributes[key] = accessor;
        return attributes[key];
      }));
    }
    if (pending.length < 1) {
      return null;
    }
    pending.push(this.parser.createNodeMesh(nodeIndex));
    return Promise.all(pending).then((results) => {
      const nodeObject = results.pop();
      const meshes = nodeObject.isGroup ? nodeObject.children : [nodeObject];
      const count = results[0].count;
      const instancedMeshes = [];
      for (const mesh of meshes) {
        const m = new Matrix4();
        const p2 = new Vector3();
        const q = new Quaternion();
        const s = new Vector3(1, 1, 1);
        const instancedMesh = new InstancedMesh(mesh.geometry, mesh.material, count);
        for (let i = 0; i < count; i++) {
          if (attributes.TRANSLATION) {
            p2.fromBufferAttribute(attributes.TRANSLATION, i);
          }
          if (attributes.ROTATION) {
            q.fromBufferAttribute(attributes.ROTATION, i);
          }
          if (attributes.SCALE) {
            s.fromBufferAttribute(attributes.SCALE, i);
          }
          instancedMesh.setMatrixAt(i, m.compose(p2, q, s));
        }
        for (const attributeName in attributes) {
          if (attributeName !== "TRANSLATION" && attributeName !== "ROTATION" && attributeName !== "SCALE") {
            mesh.geometry.setAttribute(attributeName, attributes[attributeName]);
          }
        }
        Object3D.prototype.copy.call(instancedMesh, mesh);
        this.parser.assignFinalMaterial(instancedMesh);
        instancedMeshes.push(instancedMesh);
      }
      if (nodeObject.isGroup) {
        nodeObject.clear();
        nodeObject.add(...instancedMeshes);
        return nodeObject;
      }
      return instancedMeshes[0];
    });
  }
};
var BINARY_EXTENSION_HEADER_MAGIC = "glTF";
var BINARY_EXTENSION_HEADER_LENGTH = 12;
var BINARY_EXTENSION_CHUNK_TYPES = { JSON: 1313821514, BIN: 5130562 };
var GLTFBinaryExtension = class {
  constructor(data) {
    this.name = EXTENSIONS.KHR_BINARY_GLTF;
    this.content = null;
    this.body = null;
    const headerView = new DataView(data, 0, BINARY_EXTENSION_HEADER_LENGTH);
    const textDecoder = new TextDecoder();
    this.header = {
      magic: textDecoder.decode(new Uint8Array(data.slice(0, 4))),
      version: headerView.getUint32(4, true),
      length: headerView.getUint32(8, true)
    };
    if (this.header.magic !== BINARY_EXTENSION_HEADER_MAGIC) {
      throw new Error("THREE.GLTFLoader: Unsupported glTF-Binary header.");
    } else if (this.header.version < 2) {
      throw new Error("THREE.GLTFLoader: Legacy binary file detected.");
    }
    const chunkContentsLength = this.header.length - BINARY_EXTENSION_HEADER_LENGTH;
    const chunkView = new DataView(data, BINARY_EXTENSION_HEADER_LENGTH);
    let chunkIndex = 0;
    while (chunkIndex < chunkContentsLength) {
      const chunkLength = chunkView.getUint32(chunkIndex, true);
      chunkIndex += 4;
      const chunkType = chunkView.getUint32(chunkIndex, true);
      chunkIndex += 4;
      if (chunkType === BINARY_EXTENSION_CHUNK_TYPES.JSON) {
        const contentArray = new Uint8Array(data, BINARY_EXTENSION_HEADER_LENGTH + chunkIndex, chunkLength);
        this.content = textDecoder.decode(contentArray);
      } else if (chunkType === BINARY_EXTENSION_CHUNK_TYPES.BIN) {
        const byteOffset = BINARY_EXTENSION_HEADER_LENGTH + chunkIndex;
        this.body = data.slice(byteOffset, byteOffset + chunkLength);
      }
      chunkIndex += chunkLength;
    }
    if (this.content === null) {
      throw new Error("THREE.GLTFLoader: JSON content not found.");
    }
  }
};
var GLTFDracoMeshCompressionExtension = class {
  constructor(json, dracoLoader) {
    if (!dracoLoader) {
      throw new Error("THREE.GLTFLoader: No DRACOLoader instance provided.");
    }
    this.name = EXTENSIONS.KHR_DRACO_MESH_COMPRESSION;
    this.json = json;
    this.dracoLoader = dracoLoader;
    this.dracoLoader.preload();
  }
  decodePrimitive(primitive, parser) {
    const json = this.json;
    const dracoLoader = this.dracoLoader;
    const bufferViewIndex = primitive.extensions[this.name].bufferView;
    const gltfAttributeMap = primitive.extensions[this.name].attributes;
    const threeAttributeMap = {};
    const attributeNormalizedMap = {};
    const attributeTypeMap = {};
    for (const attributeName in gltfAttributeMap) {
      const threeAttributeName = ATTRIBUTES[attributeName] || attributeName.toLowerCase();
      threeAttributeMap[threeAttributeName] = gltfAttributeMap[attributeName];
    }
    for (const attributeName in primitive.attributes) {
      const threeAttributeName = ATTRIBUTES[attributeName] || attributeName.toLowerCase();
      if (gltfAttributeMap[attributeName] !== void 0) {
        const accessorDef = json.accessors[primitive.attributes[attributeName]];
        const componentType = WEBGL_COMPONENT_TYPES[accessorDef.componentType];
        attributeTypeMap[threeAttributeName] = componentType.name;
        attributeNormalizedMap[threeAttributeName] = accessorDef.normalized === true;
      }
    }
    return parser.getDependency("bufferView", bufferViewIndex).then(function(bufferView) {
      return new Promise(function(resolve) {
        dracoLoader.decodeDracoFile(bufferView, function(geometry) {
          for (const attributeName in geometry.attributes) {
            const attribute = geometry.attributes[attributeName];
            const normalized = attributeNormalizedMap[attributeName];
            if (normalized !== void 0)
              attribute.normalized = normalized;
          }
          resolve(geometry);
        }, threeAttributeMap, attributeTypeMap);
      });
    });
  }
};
var GLTFTextureTransformExtension = class {
  constructor() {
    this.name = EXTENSIONS.KHR_TEXTURE_TRANSFORM;
  }
  extendTexture(texture, transform) {
    if ((transform.texCoord === void 0 || transform.texCoord === texture.channel) && transform.offset === void 0 && transform.rotation === void 0 && transform.scale === void 0) {
      return texture;
    }
    texture = texture.clone();
    if (transform.texCoord !== void 0) {
      texture.channel = transform.texCoord;
    }
    if (transform.offset !== void 0) {
      texture.offset.fromArray(transform.offset);
    }
    if (transform.rotation !== void 0) {
      texture.rotation = transform.rotation;
    }
    if (transform.scale !== void 0) {
      texture.repeat.fromArray(transform.scale);
    }
    texture.needsUpdate = true;
    return texture;
  }
};
var GLTFMeshQuantizationExtension = class {
  constructor() {
    this.name = EXTENSIONS.KHR_MESH_QUANTIZATION;
  }
};
var GLTFCubicSplineInterpolant = class extends Interpolant {
  constructor(parameterPositions, sampleValues, sampleSize, resultBuffer) {
    super(parameterPositions, sampleValues, sampleSize, resultBuffer);
  }
  copySampleValue_(index) {
    const result = this.resultBuffer, values = this.sampleValues, valueSize = this.valueSize, offset = index * valueSize * 3 + valueSize;
    for (let i = 0; i !== valueSize; i++) {
      result[i] = values[offset + i];
    }
    return result;
  }
  interpolate_(i1, t0, t2, t1) {
    const result = this.resultBuffer;
    const values = this.sampleValues;
    const stride = this.valueSize;
    const stride2 = stride * 2;
    const stride3 = stride * 3;
    const td = t1 - t0;
    const p2 = (t2 - t0) / td;
    const pp = p2 * p2;
    const ppp = pp * p2;
    const offset1 = i1 * stride3;
    const offset0 = offset1 - stride3;
    const s2 = -2 * ppp + 3 * pp;
    const s3 = ppp - pp;
    const s0 = 1 - s2;
    const s1 = s3 - pp + p2;
    for (let i = 0; i !== stride; i++) {
      const p0 = values[offset0 + i + stride];
      const m0 = values[offset0 + i + stride2] * td;
      const p1 = values[offset1 + i + stride];
      const m1 = values[offset1 + i] * td;
      result[i] = s0 * p0 + s1 * m0 + s2 * p1 + s3 * m1;
    }
    return result;
  }
};
var _q = new Quaternion();
var GLTFCubicSplineQuaternionInterpolant = class extends GLTFCubicSplineInterpolant {
  interpolate_(i1, t0, t2, t1) {
    const result = super.interpolate_(i1, t0, t2, t1);
    _q.fromArray(result).normalize().toArray(result);
    return result;
  }
};
var WEBGL_CONSTANTS = {
  FLOAT: 5126,
  //FLOAT_MAT2: 35674,
  FLOAT_MAT3: 35675,
  FLOAT_MAT4: 35676,
  FLOAT_VEC2: 35664,
  FLOAT_VEC3: 35665,
  FLOAT_VEC4: 35666,
  LINEAR: 9729,
  REPEAT: 10497,
  SAMPLER_2D: 35678,
  POINTS: 0,
  LINES: 1,
  LINE_LOOP: 2,
  LINE_STRIP: 3,
  TRIANGLES: 4,
  TRIANGLE_STRIP: 5,
  TRIANGLE_FAN: 6,
  UNSIGNED_BYTE: 5121,
  UNSIGNED_SHORT: 5123
};
var WEBGL_COMPONENT_TYPES = {
  5120: Int8Array,
  5121: Uint8Array,
  5122: Int16Array,
  5123: Uint16Array,
  5125: Uint32Array,
  5126: Float32Array
};
var WEBGL_FILTERS = {
  9728: NearestFilter,
  9729: LinearFilter,
  9984: NearestMipmapNearestFilter,
  9985: LinearMipmapNearestFilter,
  9986: NearestMipmapLinearFilter,
  9987: LinearMipmapLinearFilter
};
var WEBGL_WRAPPINGS = {
  33071: ClampToEdgeWrapping,
  33648: MirroredRepeatWrapping,
  10497: RepeatWrapping
};
var WEBGL_TYPE_SIZES = {
  "SCALAR": 1,
  "VEC2": 2,
  "VEC3": 3,
  "VEC4": 4,
  "MAT2": 4,
  "MAT3": 9,
  "MAT4": 16
};
var ATTRIBUTES = {
  POSITION: "position",
  NORMAL: "normal",
  TANGENT: "tangent",
  TEXCOORD_0: "uv",
  TEXCOORD_1: "uv1",
  TEXCOORD_2: "uv2",
  TEXCOORD_3: "uv3",
  COLOR_0: "color",
  WEIGHTS_0: "skinWeight",
  JOINTS_0: "skinIndex"
};
var PATH_PROPERTIES = {
  scale: "scale",
  translation: "position",
  rotation: "quaternion",
  weights: "morphTargetInfluences"
};
var INTERPOLATION = {
  CUBICSPLINE: void 0,
  // We use a custom interpolant (GLTFCubicSplineInterpolation) for CUBICSPLINE tracks. Each
  // keyframe track will be initialized with a default interpolation type, then modified.
  LINEAR: InterpolateLinear,
  STEP: InterpolateDiscrete
};
var ALPHA_MODES = {
  OPAQUE: "OPAQUE",
  MASK: "MASK",
  BLEND: "BLEND"
};
function createDefaultMaterial(cache) {
  if (cache["DefaultMaterial"] === void 0) {
    cache["DefaultMaterial"] = new MeshStandardMaterial({
      color: 16777215,
      emissive: 0,
      metalness: 1,
      roughness: 1,
      transparent: false,
      depthTest: true,
      side: FrontSide
    });
  }
  return cache["DefaultMaterial"];
}
function addUnknownExtensionsToUserData(knownExtensions, object, objectDef) {
  for (const name in objectDef.extensions) {
    if (knownExtensions[name] === void 0) {
      object.userData.gltfExtensions = object.userData.gltfExtensions || {};
      object.userData.gltfExtensions[name] = objectDef.extensions[name];
    }
  }
}
function assignExtrasToUserData(object, gltfDef) {
  if (gltfDef.extras !== void 0) {
    if (typeof gltfDef.extras === "object") {
      Object.assign(object.userData, gltfDef.extras);
    } else {
      console.warn("THREE.GLTFLoader: Ignoring primitive type .extras, " + gltfDef.extras);
    }
  }
}
function addMorphTargets(geometry, targets, parser) {
  let hasMorphPosition = false;
  let hasMorphNormal = false;
  let hasMorphColor = false;
  for (let i = 0, il = targets.length; i < il; i++) {
    const target = targets[i];
    if (target.POSITION !== void 0)
      hasMorphPosition = true;
    if (target.NORMAL !== void 0)
      hasMorphNormal = true;
    if (target.COLOR_0 !== void 0)
      hasMorphColor = true;
    if (hasMorphPosition && hasMorphNormal && hasMorphColor)
      break;
  }
  if (!hasMorphPosition && !hasMorphNormal && !hasMorphColor)
    return Promise.resolve(geometry);
  const pendingPositionAccessors = [];
  const pendingNormalAccessors = [];
  const pendingColorAccessors = [];
  for (let i = 0, il = targets.length; i < il; i++) {
    const target = targets[i];
    if (hasMorphPosition) {
      const pendingAccessor = target.POSITION !== void 0 ? parser.getDependency("accessor", target.POSITION) : geometry.attributes.position;
      pendingPositionAccessors.push(pendingAccessor);
    }
    if (hasMorphNormal) {
      const pendingAccessor = target.NORMAL !== void 0 ? parser.getDependency("accessor", target.NORMAL) : geometry.attributes.normal;
      pendingNormalAccessors.push(pendingAccessor);
    }
    if (hasMorphColor) {
      const pendingAccessor = target.COLOR_0 !== void 0 ? parser.getDependency("accessor", target.COLOR_0) : geometry.attributes.color;
      pendingColorAccessors.push(pendingAccessor);
    }
  }
  return Promise.all([
    Promise.all(pendingPositionAccessors),
    Promise.all(pendingNormalAccessors),
    Promise.all(pendingColorAccessors)
  ]).then(function(accessors) {
    const morphPositions = accessors[0];
    const morphNormals = accessors[1];
    const morphColors = accessors[2];
    if (hasMorphPosition)
      geometry.morphAttributes.position = morphPositions;
    if (hasMorphNormal)
      geometry.morphAttributes.normal = morphNormals;
    if (hasMorphColor)
      geometry.morphAttributes.color = morphColors;
    geometry.morphTargetsRelative = true;
    return geometry;
  });
}
function updateMorphTargets(mesh, meshDef) {
  mesh.updateMorphTargets();
  if (meshDef.weights !== void 0) {
    for (let i = 0, il = meshDef.weights.length; i < il; i++) {
      mesh.morphTargetInfluences[i] = meshDef.weights[i];
    }
  }
  if (meshDef.extras && Array.isArray(meshDef.extras.targetNames)) {
    const targetNames = meshDef.extras.targetNames;
    if (mesh.morphTargetInfluences.length === targetNames.length) {
      mesh.morphTargetDictionary = {};
      for (let i = 0, il = targetNames.length; i < il; i++) {
        mesh.morphTargetDictionary[targetNames[i]] = i;
      }
    } else {
      console.warn("THREE.GLTFLoader: Invalid extras.targetNames length. Ignoring names.");
    }
  }
}
function createPrimitiveKey(primitiveDef) {
  let geometryKey;
  const dracoExtension = primitiveDef.extensions && primitiveDef.extensions[EXTENSIONS.KHR_DRACO_MESH_COMPRESSION];
  if (dracoExtension) {
    geometryKey = "draco:" + dracoExtension.bufferView + ":" + dracoExtension.indices + ":" + createAttributesKey(dracoExtension.attributes);
  } else {
    geometryKey = primitiveDef.indices + ":" + createAttributesKey(primitiveDef.attributes) + ":" + primitiveDef.mode;
  }
  if (primitiveDef.targets !== void 0) {
    for (let i = 0, il = primitiveDef.targets.length; i < il; i++) {
      geometryKey += ":" + createAttributesKey(primitiveDef.targets[i]);
    }
  }
  return geometryKey;
}
function createAttributesKey(attributes) {
  let attributesKey = "";
  const keys = Object.keys(attributes).sort();
  for (let i = 0, il = keys.length; i < il; i++) {
    attributesKey += keys[i] + ":" + attributes[keys[i]] + ";";
  }
  return attributesKey;
}
function getNormalizedComponentScale(constructor) {
  switch (constructor) {
    case Int8Array:
      return 1 / 127;
    case Uint8Array:
      return 1 / 255;
    case Int16Array:
      return 1 / 32767;
    case Uint16Array:
      return 1 / 65535;
    default:
      throw new Error("THREE.GLTFLoader: Unsupported normalized accessor component type.");
  }
}
function getImageURIMimeType(uri) {
  if (uri.search(/\.jpe?g($|\?)/i) > 0 || uri.search(/^data\:image\/jpeg/) === 0)
    return "image/jpeg";
  if (uri.search(/\.webp($|\?)/i) > 0 || uri.search(/^data\:image\/webp/) === 0)
    return "image/webp";
  return "image/png";
}
var _identityMatrix = new Matrix4();
var GLTFParser = class {
  constructor(json = {}, options = {}) {
    this.json = json;
    this.extensions = {};
    this.plugins = {};
    this.options = options;
    this.cache = new GLTFRegistry();
    this.associations = /* @__PURE__ */ new Map();
    this.primitiveCache = {};
    this.nodeCache = {};
    this.meshCache = { refs: {}, uses: {} };
    this.cameraCache = { refs: {}, uses: {} };
    this.lightCache = { refs: {}, uses: {} };
    this.sourceCache = {};
    this.textureCache = {};
    this.nodeNamesUsed = {};
    let isSafari = false;
    let isFirefox = false;
    let firefoxVersion = -1;
    if (typeof navigator !== "undefined") {
      isSafari = /^((?!chrome|android).)*safari/i.test(navigator.userAgent) === true;
      isFirefox = navigator.userAgent.indexOf("Firefox") > -1;
      firefoxVersion = isFirefox ? navigator.userAgent.match(/Firefox\/([0-9]+)\./)[1] : -1;
    }
    if (typeof createImageBitmap === "undefined" || isSafari || isFirefox && firefoxVersion < 98) {
      this.textureLoader = new TextureLoader(this.options.manager);
    } else {
      this.textureLoader = new ImageBitmapLoader(this.options.manager);
    }
    this.textureLoader.setCrossOrigin(this.options.crossOrigin);
    this.textureLoader.setRequestHeader(this.options.requestHeader);
    this.fileLoader = new FileLoader(this.options.manager);
    this.fileLoader.setResponseType("arraybuffer");
    if (this.options.crossOrigin === "use-credentials") {
      this.fileLoader.setWithCredentials(true);
    }
  }
  setExtensions(extensions) {
    this.extensions = extensions;
  }
  setPlugins(plugins) {
    this.plugins = plugins;
  }
  parse(onLoad, onError) {
    const parser = this;
    const json = this.json;
    const extensions = this.extensions;
    this.cache.removeAll();
    this.nodeCache = {};
    this._invokeAll(function(ext) {
      return ext._markDefs && ext._markDefs();
    });
    Promise.all(this._invokeAll(function(ext) {
      return ext.beforeRoot && ext.beforeRoot();
    })).then(function() {
      return Promise.all([
        parser.getDependencies("scene"),
        parser.getDependencies("animation"),
        parser.getDependencies("camera")
      ]);
    }).then(function(dependencies) {
      const result = {
        scene: dependencies[0][json.scene || 0],
        scenes: dependencies[0],
        animations: dependencies[1],
        cameras: dependencies[2],
        asset: json.asset,
        parser,
        userData: {}
      };
      addUnknownExtensionsToUserData(extensions, result, json);
      assignExtrasToUserData(result, json);
      Promise.all(parser._invokeAll(function(ext) {
        return ext.afterRoot && ext.afterRoot(result);
      })).then(function() {
        onLoad(result);
      });
    }).catch(onError);
  }
  /**
   * Marks the special nodes/meshes in json for efficient parse.
   */
  _markDefs() {
    const nodeDefs = this.json.nodes || [];
    const skinDefs = this.json.skins || [];
    const meshDefs = this.json.meshes || [];
    for (let skinIndex = 0, skinLength = skinDefs.length; skinIndex < skinLength; skinIndex++) {
      const joints = skinDefs[skinIndex].joints;
      for (let i = 0, il = joints.length; i < il; i++) {
        nodeDefs[joints[i]].isBone = true;
      }
    }
    for (let nodeIndex = 0, nodeLength = nodeDefs.length; nodeIndex < nodeLength; nodeIndex++) {
      const nodeDef = nodeDefs[nodeIndex];
      if (nodeDef.mesh !== void 0) {
        this._addNodeRef(this.meshCache, nodeDef.mesh);
        if (nodeDef.skin !== void 0) {
          meshDefs[nodeDef.mesh].isSkinnedMesh = true;
        }
      }
      if (nodeDef.camera !== void 0) {
        this._addNodeRef(this.cameraCache, nodeDef.camera);
      }
    }
  }
  /**
   * Counts references to shared node / Object3D resources. These resources
   * can be reused, or "instantiated", at multiple nodes in the scene
   * hierarchy. Mesh, Camera, and Light instances are instantiated and must
   * be marked. Non-scenegraph resources (like Materials, Geometries, and
   * Textures) can be reused directly and are not marked here.
   *
   * Example: CesiumMilkTruck sample model reuses "Wheel" meshes.
   */
  _addNodeRef(cache, index) {
    if (index === void 0)
      return;
    if (cache.refs[index] === void 0) {
      cache.refs[index] = cache.uses[index] = 0;
    }
    cache.refs[index]++;
  }
  /** Returns a reference to a shared resource, cloning it if necessary. */
  _getNodeRef(cache, index, object) {
    if (cache.refs[index] <= 1)
      return object;
    const ref = object.clone();
    const updateMappings = (original, clone) => {
      const mappings = this.associations.get(original);
      if (mappings != null) {
        this.associations.set(clone, mappings);
      }
      for (const [i, child] of original.children.entries()) {
        updateMappings(child, clone.children[i]);
      }
    };
    updateMappings(object, ref);
    ref.name += "_instance_" + cache.uses[index]++;
    return ref;
  }
  _invokeOne(func) {
    const extensions = Object.values(this.plugins);
    extensions.push(this);
    for (let i = 0; i < extensions.length; i++) {
      const result = func(extensions[i]);
      if (result)
        return result;
    }
    return null;
  }
  _invokeAll(func) {
    const extensions = Object.values(this.plugins);
    extensions.unshift(this);
    const pending = [];
    for (let i = 0; i < extensions.length; i++) {
      const result = func(extensions[i]);
      if (result)
        pending.push(result);
    }
    return pending;
  }
  /**
   * Requests the specified dependency asynchronously, with caching.
   * @param {string} type
   * @param {number} index
   * @return {Promise<Object3D|Material|THREE.Texture|AnimationClip|ArrayBuffer|Object>}
   */
  getDependency(type, index) {
    const cacheKey = type + ":" + index;
    let dependency = this.cache.get(cacheKey);
    if (!dependency) {
      switch (type) {
        case "scene":
          dependency = this.loadScene(index);
          break;
        case "node":
          dependency = this._invokeOne(function(ext) {
            return ext.loadNode && ext.loadNode(index);
          });
          break;
        case "mesh":
          dependency = this._invokeOne(function(ext) {
            return ext.loadMesh && ext.loadMesh(index);
          });
          break;
        case "accessor":
          dependency = this.loadAccessor(index);
          break;
        case "bufferView":
          dependency = this._invokeOne(function(ext) {
            return ext.loadBufferView && ext.loadBufferView(index);
          });
          break;
        case "buffer":
          dependency = this.loadBuffer(index);
          break;
        case "material":
          dependency = this._invokeOne(function(ext) {
            return ext.loadMaterial && ext.loadMaterial(index);
          });
          break;
        case "texture":
          dependency = this._invokeOne(function(ext) {
            return ext.loadTexture && ext.loadTexture(index);
          });
          break;
        case "skin":
          dependency = this.loadSkin(index);
          break;
        case "animation":
          dependency = this._invokeOne(function(ext) {
            return ext.loadAnimation && ext.loadAnimation(index);
          });
          break;
        case "camera":
          dependency = this.loadCamera(index);
          break;
        default:
          dependency = this._invokeOne(function(ext) {
            return ext != this && ext.getDependency && ext.getDependency(type, index);
          });
          if (!dependency) {
            throw new Error("Unknown type: " + type);
          }
          break;
      }
      this.cache.add(cacheKey, dependency);
    }
    return dependency;
  }
  /**
   * Requests all dependencies of the specified type asynchronously, with caching.
   * @param {string} type
   * @return {Promise<Array<Object>>}
   */
  getDependencies(type) {
    let dependencies = this.cache.get(type);
    if (!dependencies) {
      const parser = this;
      const defs = this.json[type + (type === "mesh" ? "es" : "s")] || [];
      dependencies = Promise.all(defs.map(function(def, index) {
        return parser.getDependency(type, index);
      }));
      this.cache.add(type, dependencies);
    }
    return dependencies;
  }
  /**
   * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#buffers-and-buffer-views
   * @param {number} bufferIndex
   * @return {Promise<ArrayBuffer>}
   */
  loadBuffer(bufferIndex) {
    const bufferDef = this.json.buffers[bufferIndex];
    const loader2 = this.fileLoader;
    if (bufferDef.type && bufferDef.type !== "arraybuffer") {
      throw new Error("THREE.GLTFLoader: " + bufferDef.type + " buffer type is not supported.");
    }
    if (bufferDef.uri === void 0 && bufferIndex === 0) {
      return Promise.resolve(this.extensions[EXTENSIONS.KHR_BINARY_GLTF].body);
    }
    const options = this.options;
    return new Promise(function(resolve, reject) {
      loader2.load(LoaderUtils.resolveURL(bufferDef.uri, options.path), resolve, void 0, function() {
        reject(new Error('THREE.GLTFLoader: Failed to load buffer "' + bufferDef.uri + '".'));
      });
    });
  }
  /**
   * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#buffers-and-buffer-views
   * @param {number} bufferViewIndex
   * @return {Promise<ArrayBuffer>}
   */
  loadBufferView(bufferViewIndex) {
    const bufferViewDef = this.json.bufferViews[bufferViewIndex];
    return this.getDependency("buffer", bufferViewDef.buffer).then(function(buffer) {
      const byteLength = bufferViewDef.byteLength || 0;
      const byteOffset = bufferViewDef.byteOffset || 0;
      return buffer.slice(byteOffset, byteOffset + byteLength);
    });
  }
  /**
   * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#accessors
   * @param {number} accessorIndex
   * @return {Promise<BufferAttribute|InterleavedBufferAttribute>}
   */
  loadAccessor(accessorIndex) {
    const parser = this;
    const json = this.json;
    const accessorDef = this.json.accessors[accessorIndex];
    if (accessorDef.bufferView === void 0 && accessorDef.sparse === void 0) {
      const itemSize = WEBGL_TYPE_SIZES[accessorDef.type];
      const TypedArray = WEBGL_COMPONENT_TYPES[accessorDef.componentType];
      const normalized = accessorDef.normalized === true;
      const array = new TypedArray(accessorDef.count * itemSize);
      return Promise.resolve(new BufferAttribute(array, itemSize, normalized));
    }
    const pendingBufferViews = [];
    if (accessorDef.bufferView !== void 0) {
      pendingBufferViews.push(this.getDependency("bufferView", accessorDef.bufferView));
    } else {
      pendingBufferViews.push(null);
    }
    if (accessorDef.sparse !== void 0) {
      pendingBufferViews.push(this.getDependency("bufferView", accessorDef.sparse.indices.bufferView));
      pendingBufferViews.push(this.getDependency("bufferView", accessorDef.sparse.values.bufferView));
    }
    return Promise.all(pendingBufferViews).then(function(bufferViews) {
      const bufferView = bufferViews[0];
      const itemSize = WEBGL_TYPE_SIZES[accessorDef.type];
      const TypedArray = WEBGL_COMPONENT_TYPES[accessorDef.componentType];
      const elementBytes = TypedArray.BYTES_PER_ELEMENT;
      const itemBytes = elementBytes * itemSize;
      const byteOffset = accessorDef.byteOffset || 0;
      const byteStride = accessorDef.bufferView !== void 0 ? json.bufferViews[accessorDef.bufferView].byteStride : void 0;
      const normalized = accessorDef.normalized === true;
      let array, bufferAttribute;
      if (byteStride && byteStride !== itemBytes) {
        const ibSlice = Math.floor(byteOffset / byteStride);
        const ibCacheKey = "InterleavedBuffer:" + accessorDef.bufferView + ":" + accessorDef.componentType + ":" + ibSlice + ":" + accessorDef.count;
        let ib = parser.cache.get(ibCacheKey);
        if (!ib) {
          array = new TypedArray(bufferView, ibSlice * byteStride, accessorDef.count * byteStride / elementBytes);
          ib = new InterleavedBuffer(array, byteStride / elementBytes);
          parser.cache.add(ibCacheKey, ib);
        }
        bufferAttribute = new InterleavedBufferAttribute(ib, itemSize, byteOffset % byteStride / elementBytes, normalized);
      } else {
        if (bufferView === null) {
          array = new TypedArray(accessorDef.count * itemSize);
        } else {
          array = new TypedArray(bufferView, byteOffset, accessorDef.count * itemSize);
        }
        bufferAttribute = new BufferAttribute(array, itemSize, normalized);
      }
      if (accessorDef.sparse !== void 0) {
        const itemSizeIndices = WEBGL_TYPE_SIZES.SCALAR;
        const TypedArrayIndices = WEBGL_COMPONENT_TYPES[accessorDef.sparse.indices.componentType];
        const byteOffsetIndices = accessorDef.sparse.indices.byteOffset || 0;
        const byteOffsetValues = accessorDef.sparse.values.byteOffset || 0;
        const sparseIndices = new TypedArrayIndices(bufferViews[1], byteOffsetIndices, accessorDef.sparse.count * itemSizeIndices);
        const sparseValues = new TypedArray(bufferViews[2], byteOffsetValues, accessorDef.sparse.count * itemSize);
        if (bufferView !== null) {
          bufferAttribute = new BufferAttribute(bufferAttribute.array.slice(), bufferAttribute.itemSize, bufferAttribute.normalized);
        }
        for (let i = 0, il = sparseIndices.length; i < il; i++) {
          const index = sparseIndices[i];
          bufferAttribute.setX(index, sparseValues[i * itemSize]);
          if (itemSize >= 2)
            bufferAttribute.setY(index, sparseValues[i * itemSize + 1]);
          if (itemSize >= 3)
            bufferAttribute.setZ(index, sparseValues[i * itemSize + 2]);
          if (itemSize >= 4)
            bufferAttribute.setW(index, sparseValues[i * itemSize + 3]);
          if (itemSize >= 5)
            throw new Error("THREE.GLTFLoader: Unsupported itemSize in sparse BufferAttribute.");
        }
      }
      return bufferAttribute;
    });
  }
  /**
   * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#textures
   * @param {number} textureIndex
   * @return {Promise<THREE.Texture|null>}
   */
  loadTexture(textureIndex) {
    const json = this.json;
    const options = this.options;
    const textureDef = json.textures[textureIndex];
    const sourceIndex = textureDef.source;
    const sourceDef = json.images[sourceIndex];
    let loader2 = this.textureLoader;
    if (sourceDef.uri) {
      const handler = options.manager.getHandler(sourceDef.uri);
      if (handler !== null)
        loader2 = handler;
    }
    return this.loadTextureImage(textureIndex, sourceIndex, loader2);
  }
  loadTextureImage(textureIndex, sourceIndex, loader2) {
    const parser = this;
    const json = this.json;
    const textureDef = json.textures[textureIndex];
    const sourceDef = json.images[sourceIndex];
    const cacheKey = (sourceDef.uri || sourceDef.bufferView) + ":" + textureDef.sampler;
    if (this.textureCache[cacheKey]) {
      return this.textureCache[cacheKey];
    }
    const promise = this.loadImageSource(sourceIndex, loader2).then(function(texture) {
      texture.flipY = false;
      texture.name = textureDef.name || sourceDef.name || "";
      if (texture.name === "" && typeof sourceDef.uri === "string" && sourceDef.uri.startsWith("data:image/") === false) {
        texture.name = sourceDef.uri;
      }
      const samplers = json.samplers || {};
      const sampler = samplers[textureDef.sampler] || {};
      texture.magFilter = WEBGL_FILTERS[sampler.magFilter] || LinearFilter;
      texture.minFilter = WEBGL_FILTERS[sampler.minFilter] || LinearMipmapLinearFilter;
      texture.wrapS = WEBGL_WRAPPINGS[sampler.wrapS] || RepeatWrapping;
      texture.wrapT = WEBGL_WRAPPINGS[sampler.wrapT] || RepeatWrapping;
      parser.associations.set(texture, { textures: textureIndex });
      return texture;
    }).catch(function() {
      return null;
    });
    this.textureCache[cacheKey] = promise;
    return promise;
  }
  loadImageSource(sourceIndex, loader2) {
    const parser = this;
    const json = this.json;
    const options = this.options;
    if (this.sourceCache[sourceIndex] !== void 0) {
      return this.sourceCache[sourceIndex].then((texture) => texture.clone());
    }
    const sourceDef = json.images[sourceIndex];
    const URL2 = self.URL || self.webkitURL;
    let sourceURI = sourceDef.uri || "";
    let isObjectURL = false;
    if (sourceDef.bufferView !== void 0) {
      sourceURI = parser.getDependency("bufferView", sourceDef.bufferView).then(function(bufferView) {
        isObjectURL = true;
        const blob = new Blob([bufferView], { type: sourceDef.mimeType });
        sourceURI = URL2.createObjectURL(blob);
        return sourceURI;
      });
    } else if (sourceDef.uri === void 0) {
      throw new Error("THREE.GLTFLoader: Image " + sourceIndex + " is missing URI and bufferView");
    }
    const promise = Promise.resolve(sourceURI).then(function(sourceURI2) {
      return new Promise(function(resolve, reject) {
        let onLoad = resolve;
        if (loader2.isImageBitmapLoader === true) {
          onLoad = function(imageBitmap) {
            const texture = new Texture(imageBitmap);
            texture.needsUpdate = true;
            resolve(texture);
          };
        }
        loader2.load(LoaderUtils.resolveURL(sourceURI2, options.path), onLoad, void 0, reject);
      });
    }).then(function(texture) {
      if (isObjectURL === true) {
        URL2.revokeObjectURL(sourceURI);
      }
      texture.userData.mimeType = sourceDef.mimeType || getImageURIMimeType(sourceDef.uri);
      return texture;
    }).catch(function(error) {
      console.error("THREE.GLTFLoader: Couldn't load texture", sourceURI);
      throw error;
    });
    this.sourceCache[sourceIndex] = promise;
    return promise;
  }
  /**
   * Asynchronously assigns a texture to the given material parameters.
   * @param {Object} materialParams
   * @param {string} mapName
   * @param {Object} mapDef
   * @return {Promise<Texture>}
   */
  assignTexture(materialParams, mapName, mapDef, colorSpace) {
    const parser = this;
    return this.getDependency("texture", mapDef.index).then(function(texture) {
      if (!texture)
        return null;
      if (mapDef.texCoord !== void 0 && mapDef.texCoord > 0) {
        texture = texture.clone();
        texture.channel = mapDef.texCoord;
      }
      if (parser.extensions[EXTENSIONS.KHR_TEXTURE_TRANSFORM]) {
        const transform = mapDef.extensions !== void 0 ? mapDef.extensions[EXTENSIONS.KHR_TEXTURE_TRANSFORM] : void 0;
        if (transform) {
          const gltfReference = parser.associations.get(texture);
          texture = parser.extensions[EXTENSIONS.KHR_TEXTURE_TRANSFORM].extendTexture(texture, transform);
          parser.associations.set(texture, gltfReference);
        }
      }
      if (colorSpace !== void 0) {
        texture.colorSpace = colorSpace;
      }
      materialParams[mapName] = texture;
      return texture;
    });
  }
  /**
   * Assigns final material to a Mesh, Line, or Points instance. The instance
   * already has a material (generated from the glTF material options alone)
   * but reuse of the same glTF material may require multiple threejs materials
   * to accommodate different primitive types, defines, etc. New materials will
   * be created if necessary, and reused from a cache.
   * @param  {Object3D} mesh Mesh, Line, or Points instance.
   */
  assignFinalMaterial(mesh) {
    const geometry = mesh.geometry;
    let material = mesh.material;
    const useDerivativeTangents = geometry.attributes.tangent === void 0;
    const useVertexColors = geometry.attributes.color !== void 0;
    const useFlatShading = geometry.attributes.normal === void 0;
    if (mesh.isPoints) {
      const cacheKey = "PointsMaterial:" + material.uuid;
      let pointsMaterial = this.cache.get(cacheKey);
      if (!pointsMaterial) {
        pointsMaterial = new PointsMaterial();
        Material.prototype.copy.call(pointsMaterial, material);
        pointsMaterial.color.copy(material.color);
        pointsMaterial.map = material.map;
        pointsMaterial.sizeAttenuation = false;
        this.cache.add(cacheKey, pointsMaterial);
      }
      material = pointsMaterial;
    } else if (mesh.isLine) {
      const cacheKey = "LineBasicMaterial:" + material.uuid;
      let lineMaterial = this.cache.get(cacheKey);
      if (!lineMaterial) {
        lineMaterial = new LineBasicMaterial();
        Material.prototype.copy.call(lineMaterial, material);
        lineMaterial.color.copy(material.color);
        lineMaterial.map = material.map;
        this.cache.add(cacheKey, lineMaterial);
      }
      material = lineMaterial;
    }
    if (useDerivativeTangents || useVertexColors || useFlatShading) {
      let cacheKey = "ClonedMaterial:" + material.uuid + ":";
      if (useDerivativeTangents)
        cacheKey += "derivative-tangents:";
      if (useVertexColors)
        cacheKey += "vertex-colors:";
      if (useFlatShading)
        cacheKey += "flat-shading:";
      let cachedMaterial = this.cache.get(cacheKey);
      if (!cachedMaterial) {
        cachedMaterial = material.clone();
        if (useVertexColors)
          cachedMaterial.vertexColors = true;
        if (useFlatShading)
          cachedMaterial.flatShading = true;
        if (useDerivativeTangents) {
          if (cachedMaterial.normalScale)
            cachedMaterial.normalScale.y *= -1;
          if (cachedMaterial.clearcoatNormalScale)
            cachedMaterial.clearcoatNormalScale.y *= -1;
        }
        this.cache.add(cacheKey, cachedMaterial);
        this.associations.set(cachedMaterial, this.associations.get(material));
      }
      material = cachedMaterial;
    }
    mesh.material = material;
  }
  getMaterialType() {
    return MeshStandardMaterial;
  }
  /**
   * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#materials
   * @param {number} materialIndex
   * @return {Promise<Material>}
   */
  loadMaterial(materialIndex) {
    const parser = this;
    const json = this.json;
    const extensions = this.extensions;
    const materialDef = json.materials[materialIndex];
    let materialType;
    const materialParams = {};
    const materialExtensions = materialDef.extensions || {};
    const pending = [];
    if (materialExtensions[EXTENSIONS.KHR_MATERIALS_UNLIT]) {
      const kmuExtension = extensions[EXTENSIONS.KHR_MATERIALS_UNLIT];
      materialType = kmuExtension.getMaterialType();
      pending.push(kmuExtension.extendParams(materialParams, materialDef, parser));
    } else {
      const metallicRoughness = materialDef.pbrMetallicRoughness || {};
      materialParams.color = new Color(1, 1, 1);
      materialParams.opacity = 1;
      if (Array.isArray(metallicRoughness.baseColorFactor)) {
        const array = metallicRoughness.baseColorFactor;
        materialParams.color.fromArray(array);
        materialParams.opacity = array[3];
      }
      if (metallicRoughness.baseColorTexture !== void 0) {
        pending.push(parser.assignTexture(materialParams, "map", metallicRoughness.baseColorTexture, SRGBColorSpace));
      }
      materialParams.metalness = metallicRoughness.metallicFactor !== void 0 ? metallicRoughness.metallicFactor : 1;
      materialParams.roughness = metallicRoughness.roughnessFactor !== void 0 ? metallicRoughness.roughnessFactor : 1;
      if (metallicRoughness.metallicRoughnessTexture !== void 0) {
        pending.push(parser.assignTexture(materialParams, "metalnessMap", metallicRoughness.metallicRoughnessTexture));
        pending.push(parser.assignTexture(materialParams, "roughnessMap", metallicRoughness.metallicRoughnessTexture));
      }
      materialType = this._invokeOne(function(ext) {
        return ext.getMaterialType && ext.getMaterialType(materialIndex);
      });
      pending.push(Promise.all(this._invokeAll(function(ext) {
        return ext.extendMaterialParams && ext.extendMaterialParams(materialIndex, materialParams);
      })));
    }
    if (materialDef.doubleSided === true) {
      materialParams.side = DoubleSide;
    }
    const alphaMode = materialDef.alphaMode || ALPHA_MODES.OPAQUE;
    if (alphaMode === ALPHA_MODES.BLEND) {
      materialParams.transparent = true;
      materialParams.depthWrite = false;
    } else {
      materialParams.transparent = false;
      if (alphaMode === ALPHA_MODES.MASK) {
        materialParams.alphaTest = materialDef.alphaCutoff !== void 0 ? materialDef.alphaCutoff : 0.5;
      }
    }
    if (materialDef.normalTexture !== void 0 && materialType !== MeshBasicMaterial) {
      pending.push(parser.assignTexture(materialParams, "normalMap", materialDef.normalTexture));
      materialParams.normalScale = new Vector2(1, 1);
      if (materialDef.normalTexture.scale !== void 0) {
        const scale = materialDef.normalTexture.scale;
        materialParams.normalScale.set(scale, scale);
      }
    }
    if (materialDef.occlusionTexture !== void 0 && materialType !== MeshBasicMaterial) {
      pending.push(parser.assignTexture(materialParams, "aoMap", materialDef.occlusionTexture));
      if (materialDef.occlusionTexture.strength !== void 0) {
        materialParams.aoMapIntensity = materialDef.occlusionTexture.strength;
      }
    }
    if (materialDef.emissiveFactor !== void 0 && materialType !== MeshBasicMaterial) {
      materialParams.emissive = new Color().fromArray(materialDef.emissiveFactor);
    }
    if (materialDef.emissiveTexture !== void 0 && materialType !== MeshBasicMaterial) {
      pending.push(parser.assignTexture(materialParams, "emissiveMap", materialDef.emissiveTexture, SRGBColorSpace));
    }
    return Promise.all(pending).then(function() {
      const material = new materialType(materialParams);
      if (materialDef.name)
        material.name = materialDef.name;
      assignExtrasToUserData(material, materialDef);
      parser.associations.set(material, { materials: materialIndex });
      if (materialDef.extensions)
        addUnknownExtensionsToUserData(extensions, material, materialDef);
      return material;
    });
  }
  /** When Object3D instances are targeted by animation, they need unique names. */
  createUniqueName(originalName) {
    const sanitizedName = PropertyBinding.sanitizeNodeName(originalName || "");
    if (sanitizedName in this.nodeNamesUsed) {
      return sanitizedName + "_" + ++this.nodeNamesUsed[sanitizedName];
    } else {
      this.nodeNamesUsed[sanitizedName] = 0;
      return sanitizedName;
    }
  }
  /**
   * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#geometry
   *
   * Creates BufferGeometries from primitives.
   *
   * @param {Array<GLTF.Primitive>} primitives
   * @return {Promise<Array<BufferGeometry>>}
   */
  loadGeometries(primitives) {
    const parser = this;
    const extensions = this.extensions;
    const cache = this.primitiveCache;
    function createDracoPrimitive(primitive) {
      return extensions[EXTENSIONS.KHR_DRACO_MESH_COMPRESSION].decodePrimitive(primitive, parser).then(function(geometry) {
        return addPrimitiveAttributes(geometry, primitive, parser);
      });
    }
    const pending = [];
    for (let i = 0, il = primitives.length; i < il; i++) {
      const primitive = primitives[i];
      const cacheKey = createPrimitiveKey(primitive);
      const cached = cache[cacheKey];
      if (cached) {
        pending.push(cached.promise);
      } else {
        let geometryPromise;
        if (primitive.extensions && primitive.extensions[EXTENSIONS.KHR_DRACO_MESH_COMPRESSION]) {
          geometryPromise = createDracoPrimitive(primitive);
        } else {
          geometryPromise = addPrimitiveAttributes(new BufferGeometry(), primitive, parser);
        }
        cache[cacheKey] = { primitive, promise: geometryPromise };
        pending.push(geometryPromise);
      }
    }
    return Promise.all(pending);
  }
  /**
   * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#meshes
   * @param {number} meshIndex
   * @return {Promise<Group|Mesh|SkinnedMesh>}
   */
  loadMesh(meshIndex) {
    const parser = this;
    const json = this.json;
    const extensions = this.extensions;
    const meshDef = json.meshes[meshIndex];
    const primitives = meshDef.primitives;
    const pending = [];
    for (let i = 0, il = primitives.length; i < il; i++) {
      const material = primitives[i].material === void 0 ? createDefaultMaterial(this.cache) : this.getDependency("material", primitives[i].material);
      pending.push(material);
    }
    pending.push(parser.loadGeometries(primitives));
    return Promise.all(pending).then(function(results) {
      const materials = results.slice(0, results.length - 1);
      const geometries = results[results.length - 1];
      const meshes = [];
      for (let i = 0, il = geometries.length; i < il; i++) {
        const geometry = geometries[i];
        const primitive = primitives[i];
        let mesh;
        const material = materials[i];
        if (primitive.mode === WEBGL_CONSTANTS.TRIANGLES || primitive.mode === WEBGL_CONSTANTS.TRIANGLE_STRIP || primitive.mode === WEBGL_CONSTANTS.TRIANGLE_FAN || primitive.mode === void 0) {
          mesh = meshDef.isSkinnedMesh === true ? new SkinnedMesh(geometry, material) : new Mesh(geometry, material);
          if (mesh.isSkinnedMesh === true) {
            mesh.normalizeSkinWeights();
          }
          if (primitive.mode === WEBGL_CONSTANTS.TRIANGLE_STRIP) {
            mesh.geometry = toTrianglesDrawMode(mesh.geometry, TriangleStripDrawMode);
          } else if (primitive.mode === WEBGL_CONSTANTS.TRIANGLE_FAN) {
            mesh.geometry = toTrianglesDrawMode(mesh.geometry, TriangleFanDrawMode);
          }
        } else if (primitive.mode === WEBGL_CONSTANTS.LINES) {
          mesh = new LineSegments(geometry, material);
        } else if (primitive.mode === WEBGL_CONSTANTS.LINE_STRIP) {
          mesh = new Line(geometry, material);
        } else if (primitive.mode === WEBGL_CONSTANTS.LINE_LOOP) {
          mesh = new LineLoop(geometry, material);
        } else if (primitive.mode === WEBGL_CONSTANTS.POINTS) {
          mesh = new Points(geometry, material);
        } else {
          throw new Error("THREE.GLTFLoader: Primitive mode unsupported: " + primitive.mode);
        }
        if (Object.keys(mesh.geometry.morphAttributes).length > 0) {
          updateMorphTargets(mesh, meshDef);
        }
        mesh.name = parser.createUniqueName(meshDef.name || "mesh_" + meshIndex);
        assignExtrasToUserData(mesh, meshDef);
        if (primitive.extensions)
          addUnknownExtensionsToUserData(extensions, mesh, primitive);
        parser.assignFinalMaterial(mesh);
        meshes.push(mesh);
      }
      for (let i = 0, il = meshes.length; i < il; i++) {
        parser.associations.set(meshes[i], {
          meshes: meshIndex,
          primitives: i
        });
      }
      if (meshes.length === 1) {
        if (meshDef.extensions)
          addUnknownExtensionsToUserData(extensions, meshes[0], meshDef);
        return meshes[0];
      }
      const group = new Group();
      if (meshDef.extensions)
        addUnknownExtensionsToUserData(extensions, group, meshDef);
      parser.associations.set(group, { meshes: meshIndex });
      for (let i = 0, il = meshes.length; i < il; i++) {
        group.add(meshes[i]);
      }
      return group;
    });
  }
  /**
   * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#cameras
   * @param {number} cameraIndex
   * @return {Promise<THREE.Camera>}
   */
  loadCamera(cameraIndex) {
    let camera;
    const cameraDef = this.json.cameras[cameraIndex];
    const params = cameraDef[cameraDef.type];
    if (!params) {
      console.warn("THREE.GLTFLoader: Missing camera parameters.");
      return;
    }
    if (cameraDef.type === "perspective") {
      camera = new PerspectiveCamera(MathUtils.radToDeg(params.yfov), params.aspectRatio || 1, params.znear || 1, params.zfar || 2e6);
    } else if (cameraDef.type === "orthographic") {
      camera = new OrthographicCamera(-params.xmag, params.xmag, params.ymag, -params.ymag, params.znear, params.zfar);
    }
    if (cameraDef.name)
      camera.name = this.createUniqueName(cameraDef.name);
    assignExtrasToUserData(camera, cameraDef);
    return Promise.resolve(camera);
  }
  /**
   * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#skins
   * @param {number} skinIndex
   * @return {Promise<Skeleton>}
   */
  loadSkin(skinIndex) {
    const skinDef = this.json.skins[skinIndex];
    const pending = [];
    for (let i = 0, il = skinDef.joints.length; i < il; i++) {
      pending.push(this._loadNodeShallow(skinDef.joints[i]));
    }
    if (skinDef.inverseBindMatrices !== void 0) {
      pending.push(this.getDependency("accessor", skinDef.inverseBindMatrices));
    } else {
      pending.push(null);
    }
    return Promise.all(pending).then(function(results) {
      const inverseBindMatrices = results.pop();
      const jointNodes = results;
      const bones = [];
      const boneInverses = [];
      for (let i = 0, il = jointNodes.length; i < il; i++) {
        const jointNode = jointNodes[i];
        if (jointNode) {
          bones.push(jointNode);
          const mat = new Matrix4();
          if (inverseBindMatrices !== null) {
            mat.fromArray(inverseBindMatrices.array, i * 16);
          }
          boneInverses.push(mat);
        } else {
          console.warn('THREE.GLTFLoader: Joint "%s" could not be found.', skinDef.joints[i]);
        }
      }
      return new Skeleton(bones, boneInverses);
    });
  }
  /**
   * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#animations
   * @param {number} animationIndex
   * @return {Promise<AnimationClip>}
   */
  loadAnimation(animationIndex) {
    const json = this.json;
    const animationDef = json.animations[animationIndex];
    const animationName = animationDef.name ? animationDef.name : "animation_" + animationIndex;
    const pendingNodes = [];
    const pendingInputAccessors = [];
    const pendingOutputAccessors = [];
    const pendingSamplers = [];
    const pendingTargets = [];
    for (let i = 0, il = animationDef.channels.length; i < il; i++) {
      const channel = animationDef.channels[i];
      const sampler = animationDef.samplers[channel.sampler];
      const target = channel.target;
      const name = target.node;
      const input = animationDef.parameters !== void 0 ? animationDef.parameters[sampler.input] : sampler.input;
      const output = animationDef.parameters !== void 0 ? animationDef.parameters[sampler.output] : sampler.output;
      if (target.node === void 0)
        continue;
      pendingNodes.push(this.getDependency("node", name));
      pendingInputAccessors.push(this.getDependency("accessor", input));
      pendingOutputAccessors.push(this.getDependency("accessor", output));
      pendingSamplers.push(sampler);
      pendingTargets.push(target);
    }
    return Promise.all([
      Promise.all(pendingNodes),
      Promise.all(pendingInputAccessors),
      Promise.all(pendingOutputAccessors),
      Promise.all(pendingSamplers),
      Promise.all(pendingTargets)
    ]).then(function(dependencies) {
      const nodes = dependencies[0];
      const inputAccessors = dependencies[1];
      const outputAccessors = dependencies[2];
      const samplers = dependencies[3];
      const targets = dependencies[4];
      const tracks = [];
      for (let i = 0, il = nodes.length; i < il; i++) {
        const node = nodes[i];
        const inputAccessor = inputAccessors[i];
        const outputAccessor = outputAccessors[i];
        const sampler = samplers[i];
        const target = targets[i];
        if (node === void 0)
          continue;
        node.updateMatrix();
        let TypedKeyframeTrack;
        switch (PATH_PROPERTIES[target.path]) {
          case PATH_PROPERTIES.weights:
            TypedKeyframeTrack = NumberKeyframeTrack;
            break;
          case PATH_PROPERTIES.rotation:
            TypedKeyframeTrack = QuaternionKeyframeTrack;
            break;
          case PATH_PROPERTIES.position:
          case PATH_PROPERTIES.scale:
          default:
            TypedKeyframeTrack = VectorKeyframeTrack;
            break;
        }
        const targetName = node.name ? node.name : node.uuid;
        const interpolation = sampler.interpolation !== void 0 ? INTERPOLATION[sampler.interpolation] : InterpolateLinear;
        const targetNames = [];
        if (PATH_PROPERTIES[target.path] === PATH_PROPERTIES.weights) {
          node.traverse(function(object) {
            if (object.morphTargetInfluences) {
              targetNames.push(object.name ? object.name : object.uuid);
            }
          });
        } else {
          targetNames.push(targetName);
        }
        let outputArray = outputAccessor.array;
        if (outputAccessor.normalized) {
          const scale = getNormalizedComponentScale(outputArray.constructor);
          const scaled = new Float32Array(outputArray.length);
          for (let j = 0, jl = outputArray.length; j < jl; j++) {
            scaled[j] = outputArray[j] * scale;
          }
          outputArray = scaled;
        }
        for (let j = 0, jl = targetNames.length; j < jl; j++) {
          const track = new TypedKeyframeTrack(
            targetNames[j] + "." + PATH_PROPERTIES[target.path],
            inputAccessor.array,
            outputArray,
            interpolation
          );
          if (sampler.interpolation === "CUBICSPLINE") {
            track.createInterpolant = function InterpolantFactoryMethodGLTFCubicSpline(result) {
              const interpolantType = this instanceof QuaternionKeyframeTrack ? GLTFCubicSplineQuaternionInterpolant : GLTFCubicSplineInterpolant;
              return new interpolantType(this.times, this.values, this.getValueSize() / 3, result);
            };
            track.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline = true;
          }
          tracks.push(track);
        }
      }
      return new AnimationClip(animationName, void 0, tracks);
    });
  }
  createNodeMesh(nodeIndex) {
    const json = this.json;
    const parser = this;
    const nodeDef = json.nodes[nodeIndex];
    if (nodeDef.mesh === void 0)
      return null;
    return parser.getDependency("mesh", nodeDef.mesh).then(function(mesh) {
      const node = parser._getNodeRef(parser.meshCache, nodeDef.mesh, mesh);
      if (nodeDef.weights !== void 0) {
        node.traverse(function(o) {
          if (!o.isMesh)
            return;
          for (let i = 0, il = nodeDef.weights.length; i < il; i++) {
            o.morphTargetInfluences[i] = nodeDef.weights[i];
          }
        });
      }
      return node;
    });
  }
  /**
   * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#nodes-and-hierarchy
   * @param {number} nodeIndex
   * @return {Promise<Object3D>}
   */
  loadNode(nodeIndex) {
    const json = this.json;
    const parser = this;
    const nodeDef = json.nodes[nodeIndex];
    const nodePending = parser._loadNodeShallow(nodeIndex);
    const childPending = [];
    const childrenDef = nodeDef.children || [];
    for (let i = 0, il = childrenDef.length; i < il; i++) {
      childPending.push(parser.getDependency("node", childrenDef[i]));
    }
    const skeletonPending = nodeDef.skin === void 0 ? Promise.resolve(null) : parser.getDependency("skin", nodeDef.skin);
    return Promise.all([
      nodePending,
      Promise.all(childPending),
      skeletonPending
    ]).then(function(results) {
      const node = results[0];
      const children2 = results[1];
      const skeleton = results[2];
      if (skeleton !== null) {
        node.traverse(function(mesh) {
          if (!mesh.isSkinnedMesh)
            return;
          mesh.bind(skeleton, _identityMatrix);
        });
      }
      for (let i = 0, il = children2.length; i < il; i++) {
        node.add(children2[i]);
      }
      return node;
    });
  }
  // ._loadNodeShallow() parses a single node.
  // skin and child nodes are created and added in .loadNode() (no '_' prefix).
  _loadNodeShallow(nodeIndex) {
    const json = this.json;
    const extensions = this.extensions;
    const parser = this;
    if (this.nodeCache[nodeIndex] !== void 0) {
      return this.nodeCache[nodeIndex];
    }
    const nodeDef = json.nodes[nodeIndex];
    const nodeName = nodeDef.name ? parser.createUniqueName(nodeDef.name) : "";
    const pending = [];
    const meshPromise = parser._invokeOne(function(ext) {
      return ext.createNodeMesh && ext.createNodeMesh(nodeIndex);
    });
    if (meshPromise) {
      pending.push(meshPromise);
    }
    if (nodeDef.camera !== void 0) {
      pending.push(parser.getDependency("camera", nodeDef.camera).then(function(camera) {
        return parser._getNodeRef(parser.cameraCache, nodeDef.camera, camera);
      }));
    }
    parser._invokeAll(function(ext) {
      return ext.createNodeAttachment && ext.createNodeAttachment(nodeIndex);
    }).forEach(function(promise) {
      pending.push(promise);
    });
    this.nodeCache[nodeIndex] = Promise.all(pending).then(function(objects) {
      let node;
      if (nodeDef.isBone === true) {
        node = new Bone();
      } else if (objects.length > 1) {
        node = new Group();
      } else if (objects.length === 1) {
        node = objects[0];
      } else {
        node = new Object3D();
      }
      if (node !== objects[0]) {
        for (let i = 0, il = objects.length; i < il; i++) {
          node.add(objects[i]);
        }
      }
      if (nodeDef.name) {
        node.userData.name = nodeDef.name;
        node.name = nodeName;
      }
      assignExtrasToUserData(node, nodeDef);
      if (nodeDef.extensions)
        addUnknownExtensionsToUserData(extensions, node, nodeDef);
      if (nodeDef.matrix !== void 0) {
        const matrix = new Matrix4();
        matrix.fromArray(nodeDef.matrix);
        node.applyMatrix4(matrix);
      } else {
        if (nodeDef.translation !== void 0) {
          node.position.fromArray(nodeDef.translation);
        }
        if (nodeDef.rotation !== void 0) {
          node.quaternion.fromArray(nodeDef.rotation);
        }
        if (nodeDef.scale !== void 0) {
          node.scale.fromArray(nodeDef.scale);
        }
      }
      if (!parser.associations.has(node)) {
        parser.associations.set(node, {});
      }
      parser.associations.get(node).nodes = nodeIndex;
      return node;
    });
    return this.nodeCache[nodeIndex];
  }
  /**
   * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#scenes
   * @param {number} sceneIndex
   * @return {Promise<Group>}
   */
  loadScene(sceneIndex) {
    const extensions = this.extensions;
    const sceneDef = this.json.scenes[sceneIndex];
    const parser = this;
    const scene = new Group();
    if (sceneDef.name)
      scene.name = parser.createUniqueName(sceneDef.name);
    assignExtrasToUserData(scene, sceneDef);
    if (sceneDef.extensions)
      addUnknownExtensionsToUserData(extensions, scene, sceneDef);
    const nodeIds = sceneDef.nodes || [];
    const pending = [];
    for (let i = 0, il = nodeIds.length; i < il; i++) {
      pending.push(parser.getDependency("node", nodeIds[i]));
    }
    return Promise.all(pending).then(function(nodes) {
      for (let i = 0, il = nodes.length; i < il; i++) {
        scene.add(nodes[i]);
      }
      const reduceAssociations = (node) => {
        const reducedAssociations = /* @__PURE__ */ new Map();
        for (const [key, value] of parser.associations) {
          if (key instanceof Material || key instanceof Texture) {
            reducedAssociations.set(key, value);
          }
        }
        node.traverse((node2) => {
          const mappings = parser.associations.get(node2);
          if (mappings != null) {
            reducedAssociations.set(node2, mappings);
          }
        });
        return reducedAssociations;
      };
      parser.associations = reduceAssociations(scene);
      return scene;
    });
  }
};
function computeBounds(geometry, primitiveDef, parser) {
  const attributes = primitiveDef.attributes;
  const box = new Box3();
  if (attributes.POSITION !== void 0) {
    const accessor = parser.json.accessors[attributes.POSITION];
    const min = accessor.min;
    const max = accessor.max;
    if (min !== void 0 && max !== void 0) {
      box.set(
        new Vector3(min[0], min[1], min[2]),
        new Vector3(max[0], max[1], max[2])
      );
      if (accessor.normalized) {
        const boxScale = getNormalizedComponentScale(WEBGL_COMPONENT_TYPES[accessor.componentType]);
        box.min.multiplyScalar(boxScale);
        box.max.multiplyScalar(boxScale);
      }
    } else {
      console.warn("THREE.GLTFLoader: Missing min/max properties for accessor POSITION.");
      return;
    }
  } else {
    return;
  }
  const targets = primitiveDef.targets;
  if (targets !== void 0) {
    const maxDisplacement = new Vector3();
    const vector = new Vector3();
    for (let i = 0, il = targets.length; i < il; i++) {
      const target = targets[i];
      if (target.POSITION !== void 0) {
        const accessor = parser.json.accessors[target.POSITION];
        const min = accessor.min;
        const max = accessor.max;
        if (min !== void 0 && max !== void 0) {
          vector.setX(Math.max(Math.abs(min[0]), Math.abs(max[0])));
          vector.setY(Math.max(Math.abs(min[1]), Math.abs(max[1])));
          vector.setZ(Math.max(Math.abs(min[2]), Math.abs(max[2])));
          if (accessor.normalized) {
            const boxScale = getNormalizedComponentScale(WEBGL_COMPONENT_TYPES[accessor.componentType]);
            vector.multiplyScalar(boxScale);
          }
          maxDisplacement.max(vector);
        } else {
          console.warn("THREE.GLTFLoader: Missing min/max properties for accessor POSITION.");
        }
      }
    }
    box.expandByVector(maxDisplacement);
  }
  geometry.boundingBox = box;
  const sphere = new Sphere();
  box.getCenter(sphere.center);
  sphere.radius = box.min.distanceTo(box.max) / 2;
  geometry.boundingSphere = sphere;
}
function addPrimitiveAttributes(geometry, primitiveDef, parser) {
  const attributes = primitiveDef.attributes;
  const pending = [];
  function assignAttributeAccessor(accessorIndex, attributeName) {
    return parser.getDependency("accessor", accessorIndex).then(function(accessor) {
      geometry.setAttribute(attributeName, accessor);
    });
  }
  for (const gltfAttributeName in attributes) {
    const threeAttributeName = ATTRIBUTES[gltfAttributeName] || gltfAttributeName.toLowerCase();
    if (threeAttributeName in geometry.attributes)
      continue;
    pending.push(assignAttributeAccessor(attributes[gltfAttributeName], threeAttributeName));
  }
  if (primitiveDef.indices !== void 0 && !geometry.index) {
    const accessor = parser.getDependency("accessor", primitiveDef.indices).then(function(accessor2) {
      geometry.setIndex(accessor2);
    });
    pending.push(accessor);
  }
  assignExtrasToUserData(geometry, primitiveDef);
  computeBounds(geometry, primitiveDef, parser);
  return Promise.all(pending).then(function() {
    return primitiveDef.targets !== void 0 ? addMorphTargets(geometry, primitiveDef.targets, parser) : geometry;
  });
}

// node_modules/three/examples/jsm/utils/WorkerPool.js
var WorkerPool = class {
  constructor(pool = 4) {
    this.pool = pool;
    this.queue = [];
    this.workers = [];
    this.workersResolve = [];
    this.workerStatus = 0;
  }
  _initWorker(workerId) {
    if (!this.workers[workerId]) {
      const worker = this.workerCreator();
      worker.addEventListener("message", this._onMessage.bind(this, workerId));
      this.workers[workerId] = worker;
    }
  }
  _getIdleWorker() {
    for (let i = 0; i < this.pool; i++)
      if (!(this.workerStatus & 1 << i))
        return i;
    return -1;
  }
  _onMessage(workerId, msg) {
    const resolve = this.workersResolve[workerId];
    resolve && resolve(msg);
    if (this.queue.length) {
      const { resolve: resolve2, msg: msg2, transfer } = this.queue.shift();
      this.workersResolve[workerId] = resolve2;
      this.workers[workerId].postMessage(msg2, transfer);
    } else {
      this.workerStatus ^= 1 << workerId;
    }
  }
  setWorkerCreator(workerCreator) {
    this.workerCreator = workerCreator;
  }
  setWorkerLimit(pool) {
    this.pool = pool;
  }
  postMessage(msg, transfer) {
    return new Promise((resolve) => {
      const workerId = this._getIdleWorker();
      if (workerId !== -1) {
        this._initWorker(workerId);
        this.workerStatus |= 1 << workerId;
        this.workersResolve[workerId] = resolve;
        this.workers[workerId].postMessage(msg, transfer);
      } else {
        this.queue.push({ resolve, msg, transfer });
      }
    });
  }
  dispose() {
    this.workers.forEach((worker) => worker.terminate());
    this.workersResolve.length = 0;
    this.workers.length = 0;
    this.queue.length = 0;
    this.workerStatus = 0;
  }
};

// node_modules/three/examples/jsm/libs/ktx-parse.module.js
var t = 0;
var n = 2;
var p = 1;
var x = 2;
var nt = 0;
var ct = 9;
var gt = 15;
var yt = 16;
var dt = 22;
var Ot = 37;
var Ft = 43;
var $t = 76;
var se = 83;
var pe = 97;
var xe = 100;
var de = 103;
var Ae = 109;
var Si = class {
  constructor() {
    this.vkFormat = 0, this.typeSize = 1, this.pixelWidth = 0, this.pixelHeight = 0, this.pixelDepth = 0, this.layerCount = 0, this.faceCount = 1, this.supercompressionScheme = 0, this.levels = [], this.dataFormatDescriptor = [{ vendorId: 0, descriptorType: 0, descriptorBlockSize: 0, versionNumber: 2, colorModel: 0, colorPrimaries: 1, transferFunction: 2, flags: 0, texelBlockDimension: [0, 0, 0, 0], bytesPlane: [0, 0, 0, 0, 0, 0, 0, 0], samples: [] }], this.keyValue = {}, this.globalData = null;
  }
};
var Ii = class {
  constructor(t2, e, n2, i) {
    this._dataView = new DataView(t2.buffer, t2.byteOffset + e, n2), this._littleEndian = i, this._offset = 0;
  }
  _nextUint8() {
    const t2 = this._dataView.getUint8(this._offset);
    return this._offset += 1, t2;
  }
  _nextUint16() {
    const t2 = this._dataView.getUint16(this._offset, this._littleEndian);
    return this._offset += 2, t2;
  }
  _nextUint32() {
    const t2 = this._dataView.getUint32(this._offset, this._littleEndian);
    return this._offset += 4, t2;
  }
  _nextUint64() {
    const t2 = this._dataView.getUint32(this._offset, this._littleEndian) + 2 ** 32 * this._dataView.getUint32(this._offset + 4, this._littleEndian);
    return this._offset += 8, t2;
  }
  _nextInt32() {
    const t2 = this._dataView.getInt32(this._offset, this._littleEndian);
    return this._offset += 4, t2;
  }
  _skip(t2) {
    return this._offset += t2, this;
  }
  _scan(t2, e = 0) {
    const n2 = this._offset;
    let i = 0;
    for (; this._dataView.getUint8(this._offset) !== e && i < t2; )
      i++, this._offset++;
    return i < t2 && this._offset++, new Uint8Array(this._dataView.buffer, this._dataView.byteOffset + n2, i);
  }
};
var Oi = new Uint8Array([0]);
var Ti = [171, 75, 84, 88, 32, 50, 48, 187, 13, 10, 26, 10];
function Ei(t2) {
  return "undefined" != typeof TextDecoder ? new TextDecoder().decode(t2) : Buffer.from(t2).toString("utf8");
}
function Pi(t2) {
  const e = new Uint8Array(t2.buffer, t2.byteOffset, Ti.length);
  if (e[0] !== Ti[0] || e[1] !== Ti[1] || e[2] !== Ti[2] || e[3] !== Ti[3] || e[4] !== Ti[4] || e[5] !== Ti[5] || e[6] !== Ti[6] || e[7] !== Ti[7] || e[8] !== Ti[8] || e[9] !== Ti[9] || e[10] !== Ti[10] || e[11] !== Ti[11])
    throw new Error("Missing KTX 2.0 identifier.");
  const n2 = new Si(), i = 17 * Uint32Array.BYTES_PER_ELEMENT, s = new Ii(t2, Ti.length, i, true);
  n2.vkFormat = s._nextUint32(), n2.typeSize = s._nextUint32(), n2.pixelWidth = s._nextUint32(), n2.pixelHeight = s._nextUint32(), n2.pixelDepth = s._nextUint32(), n2.layerCount = s._nextUint32(), n2.faceCount = s._nextUint32();
  const a = s._nextUint32();
  n2.supercompressionScheme = s._nextUint32();
  const r = s._nextUint32(), o = s._nextUint32(), l = s._nextUint32(), f = s._nextUint32(), U = s._nextUint64(), c = s._nextUint64(), h = new Ii(t2, Ti.length + i, 3 * a * 8, true);
  for (let e2 = 0; e2 < a; e2++)
    n2.levels.push({ levelData: new Uint8Array(t2.buffer, t2.byteOffset + h._nextUint64(), h._nextUint64()), uncompressedByteLength: h._nextUint64() });
  const _ = new Ii(t2, r, o, true), p2 = { vendorId: _._skip(4)._nextUint16(), descriptorType: _._nextUint16(), versionNumber: _._nextUint16(), descriptorBlockSize: _._nextUint16(), colorModel: _._nextUint8(), colorPrimaries: _._nextUint8(), transferFunction: _._nextUint8(), flags: _._nextUint8(), texelBlockDimension: [_._nextUint8(), _._nextUint8(), _._nextUint8(), _._nextUint8()], bytesPlane: [_._nextUint8(), _._nextUint8(), _._nextUint8(), _._nextUint8(), _._nextUint8(), _._nextUint8(), _._nextUint8(), _._nextUint8()], samples: [] }, g2 = (p2.descriptorBlockSize / 4 - 6) / 4;
  for (let t3 = 0; t3 < g2; t3++) {
    const e2 = { bitOffset: _._nextUint16(), bitLength: _._nextUint8(), channelType: _._nextUint8(), samplePosition: [_._nextUint8(), _._nextUint8(), _._nextUint8(), _._nextUint8()], sampleLower: -Infinity, sampleUpper: Infinity };
    64 & e2.channelType ? (e2.sampleLower = _._nextInt32(), e2.sampleUpper = _._nextInt32()) : (e2.sampleLower = _._nextUint32(), e2.sampleUpper = _._nextUint32()), p2.samples[t3] = e2;
  }
  n2.dataFormatDescriptor.length = 0, n2.dataFormatDescriptor.push(p2);
  const y = new Ii(t2, l, f, true);
  for (; y._offset < f; ) {
    const t3 = y._nextUint32(), e2 = y._scan(t3), i2 = Ei(e2), s2 = y._scan(t3 - e2.byteLength);
    n2.keyValue[i2] = i2.match(/^ktx/i) ? Ei(s2) : s2, y._offset % 4 && y._skip(4 - y._offset % 4);
  }
  if (c <= 0)
    return n2;
  const x2 = new Ii(t2, U, c, true), u = x2._nextUint16(), b = x2._nextUint16(), d = x2._nextUint32(), m = x2._nextUint32(), w = x2._nextUint32(), D = x2._nextUint32(), B2 = [];
  for (let t3 = 0; t3 < a; t3++)
    B2.push({ imageFlags: x2._nextUint32(), rgbSliceByteOffset: x2._nextUint32(), rgbSliceByteLength: x2._nextUint32(), alphaSliceByteOffset: x2._nextUint32(), alphaSliceByteLength: x2._nextUint32() });
  const L = U + x2._offset, A2 = L + d, k = A2 + m, v = k + w, S = new Uint8Array(t2.buffer, t2.byteOffset + L, d), I2 = new Uint8Array(t2.buffer, t2.byteOffset + A2, m), O = new Uint8Array(t2.buffer, t2.byteOffset + k, w), T = new Uint8Array(t2.buffer, t2.byteOffset + v, D);
  return n2.globalData = { endpointCount: u, selectorCount: b, imageDescs: B2, endpointsData: S, selectorsData: I2, tablesData: O, extendedData: T }, n2;
}

// node_modules/three/examples/jsm/libs/zstddec.module.js
var A;
var I;
var B;
var g = { env: { emscripten_notify_memory_growth: function(A2) {
  B = new Uint8Array(I.exports.memory.buffer);
} } };
var Q = class {
  init() {
    return A || (A = "undefined" != typeof fetch ? fetch("data:application/wasm;base64," + C).then((A2) => A2.arrayBuffer()).then((A2) => WebAssembly.instantiate(A2, g)).then(this._init) : WebAssembly.instantiate(Buffer.from(C, "base64"), g).then(this._init), A);
  }
  _init(A2) {
    I = A2.instance, g.env.emscripten_notify_memory_growth(0);
  }
  decode(A2, g2 = 0) {
    if (!I)
      throw new Error("ZSTDDecoder: Await .init() before decoding.");
    const Q2 = A2.byteLength, C2 = I.exports.malloc(Q2);
    B.set(A2, C2), g2 = g2 || Number(I.exports.ZSTD_findDecompressedSize(C2, Q2));
    const E = I.exports.malloc(g2), i = I.exports.ZSTD_decompress(E, g2, C2, Q2), D = B.slice(E, E + i);
    return I.exports.free(C2), I.exports.free(E), D;
  }
};
var C = "AGFzbQEAAAABpQEVYAF/AX9gAn9/AGADf39/AX9gBX9/f39/AX9gAX8AYAJ/fwF/YAR/f39/AX9gA39/fwBgBn9/f39/fwF/YAd/f39/f39/AX9gAn9/AX5gAn5+AX5gAABgBX9/f39/AGAGf39/f39/AGAIf39/f39/f38AYAl/f39/f39/f38AYAABf2AIf39/f39/f38Bf2ANf39/f39/f39/f39/fwF/YAF/AX4CJwEDZW52H2Vtc2NyaXB0ZW5fbm90aWZ5X21lbW9yeV9ncm93dGgABANpaAEFAAAFAgEFCwACAQABAgIFBQcAAwABDgsBAQcAEhMHAAUBDAQEAAANBwQCAgYCBAgDAwMDBgEACQkHBgICAAYGAgQUBwYGAwIGAAMCAQgBBwUGCgoEEQAEBAEIAwgDBQgDEA8IAAcABAUBcAECAgUEAQCAAgYJAX8BQaCgwAILB2AHBm1lbW9yeQIABm1hbGxvYwAoBGZyZWUAJgxaU1REX2lzRXJyb3IAaBlaU1REX2ZpbmREZWNvbXByZXNzZWRTaXplAFQPWlNURF9kZWNvbXByZXNzAEoGX3N0YXJ0ACQJBwEAQQELASQKussBaA8AIAAgACgCBCABajYCBAsZACAAKAIAIAAoAgRBH3F0QQAgAWtBH3F2CwgAIABBiH9LC34BBH9BAyEBIAAoAgQiA0EgTQRAIAAoAggiASAAKAIQTwRAIAAQDQ8LIAAoAgwiAiABRgRAQQFBAiADQSBJGw8LIAAgASABIAJrIANBA3YiBCABIARrIAJJIgEbIgJrIgQ2AgggACADIAJBA3RrNgIEIAAgBCgAADYCAAsgAQsUAQF/IAAgARACIQIgACABEAEgAgv3AQECfyACRQRAIABCADcCACAAQQA2AhAgAEIANwIIQbh/DwsgACABNgIMIAAgAUEEajYCECACQQRPBEAgACABIAJqIgFBfGoiAzYCCCAAIAMoAAA2AgAgAUF/ai0AACIBBEAgAEEIIAEQFGs2AgQgAg8LIABBADYCBEF/DwsgACABNgIIIAAgAS0AACIDNgIAIAJBfmoiBEEBTQRAIARBAWtFBEAgACABLQACQRB0IANyIgM2AgALIAAgAS0AAUEIdCADajYCAAsgASACakF/ai0AACIBRQRAIABBADYCBEFsDwsgAEEoIAEQFCACQQN0ams2AgQgAgsWACAAIAEpAAA3AAAgACABKQAINwAICy8BAX8gAUECdEGgHWooAgAgACgCAEEgIAEgACgCBGprQR9xdnEhAiAAIAEQASACCyEAIAFCz9bTvtLHq9lCfiAAfEIfiUKHla+vmLbem55/fgsdAQF/IAAoAgggACgCDEYEfyAAKAIEQSBGBUEACwuCBAEDfyACQYDAAE8EQCAAIAEgAhBnIAAPCyAAIAJqIQMCQCAAIAFzQQNxRQRAAkAgAkEBSARAIAAhAgwBCyAAQQNxRQRAIAAhAgwBCyAAIQIDQCACIAEtAAA6AAAgAUEBaiEBIAJBAWoiAiADTw0BIAJBA3ENAAsLAkAgA0F8cSIEQcAASQ0AIAIgBEFAaiIFSw0AA0AgAiABKAIANgIAIAIgASgCBDYCBCACIAEoAgg2AgggAiABKAIMNgIMIAIgASgCEDYCECACIAEoAhQ2AhQgAiABKAIYNgIYIAIgASgCHDYCHCACIAEoAiA2AiAgAiABKAIkNgIkIAIgASgCKDYCKCACIAEoAiw2AiwgAiABKAIwNgIwIAIgASgCNDYCNCACIAEoAjg2AjggAiABKAI8NgI8IAFBQGshASACQUBrIgIgBU0NAAsLIAIgBE8NAQNAIAIgASgCADYCACABQQRqIQEgAkEEaiICIARJDQALDAELIANBBEkEQCAAIQIMAQsgA0F8aiIEIABJBEAgACECDAELIAAhAgNAIAIgAS0AADoAACACIAEtAAE6AAEgAiABLQACOgACIAIgAS0AAzoAAyABQQRqIQEgAkEEaiICIARNDQALCyACIANJBEADQCACIAEtAAA6AAAgAUEBaiEBIAJBAWoiAiADRw0ACwsgAAsMACAAIAEpAAA3AAALQQECfyAAKAIIIgEgACgCEEkEQEEDDwsgACAAKAIEIgJBB3E2AgQgACABIAJBA3ZrIgE2AgggACABKAAANgIAQQALDAAgACABKAIANgAAC/cCAQJ/AkAgACABRg0AAkAgASACaiAASwRAIAAgAmoiBCABSw0BCyAAIAEgAhALDwsgACABc0EDcSEDAkACQCAAIAFJBEAgAwRAIAAhAwwDCyAAQQNxRQRAIAAhAwwCCyAAIQMDQCACRQ0EIAMgAS0AADoAACABQQFqIQEgAkF/aiECIANBAWoiA0EDcQ0ACwwBCwJAIAMNACAEQQNxBEADQCACRQ0FIAAgAkF/aiICaiIDIAEgAmotAAA6AAAgA0EDcQ0ACwsgAkEDTQ0AA0AgACACQXxqIgJqIAEgAmooAgA2AgAgAkEDSw0ACwsgAkUNAgNAIAAgAkF/aiICaiABIAJqLQAAOgAAIAINAAsMAgsgAkEDTQ0AIAIhBANAIAMgASgCADYCACABQQRqIQEgA0EEaiEDIARBfGoiBEEDSw0ACyACQQNxIQILIAJFDQADQCADIAEtAAA6AAAgA0EBaiEDIAFBAWohASACQX9qIgINAAsLIAAL8wICAn8BfgJAIAJFDQAgACACaiIDQX9qIAE6AAAgACABOgAAIAJBA0kNACADQX5qIAE6AAAgACABOgABIANBfWogAToAACAAIAE6AAIgAkEHSQ0AIANBfGogAToAACAAIAE6AAMgAkEJSQ0AIABBACAAa0EDcSIEaiIDIAFB/wFxQYGChAhsIgE2AgAgAyACIARrQXxxIgRqIgJBfGogATYCACAEQQlJDQAgAyABNgIIIAMgATYCBCACQXhqIAE2AgAgAkF0aiABNgIAIARBGUkNACADIAE2AhggAyABNgIUIAMgATYCECADIAE2AgwgAkFwaiABNgIAIAJBbGogATYCACACQWhqIAE2AgAgAkFkaiABNgIAIAQgA0EEcUEYciIEayICQSBJDQAgAa0iBUIghiAFhCEFIAMgBGohAQNAIAEgBTcDGCABIAU3AxAgASAFNwMIIAEgBTcDACABQSBqIQEgAkFgaiICQR9LDQALCyAACy8BAn8gACgCBCAAKAIAQQJ0aiICLQACIQMgACACLwEAIAEgAi0AAxAIajYCACADCy8BAn8gACgCBCAAKAIAQQJ0aiICLQACIQMgACACLwEAIAEgAi0AAxAFajYCACADCx8AIAAgASACKAIEEAg2AgAgARAEGiAAIAJBCGo2AgQLCAAgAGdBH3MLugUBDX8jAEEQayIKJAACfyAEQQNNBEAgCkEANgIMIApBDGogAyAEEAsaIAAgASACIApBDGpBBBAVIgBBbCAAEAMbIAAgACAESxsMAQsgAEEAIAEoAgBBAXRBAmoQECENQVQgAygAACIGQQ9xIgBBCksNABogAiAAQQVqNgIAIAMgBGoiAkF8aiEMIAJBeWohDiACQXtqIRAgAEEGaiELQQQhBSAGQQR2IQRBICAAdCIAQQFyIQkgASgCACEPQQAhAiADIQYCQANAIAlBAkggAiAPS3JFBEAgAiEHAkAgCARAA0AgBEH//wNxQf//A0YEQCAHQRhqIQcgBiAQSQR/IAZBAmoiBigAACAFdgUgBUEQaiEFIARBEHYLIQQMAQsLA0AgBEEDcSIIQQNGBEAgBUECaiEFIARBAnYhBCAHQQNqIQcMAQsLIAcgCGoiByAPSw0EIAVBAmohBQNAIAIgB0kEQCANIAJBAXRqQQA7AQAgAkEBaiECDAELCyAGIA5LQQAgBiAFQQN1aiIHIAxLG0UEQCAHKAAAIAVBB3EiBXYhBAwCCyAEQQJ2IQQLIAYhBwsCfyALQX9qIAQgAEF/anEiBiAAQQF0QX9qIgggCWsiEUkNABogBCAIcSIEQQAgESAEIABIG2shBiALCyEIIA0gAkEBdGogBkF/aiIEOwEAIAlBASAGayAEIAZBAUgbayEJA0AgCSAASARAIABBAXUhACALQX9qIQsMAQsLAn8gByAOS0EAIAcgBSAIaiIFQQN1aiIGIAxLG0UEQCAFQQdxDAELIAUgDCIGIAdrQQN0awshBSACQQFqIQIgBEUhCCAGKAAAIAVBH3F2IQQMAQsLQWwgCUEBRyAFQSBKcg0BGiABIAJBf2o2AgAgBiAFQQdqQQN1aiADawwBC0FQCyEAIApBEGokACAACwkAQQFBBSAAGwsMACAAIAEoAAA2AAALqgMBCn8jAEHwAGsiCiQAIAJBAWohDiAAQQhqIQtBgIAEIAVBf2p0QRB1IQxBACECQQEhBkEBIAV0IglBf2oiDyEIA0AgAiAORkUEQAJAIAEgAkEBdCINai8BACIHQf//A0YEQCALIAhBA3RqIAI2AgQgCEF/aiEIQQEhBwwBCyAGQQAgDCAHQRB0QRB1ShshBgsgCiANaiAHOwEAIAJBAWohAgwBCwsgACAFNgIEIAAgBjYCACAJQQN2IAlBAXZqQQNqIQxBACEAQQAhBkEAIQIDQCAGIA5GBEADQAJAIAAgCUYNACAKIAsgAEEDdGoiASgCBCIGQQF0aiICIAIvAQAiAkEBajsBACABIAUgAhAUayIIOgADIAEgAiAIQf8BcXQgCWs7AQAgASAEIAZBAnQiAmooAgA6AAIgASACIANqKAIANgIEIABBAWohAAwBCwsFIAEgBkEBdGouAQAhDUEAIQcDQCAHIA1ORQRAIAsgAkEDdGogBjYCBANAIAIgDGogD3EiAiAISw0ACyAHQQFqIQcMAQsLIAZBAWohBgwBCwsgCkHwAGokAAsjAEIAIAEQCSAAhUKHla+vmLbem55/fkLj3MqV/M7y9YV/fAsQACAAQn43AwggACABNgIACyQBAX8gAARAIAEoAgQiAgRAIAEoAgggACACEQEADwsgABAmCwsfACAAIAEgAi8BABAINgIAIAEQBBogACACQQRqNgIEC0oBAX9BoCAoAgAiASAAaiIAQX9MBEBBiCBBMDYCAEF/DwsCQCAAPwBBEHRNDQAgABBmDQBBiCBBMDYCAEF/DwtBoCAgADYCACABC9cBAQh/Qbp/IQoCQCACKAIEIgggAigCACIJaiIOIAEgAGtLDQBBbCEKIAkgBCADKAIAIgtrSw0AIAAgCWoiBCACKAIIIgxrIQ0gACABQWBqIg8gCyAJQQAQKSADIAkgC2o2AgACQAJAIAwgBCAFa00EQCANIQUMAQsgDCAEIAZrSw0CIAcgDSAFayIAaiIBIAhqIAdNBEAgBCABIAgQDxoMAgsgBCABQQAgAGsQDyEBIAIgACAIaiIINgIEIAEgAGshBAsgBCAPIAUgCEEBECkLIA4hCgsgCgubAgEBfyMAQYABayINJAAgDSADNgJ8AkAgAkEDSwRAQX8hCQwBCwJAAkACQAJAIAJBAWsOAwADAgELIAZFBEBBuH8hCQwEC0FsIQkgBS0AACICIANLDQMgACAHIAJBAnQiAmooAgAgAiAIaigCABA7IAEgADYCAEEBIQkMAwsgASAJNgIAQQAhCQwCCyAKRQRAQWwhCQwCC0EAIQkgC0UgDEEZSHINAUEIIAR0QQhqIQBBACECA0AgAiAATw0CIAJBQGshAgwAAAsAC0FsIQkgDSANQfwAaiANQfgAaiAFIAYQFSICEAMNACANKAJ4IgMgBEsNACAAIA0gDSgCfCAHIAggAxAYIAEgADYCACACIQkLIA1BgAFqJAAgCQsLACAAIAEgAhALGgsQACAALwAAIAAtAAJBEHRyCy8AAn9BuH8gAUEISQ0AGkFyIAAoAAQiAEF3Sw0AGkG4fyAAQQhqIgAgACABSxsLCwkAIAAgATsAAAsDAAELigYBBX8gACAAKAIAIgVBfnE2AgBBACAAIAVBAXZqQYQgKAIAIgQgAEYbIQECQAJAIAAoAgQiAkUNACACKAIAIgNBAXENACACQQhqIgUgA0EBdkF4aiIDQQggA0EISxtnQR9zQQJ0QYAfaiIDKAIARgRAIAMgAigCDDYCAAsgAigCCCIDBEAgAyACKAIMNgIECyACKAIMIgMEQCADIAIoAgg2AgALIAIgAigCACAAKAIAQX5xajYCAEGEICEAAkACQCABRQ0AIAEgAjYCBCABKAIAIgNBAXENASADQQF2QXhqIgNBCCADQQhLG2dBH3NBAnRBgB9qIgMoAgAgAUEIakYEQCADIAEoAgw2AgALIAEoAggiAwRAIAMgASgCDDYCBAsgASgCDCIDBEAgAyABKAIINgIAQYQgKAIAIQQLIAIgAigCACABKAIAQX5xajYCACABIARGDQAgASABKAIAQQF2akEEaiEACyAAIAI2AgALIAIoAgBBAXZBeGoiAEEIIABBCEsbZ0Efc0ECdEGAH2oiASgCACEAIAEgBTYCACACIAA2AgwgAkEANgIIIABFDQEgACAFNgIADwsCQCABRQ0AIAEoAgAiAkEBcQ0AIAJBAXZBeGoiAkEIIAJBCEsbZ0Efc0ECdEGAH2oiAigCACABQQhqRgRAIAIgASgCDDYCAAsgASgCCCICBEAgAiABKAIMNgIECyABKAIMIgIEQCACIAEoAgg2AgBBhCAoAgAhBAsgACAAKAIAIAEoAgBBfnFqIgI2AgACQCABIARHBEAgASABKAIAQQF2aiAANgIEIAAoAgAhAgwBC0GEICAANgIACyACQQF2QXhqIgFBCCABQQhLG2dBH3NBAnRBgB9qIgIoAgAhASACIABBCGoiAjYCACAAIAE2AgwgAEEANgIIIAFFDQEgASACNgIADwsgBUEBdkF4aiIBQQggAUEISxtnQR9zQQJ0QYAfaiICKAIAIQEgAiAAQQhqIgI2AgAgACABNgIMIABBADYCCCABRQ0AIAEgAjYCAAsLDgAgAARAIABBeGoQJQsLgAIBA38CQCAAQQ9qQXhxQYQgKAIAKAIAQQF2ayICEB1Bf0YNAAJAQYQgKAIAIgAoAgAiAUEBcQ0AIAFBAXZBeGoiAUEIIAFBCEsbZ0Efc0ECdEGAH2oiASgCACAAQQhqRgRAIAEgACgCDDYCAAsgACgCCCIBBEAgASAAKAIMNgIECyAAKAIMIgFFDQAgASAAKAIINgIAC0EBIQEgACAAKAIAIAJBAXRqIgI2AgAgAkEBcQ0AIAJBAXZBeGoiAkEIIAJBCEsbZ0Efc0ECdEGAH2oiAygCACECIAMgAEEIaiIDNgIAIAAgAjYCDCAAQQA2AgggAkUNACACIAM2AgALIAELtwIBA38CQAJAIABBASAAGyICEDgiAA0AAkACQEGEICgCACIARQ0AIAAoAgAiA0EBcQ0AIAAgA0EBcjYCACADQQF2QXhqIgFBCCABQQhLG2dBH3NBAnRBgB9qIgEoAgAgAEEIakYEQCABIAAoAgw2AgALIAAoAggiAQRAIAEgACgCDDYCBAsgACgCDCIBBEAgASAAKAIINgIACyACECchAkEAIQFBhCAoAgAhACACDQEgACAAKAIAQX5xNgIAQQAPCyACQQ9qQXhxIgMQHSICQX9GDQIgAkEHakF4cSIAIAJHBEAgACACaxAdQX9GDQMLAkBBhCAoAgAiAUUEQEGAICAANgIADAELIAAgATYCBAtBhCAgADYCACAAIANBAXRBAXI2AgAMAQsgAEUNAQsgAEEIaiEBCyABC7kDAQJ/IAAgA2ohBQJAIANBB0wEQANAIAAgBU8NAiAAIAItAAA6AAAgAEEBaiEAIAJBAWohAgwAAAsACyAEQQFGBEACQCAAIAJrIgZBB00EQCAAIAItAAA6AAAgACACLQABOgABIAAgAi0AAjoAAiAAIAItAAM6AAMgAEEEaiACIAZBAnQiBkHAHmooAgBqIgIQFyACIAZB4B5qKAIAayECDAELIAAgAhAMCyACQQhqIQIgAEEIaiEACwJAAkACQAJAIAUgAU0EQCAAIANqIQEgBEEBRyAAIAJrQQ9Kcg0BA0AgACACEAwgAkEIaiECIABBCGoiACABSQ0ACwwFCyAAIAFLBEAgACEBDAQLIARBAUcgACACa0EPSnINASAAIQMgAiEEA0AgAyAEEAwgBEEIaiEEIANBCGoiAyABSQ0ACwwCCwNAIAAgAhAHIAJBEGohAiAAQRBqIgAgAUkNAAsMAwsgACEDIAIhBANAIAMgBBAHIARBEGohBCADQRBqIgMgAUkNAAsLIAIgASAAa2ohAgsDQCABIAVPDQEgASACLQAAOgAAIAFBAWohASACQQFqIQIMAAALAAsLQQECfyAAIAAoArjgASIDNgLE4AEgACgCvOABIQQgACABNgK84AEgACABIAJqNgK44AEgACABIAQgA2tqNgLA4AELpgEBAX8gACAAKALs4QEQFjYCyOABIABCADcD+OABIABCADcDuOABIABBwOABakIANwMAIABBqNAAaiIBQYyAgOAANgIAIABBADYCmOIBIABCADcDiOEBIABCAzcDgOEBIABBrNABakHgEikCADcCACAAQbTQAWpB6BIoAgA2AgAgACABNgIMIAAgAEGYIGo2AgggACAAQaAwajYCBCAAIABBEGo2AgALYQEBf0G4fyEDAkAgAUEDSQ0AIAIgABAhIgFBA3YiADYCCCACIAFBAXE2AgQgAiABQQF2QQNxIgM2AgACQCADQX9qIgFBAksNAAJAIAFBAWsOAgEAAgtBbA8LIAAhAwsgAwsMACAAIAEgAkEAEC4LiAQCA38CfiADEBYhBCAAQQBBKBAQIQAgBCACSwRAIAQPCyABRQRAQX8PCwJAAkAgA0EBRg0AIAEoAAAiBkGo6r5pRg0AQXYhAyAGQXBxQdDUtMIBRw0BQQghAyACQQhJDQEgAEEAQSgQECEAIAEoAAQhASAAQQE2AhQgACABrTcDAEEADwsgASACIAMQLyIDIAJLDQAgACADNgIYQXIhAyABIARqIgVBf2otAAAiAkEIcQ0AIAJBIHEiBkUEQEFwIQMgBS0AACIFQacBSw0BIAVBB3GtQgEgBUEDdkEKaq2GIgdCA4h+IAd8IQggBEEBaiEECyACQQZ2IQMgAkECdiEFAkAgAkEDcUF/aiICQQJLBEBBACECDAELAkACQAJAIAJBAWsOAgECAAsgASAEai0AACECIARBAWohBAwCCyABIARqLwAAIQIgBEECaiEEDAELIAEgBGooAAAhAiAEQQRqIQQLIAVBAXEhBQJ+AkACQAJAIANBf2oiA0ECTQRAIANBAWsOAgIDAQtCfyAGRQ0DGiABIARqMQAADAMLIAEgBGovAACtQoACfAwCCyABIARqKAAArQwBCyABIARqKQAACyEHIAAgBTYCICAAIAI2AhwgACAHNwMAQQAhAyAAQQA2AhQgACAHIAggBhsiBzcDCCAAIAdCgIAIIAdCgIAIVBs+AhALIAMLWwEBf0G4fyEDIAIQFiICIAFNBH8gACACakF/ai0AACIAQQNxQQJ0QaAeaigCACACaiAAQQZ2IgFBAnRBsB5qKAIAaiAAQSBxIgBFaiABRSAAQQV2cWoFQbh/CwsdACAAKAKQ4gEQWiAAQQA2AqDiASAAQgA3A5DiAQu1AwEFfyMAQZACayIKJABBuH8hBgJAIAVFDQAgBCwAACIIQf8BcSEHAkAgCEF/TARAIAdBgn9qQQF2IgggBU8NAkFsIQYgB0GBf2oiBUGAAk8NAiAEQQFqIQdBACEGA0AgBiAFTwRAIAUhBiAIIQcMAwUgACAGaiAHIAZBAXZqIgQtAABBBHY6AAAgACAGQQFyaiAELQAAQQ9xOgAAIAZBAmohBgwBCwAACwALIAcgBU8NASAAIARBAWogByAKEFMiBhADDQELIAYhBEEAIQYgAUEAQTQQECEJQQAhBQNAIAQgBkcEQCAAIAZqIggtAAAiAUELSwRAQWwhBgwDBSAJIAFBAnRqIgEgASgCAEEBajYCACAGQQFqIQZBASAILQAAdEEBdSAFaiEFDAILAAsLQWwhBiAFRQ0AIAUQFEEBaiIBQQxLDQAgAyABNgIAQQFBASABdCAFayIDEBQiAXQgA0cNACAAIARqIAFBAWoiADoAACAJIABBAnRqIgAgACgCAEEBajYCACAJKAIEIgBBAkkgAEEBcXINACACIARBAWo2AgAgB0EBaiEGCyAKQZACaiQAIAYLxhEBDH8jAEHwAGsiBSQAQWwhCwJAIANBCkkNACACLwAAIQogAi8AAiEJIAIvAAQhByAFQQhqIAQQDgJAIAMgByAJIApqakEGaiIMSQ0AIAUtAAohCCAFQdgAaiACQQZqIgIgChAGIgsQAw0BIAVBQGsgAiAKaiICIAkQBiILEAMNASAFQShqIAIgCWoiAiAHEAYiCxADDQEgBUEQaiACIAdqIAMgDGsQBiILEAMNASAAIAFqIg9BfWohECAEQQRqIQZBASELIAAgAUEDakECdiIDaiIMIANqIgIgA2oiDiEDIAIhBCAMIQcDQCALIAMgEElxBEAgACAGIAVB2ABqIAgQAkECdGoiCS8BADsAACAFQdgAaiAJLQACEAEgCS0AAyELIAcgBiAFQUBrIAgQAkECdGoiCS8BADsAACAFQUBrIAktAAIQASAJLQADIQogBCAGIAVBKGogCBACQQJ0aiIJLwEAOwAAIAVBKGogCS0AAhABIAktAAMhCSADIAYgBUEQaiAIEAJBAnRqIg0vAQA7AAAgBUEQaiANLQACEAEgDS0AAyENIAAgC2oiCyAGIAVB2ABqIAgQAkECdGoiAC8BADsAACAFQdgAaiAALQACEAEgAC0AAyEAIAcgCmoiCiAGIAVBQGsgCBACQQJ0aiIHLwEAOwAAIAVBQGsgBy0AAhABIActAAMhByAEIAlqIgkgBiAFQShqIAgQAkECdGoiBC8BADsAACAFQShqIAQtAAIQASAELQADIQQgAyANaiIDIAYgBUEQaiAIEAJBAnRqIg0vAQA7AAAgBUEQaiANLQACEAEgACALaiEAIAcgCmohByAEIAlqIQQgAyANLQADaiEDIAVB2ABqEA0gBUFAaxANciAFQShqEA1yIAVBEGoQDXJFIQsMAQsLIAQgDksgByACS3INAEFsIQsgACAMSw0BIAxBfWohCQNAQQAgACAJSSAFQdgAahAEGwRAIAAgBiAFQdgAaiAIEAJBAnRqIgovAQA7AAAgBUHYAGogCi0AAhABIAAgCi0AA2oiACAGIAVB2ABqIAgQAkECdGoiCi8BADsAACAFQdgAaiAKLQACEAEgACAKLQADaiEADAEFIAxBfmohCgNAIAVB2ABqEAQgACAKS3JFBEAgACAGIAVB2ABqIAgQAkECdGoiCS8BADsAACAFQdgAaiAJLQACEAEgACAJLQADaiEADAELCwNAIAAgCk0EQCAAIAYgBUHYAGogCBACQQJ0aiIJLwEAOwAAIAVB2ABqIAktAAIQASAAIAktAANqIQAMAQsLAkAgACAMTw0AIAAgBiAFQdgAaiAIEAIiAEECdGoiDC0AADoAACAMLQADQQFGBEAgBUHYAGogDC0AAhABDAELIAUoAlxBH0sNACAFQdgAaiAGIABBAnRqLQACEAEgBSgCXEEhSQ0AIAVBIDYCXAsgAkF9aiEMA0BBACAHIAxJIAVBQGsQBBsEQCAHIAYgBUFAayAIEAJBAnRqIgAvAQA7AAAgBUFAayAALQACEAEgByAALQADaiIAIAYgBUFAayAIEAJBAnRqIgcvAQA7AAAgBUFAayAHLQACEAEgACAHLQADaiEHDAEFIAJBfmohDANAIAVBQGsQBCAHIAxLckUEQCAHIAYgBUFAayAIEAJBAnRqIgAvAQA7AAAgBUFAayAALQACEAEgByAALQADaiEHDAELCwNAIAcgDE0EQCAHIAYgBUFAayAIEAJBAnRqIgAvAQA7AAAgBUFAayAALQACEAEgByAALQADaiEHDAELCwJAIAcgAk8NACAHIAYgBUFAayAIEAIiAEECdGoiAi0AADoAACACLQADQQFGBEAgBUFAayACLQACEAEMAQsgBSgCREEfSw0AIAVBQGsgBiAAQQJ0ai0AAhABIAUoAkRBIUkNACAFQSA2AkQLIA5BfWohAgNAQQAgBCACSSAFQShqEAQbBEAgBCAGIAVBKGogCBACQQJ0aiIALwEAOwAAIAVBKGogAC0AAhABIAQgAC0AA2oiACAGIAVBKGogCBACQQJ0aiIELwEAOwAAIAVBKGogBC0AAhABIAAgBC0AA2ohBAwBBSAOQX5qIQIDQCAFQShqEAQgBCACS3JFBEAgBCAGIAVBKGogCBACQQJ0aiIALwEAOwAAIAVBKGogAC0AAhABIAQgAC0AA2ohBAwBCwsDQCAEIAJNBEAgBCAGIAVBKGogCBACQQJ0aiIALwEAOwAAIAVBKGogAC0AAhABIAQgAC0AA2ohBAwBCwsCQCAEIA5PDQAgBCAGIAVBKGogCBACIgBBAnRqIgItAAA6AAAgAi0AA0EBRgRAIAVBKGogAi0AAhABDAELIAUoAixBH0sNACAFQShqIAYgAEECdGotAAIQASAFKAIsQSFJDQAgBUEgNgIsCwNAQQAgAyAQSSAFQRBqEAQbBEAgAyAGIAVBEGogCBACQQJ0aiIALwEAOwAAIAVBEGogAC0AAhABIAMgAC0AA2oiACAGIAVBEGogCBACQQJ0aiICLwEAOwAAIAVBEGogAi0AAhABIAAgAi0AA2ohAwwBBSAPQX5qIQIDQCAFQRBqEAQgAyACS3JFBEAgAyAGIAVBEGogCBACQQJ0aiIALwEAOwAAIAVBEGogAC0AAhABIAMgAC0AA2ohAwwBCwsDQCADIAJNBEAgAyAGIAVBEGogCBACQQJ0aiIALwEAOwAAIAVBEGogAC0AAhABIAMgAC0AA2ohAwwBCwsCQCADIA9PDQAgAyAGIAVBEGogCBACIgBBAnRqIgItAAA6AAAgAi0AA0EBRgRAIAVBEGogAi0AAhABDAELIAUoAhRBH0sNACAFQRBqIAYgAEECdGotAAIQASAFKAIUQSFJDQAgBUEgNgIUCyABQWwgBUHYAGoQCiAFQUBrEApxIAVBKGoQCnEgBUEQahAKcRshCwwJCwAACwALAAALAAsAAAsACwAACwALQWwhCwsgBUHwAGokACALC7UEAQ5/IwBBEGsiBiQAIAZBBGogABAOQVQhBQJAIARB3AtJDQAgBi0ABCEHIANB8ARqQQBB7AAQECEIIAdBDEsNACADQdwJaiIJIAggBkEIaiAGQQxqIAEgAhAxIhAQA0UEQCAGKAIMIgQgB0sNASADQdwFaiEPIANBpAVqIREgAEEEaiESIANBqAVqIQEgBCEFA0AgBSICQX9qIQUgCCACQQJ0aigCAEUNAAsgAkEBaiEOQQEhBQNAIAUgDk9FBEAgCCAFQQJ0IgtqKAIAIQwgASALaiAKNgIAIAVBAWohBSAKIAxqIQoMAQsLIAEgCjYCAEEAIQUgBigCCCELA0AgBSALRkUEQCABIAUgCWotAAAiDEECdGoiDSANKAIAIg1BAWo2AgAgDyANQQF0aiINIAw6AAEgDSAFOgAAIAVBAWohBQwBCwtBACEBIANBADYCqAUgBEF/cyAHaiEJQQEhBQNAIAUgDk9FBEAgCCAFQQJ0IgtqKAIAIQwgAyALaiABNgIAIAwgBSAJanQgAWohASAFQQFqIQUMAQsLIAcgBEEBaiIBIAJrIgRrQQFqIQgDQEEBIQUgBCAIT0UEQANAIAUgDk9FBEAgBUECdCIJIAMgBEE0bGpqIAMgCWooAgAgBHY2AgAgBUEBaiEFDAELCyAEQQFqIQQMAQsLIBIgByAPIAogESADIAIgARBkIAZBAToABSAGIAc6AAYgACAGKAIENgIACyAQIQULIAZBEGokACAFC8ENAQt/IwBB8ABrIgUkAEFsIQkCQCADQQpJDQAgAi8AACEKIAIvAAIhDCACLwAEIQYgBUEIaiAEEA4CQCADIAYgCiAMampBBmoiDUkNACAFLQAKIQcgBUHYAGogAkEGaiICIAoQBiIJEAMNASAFQUBrIAIgCmoiAiAMEAYiCRADDQEgBUEoaiACIAxqIgIgBhAGIgkQAw0BIAVBEGogAiAGaiADIA1rEAYiCRADDQEgACABaiIOQX1qIQ8gBEEEaiEGQQEhCSAAIAFBA2pBAnYiAmoiCiACaiIMIAJqIg0hAyAMIQQgCiECA0AgCSADIA9JcQRAIAYgBUHYAGogBxACQQF0aiIILQAAIQsgBUHYAGogCC0AARABIAAgCzoAACAGIAVBQGsgBxACQQF0aiIILQAAIQsgBUFAayAILQABEAEgAiALOgAAIAYgBUEoaiAHEAJBAXRqIggtAAAhCyAFQShqIAgtAAEQASAEIAs6AAAgBiAFQRBqIAcQAkEBdGoiCC0AACELIAVBEGogCC0AARABIAMgCzoAACAGIAVB2ABqIAcQAkEBdGoiCC0AACELIAVB2ABqIAgtAAEQASAAIAs6AAEgBiAFQUBrIAcQAkEBdGoiCC0AACELIAVBQGsgCC0AARABIAIgCzoAASAGIAVBKGogBxACQQF0aiIILQAAIQsgBUEoaiAILQABEAEgBCALOgABIAYgBUEQaiAHEAJBAXRqIggtAAAhCyAFQRBqIAgtAAEQASADIAs6AAEgA0ECaiEDIARBAmohBCACQQJqIQIgAEECaiEAIAkgBUHYAGoQDUVxIAVBQGsQDUVxIAVBKGoQDUVxIAVBEGoQDUVxIQkMAQsLIAQgDUsgAiAMS3INAEFsIQkgACAKSw0BIApBfWohCQNAIAVB2ABqEAQgACAJT3JFBEAgBiAFQdgAaiAHEAJBAXRqIggtAAAhCyAFQdgAaiAILQABEAEgACALOgAAIAYgBUHYAGogBxACQQF0aiIILQAAIQsgBUHYAGogCC0AARABIAAgCzoAASAAQQJqIQAMAQsLA0AgBUHYAGoQBCAAIApPckUEQCAGIAVB2ABqIAcQAkEBdGoiCS0AACEIIAVB2ABqIAktAAEQASAAIAg6AAAgAEEBaiEADAELCwNAIAAgCkkEQCAGIAVB2ABqIAcQAkEBdGoiCS0AACEIIAVB2ABqIAktAAEQASAAIAg6AAAgAEEBaiEADAELCyAMQX1qIQADQCAFQUBrEAQgAiAAT3JFBEAgBiAFQUBrIAcQAkEBdGoiCi0AACEJIAVBQGsgCi0AARABIAIgCToAACAGIAVBQGsgBxACQQF0aiIKLQAAIQkgBUFAayAKLQABEAEgAiAJOgABIAJBAmohAgwBCwsDQCAFQUBrEAQgAiAMT3JFBEAgBiAFQUBrIAcQAkEBdGoiAC0AACEKIAVBQGsgAC0AARABIAIgCjoAACACQQFqIQIMAQsLA0AgAiAMSQRAIAYgBUFAayAHEAJBAXRqIgAtAAAhCiAFQUBrIAAtAAEQASACIAo6AAAgAkEBaiECDAELCyANQX1qIQADQCAFQShqEAQgBCAAT3JFBEAgBiAFQShqIAcQAkEBdGoiAi0AACEKIAVBKGogAi0AARABIAQgCjoAACAGIAVBKGogBxACQQF0aiICLQAAIQogBUEoaiACLQABEAEgBCAKOgABIARBAmohBAwBCwsDQCAFQShqEAQgBCANT3JFBEAgBiAFQShqIAcQAkEBdGoiAC0AACECIAVBKGogAC0AARABIAQgAjoAACAEQQFqIQQMAQsLA0AgBCANSQRAIAYgBUEoaiAHEAJBAXRqIgAtAAAhAiAFQShqIAAtAAEQASAEIAI6AAAgBEEBaiEEDAELCwNAIAVBEGoQBCADIA9PckUEQCAGIAVBEGogBxACQQF0aiIALQAAIQIgBUEQaiAALQABEAEgAyACOgAAIAYgBUEQaiAHEAJBAXRqIgAtAAAhAiAFQRBqIAAtAAEQASADIAI6AAEgA0ECaiEDDAELCwNAIAVBEGoQBCADIA5PckUEQCAGIAVBEGogBxACQQF0aiIALQAAIQIgBUEQaiAALQABEAEgAyACOgAAIANBAWohAwwBCwsDQCADIA5JBEAgBiAFQRBqIAcQAkEBdGoiAC0AACECIAVBEGogAC0AARABIAMgAjoAACADQQFqIQMMAQsLIAFBbCAFQdgAahAKIAVBQGsQCnEgBUEoahAKcSAFQRBqEApxGyEJDAELQWwhCQsgBUHwAGokACAJC8oCAQR/IwBBIGsiBSQAIAUgBBAOIAUtAAIhByAFQQhqIAIgAxAGIgIQA0UEQCAEQQRqIQIgACABaiIDQX1qIQQDQCAFQQhqEAQgACAET3JFBEAgAiAFQQhqIAcQAkEBdGoiBi0AACEIIAVBCGogBi0AARABIAAgCDoAACACIAVBCGogBxACQQF0aiIGLQAAIQggBUEIaiAGLQABEAEgACAIOgABIABBAmohAAwBCwsDQCAFQQhqEAQgACADT3JFBEAgAiAFQQhqIAcQAkEBdGoiBC0AACEGIAVBCGogBC0AARABIAAgBjoAACAAQQFqIQAMAQsLA0AgACADT0UEQCACIAVBCGogBxACQQF0aiIELQAAIQYgBUEIaiAELQABEAEgACAGOgAAIABBAWohAAwBCwsgAUFsIAVBCGoQChshAgsgBUEgaiQAIAILtgMBCX8jAEEQayIGJAAgBkEANgIMIAZBADYCCEFUIQQCQAJAIANBQGsiDCADIAZBCGogBkEMaiABIAIQMSICEAMNACAGQQRqIAAQDiAGKAIMIgcgBi0ABEEBaksNASAAQQRqIQogBkEAOgAFIAYgBzoABiAAIAYoAgQ2AgAgB0EBaiEJQQEhBANAIAQgCUkEQCADIARBAnRqIgEoAgAhACABIAU2AgAgACAEQX9qdCAFaiEFIARBAWohBAwBCwsgB0EBaiEHQQAhBSAGKAIIIQkDQCAFIAlGDQEgAyAFIAxqLQAAIgRBAnRqIgBBASAEdEEBdSILIAAoAgAiAWoiADYCACAHIARrIQhBACEEAkAgC0EDTQRAA0AgBCALRg0CIAogASAEakEBdGoiACAIOgABIAAgBToAACAEQQFqIQQMAAALAAsDQCABIABPDQEgCiABQQF0aiIEIAg6AAEgBCAFOgAAIAQgCDoAAyAEIAU6AAIgBCAIOgAFIAQgBToABCAEIAg6AAcgBCAFOgAGIAFBBGohAQwAAAsACyAFQQFqIQUMAAALAAsgAiEECyAGQRBqJAAgBAutAQECfwJAQYQgKAIAIABHIAAoAgBBAXYiAyABa0F4aiICQXhxQQhHcgR/IAIFIAMQJ0UNASACQQhqC0EQSQ0AIAAgACgCACICQQFxIAAgAWpBD2pBeHEiASAAa0EBdHI2AgAgASAANgIEIAEgASgCAEEBcSAAIAJBAXZqIAFrIgJBAXRyNgIAQYQgIAEgAkH/////B3FqQQRqQYQgKAIAIABGGyABNgIAIAEQJQsLygIBBX8CQAJAAkAgAEEIIABBCEsbZ0EfcyAAaUEBR2oiAUEESSAAIAF2cg0AIAFBAnRB/B5qKAIAIgJFDQADQCACQXhqIgMoAgBBAXZBeGoiBSAATwRAIAIgBUEIIAVBCEsbZ0Efc0ECdEGAH2oiASgCAEYEQCABIAIoAgQ2AgALDAMLIARBHksNASAEQQFqIQQgAigCBCICDQALC0EAIQMgAUEgTw0BA0AgAUECdEGAH2ooAgAiAkUEQCABQR5LIQIgAUEBaiEBIAJFDQEMAwsLIAIgAkF4aiIDKAIAQQF2QXhqIgFBCCABQQhLG2dBH3NBAnRBgB9qIgEoAgBGBEAgASACKAIENgIACwsgAigCACIBBEAgASACKAIENgIECyACKAIEIgEEQCABIAIoAgA2AgALIAMgAygCAEEBcjYCACADIAAQNwsgAwvhCwINfwV+IwBB8ABrIgckACAHIAAoAvDhASIINgJcIAEgAmohDSAIIAAoAoDiAWohDwJAAkAgBUUEQCABIQQMAQsgACgCxOABIRAgACgCwOABIREgACgCvOABIQ4gAEEBNgKM4QFBACEIA0AgCEEDRwRAIAcgCEECdCICaiAAIAJqQazQAWooAgA2AkQgCEEBaiEIDAELC0FsIQwgB0EYaiADIAQQBhADDQEgB0EsaiAHQRhqIAAoAgAQEyAHQTRqIAdBGGogACgCCBATIAdBPGogB0EYaiAAKAIEEBMgDUFgaiESIAEhBEEAIQwDQCAHKAIwIAcoAixBA3RqKQIAIhRCEIinQf8BcSEIIAcoAkAgBygCPEEDdGopAgAiFUIQiKdB/wFxIQsgBygCOCAHKAI0QQN0aikCACIWQiCIpyEJIBVCIIghFyAUQiCIpyECAkAgFkIQiKdB/wFxIgNBAk8EQAJAIAZFIANBGUlyRQRAIAkgB0EYaiADQSAgBygCHGsiCiAKIANLGyIKEAUgAyAKayIDdGohCSAHQRhqEAQaIANFDQEgB0EYaiADEAUgCWohCQwBCyAHQRhqIAMQBSAJaiEJIAdBGGoQBBoLIAcpAkQhGCAHIAk2AkQgByAYNwNIDAELAkAgA0UEQCACBEAgBygCRCEJDAMLIAcoAkghCQwBCwJAAkAgB0EYakEBEAUgCSACRWpqIgNBA0YEQCAHKAJEQX9qIgMgA0VqIQkMAQsgA0ECdCAHaigCRCIJIAlFaiEJIANBAUYNAQsgByAHKAJINgJMCwsgByAHKAJENgJIIAcgCTYCRAsgF6chAyALBEAgB0EYaiALEAUgA2ohAwsgCCALakEUTwRAIAdBGGoQBBoLIAgEQCAHQRhqIAgQBSACaiECCyAHQRhqEAQaIAcgB0EYaiAUQhiIp0H/AXEQCCAUp0H//wNxajYCLCAHIAdBGGogFUIYiKdB/wFxEAggFadB//8DcWo2AjwgB0EYahAEGiAHIAdBGGogFkIYiKdB/wFxEAggFqdB//8DcWo2AjQgByACNgJgIAcoAlwhCiAHIAk2AmggByADNgJkAkACQAJAIAQgAiADaiILaiASSw0AIAIgCmoiEyAPSw0AIA0gBGsgC0Egak8NAQsgByAHKQNoNwMQIAcgBykDYDcDCCAEIA0gB0EIaiAHQdwAaiAPIA4gESAQEB4hCwwBCyACIARqIQggBCAKEAcgAkERTwRAIARBEGohAgNAIAIgCkEQaiIKEAcgAkEQaiICIAhJDQALCyAIIAlrIQIgByATNgJcIAkgCCAOa0sEQCAJIAggEWtLBEBBbCELDAILIBAgAiAOayICaiIKIANqIBBNBEAgCCAKIAMQDxoMAgsgCCAKQQAgAmsQDyEIIAcgAiADaiIDNgJkIAggAmshCCAOIQILIAlBEE8EQCADIAhqIQMDQCAIIAIQByACQRBqIQIgCEEQaiIIIANJDQALDAELAkAgCUEHTQRAIAggAi0AADoAACAIIAItAAE6AAEgCCACLQACOgACIAggAi0AAzoAAyAIQQRqIAIgCUECdCIDQcAeaigCAGoiAhAXIAIgA0HgHmooAgBrIQIgBygCZCEDDAELIAggAhAMCyADQQlJDQAgAyAIaiEDIAhBCGoiCCACQQhqIgJrQQ9MBEADQCAIIAIQDCACQQhqIQIgCEEIaiIIIANJDQAMAgALAAsDQCAIIAIQByACQRBqIQIgCEEQaiIIIANJDQALCyAHQRhqEAQaIAsgDCALEAMiAhshDCAEIAQgC2ogAhshBCAFQX9qIgUNAAsgDBADDQFBbCEMIAdBGGoQBEECSQ0BQQAhCANAIAhBA0cEQCAAIAhBAnQiAmpBrNABaiACIAdqKAJENgIAIAhBAWohCAwBCwsgBygCXCEIC0G6fyEMIA8gCGsiACANIARrSw0AIAQEfyAEIAggABALIABqBUEACyABayEMCyAHQfAAaiQAIAwLkRcCFn8FfiMAQdABayIHJAAgByAAKALw4QEiCDYCvAEgASACaiESIAggACgCgOIBaiETAkACQCAFRQRAIAEhAwwBCyAAKALE4AEhESAAKALA4AEhFSAAKAK84AEhDyAAQQE2AozhAUEAIQgDQCAIQQNHBEAgByAIQQJ0IgJqIAAgAmpBrNABaigCADYCVCAIQQFqIQgMAQsLIAcgETYCZCAHIA82AmAgByABIA9rNgJoQWwhECAHQShqIAMgBBAGEAMNASAFQQQgBUEESBshFyAHQTxqIAdBKGogACgCABATIAdBxABqIAdBKGogACgCCBATIAdBzABqIAdBKGogACgCBBATQQAhBCAHQeAAaiEMIAdB5ABqIQoDQCAHQShqEARBAksgBCAXTnJFBEAgBygCQCAHKAI8QQN0aikCACIdQhCIp0H/AXEhCyAHKAJQIAcoAkxBA3RqKQIAIh5CEIinQf8BcSEJIAcoAkggBygCREEDdGopAgAiH0IgiKchCCAeQiCIISAgHUIgiKchAgJAIB9CEIinQf8BcSIDQQJPBEACQCAGRSADQRlJckUEQCAIIAdBKGogA0EgIAcoAixrIg0gDSADSxsiDRAFIAMgDWsiA3RqIQggB0EoahAEGiADRQ0BIAdBKGogAxAFIAhqIQgMAQsgB0EoaiADEAUgCGohCCAHQShqEAQaCyAHKQJUISEgByAINgJUIAcgITcDWAwBCwJAIANFBEAgAgRAIAcoAlQhCAwDCyAHKAJYIQgMAQsCQAJAIAdBKGpBARAFIAggAkVqaiIDQQNGBEAgBygCVEF/aiIDIANFaiEIDAELIANBAnQgB2ooAlQiCCAIRWohCCADQQFGDQELIAcgBygCWDYCXAsLIAcgBygCVDYCWCAHIAg2AlQLICCnIQMgCQRAIAdBKGogCRAFIANqIQMLIAkgC2pBFE8EQCAHQShqEAQaCyALBEAgB0EoaiALEAUgAmohAgsgB0EoahAEGiAHIAcoAmggAmoiCSADajYCaCAKIAwgCCAJSxsoAgAhDSAHIAdBKGogHUIYiKdB/wFxEAggHadB//8DcWo2AjwgByAHQShqIB5CGIinQf8BcRAIIB6nQf//A3FqNgJMIAdBKGoQBBogB0EoaiAfQhiIp0H/AXEQCCEOIAdB8ABqIARBBHRqIgsgCSANaiAIazYCDCALIAg2AgggCyADNgIEIAsgAjYCACAHIA4gH6dB//8DcWo2AkQgBEEBaiEEDAELCyAEIBdIDQEgEkFgaiEYIAdB4ABqIRogB0HkAGohGyABIQMDQCAHQShqEARBAksgBCAFTnJFBEAgBygCQCAHKAI8QQN0aikCACIdQhCIp0H/AXEhCyAHKAJQIAcoAkxBA3RqKQIAIh5CEIinQf8BcSEIIAcoAkggBygCREEDdGopAgAiH0IgiKchCSAeQiCIISAgHUIgiKchDAJAIB9CEIinQf8BcSICQQJPBEACQCAGRSACQRlJckUEQCAJIAdBKGogAkEgIAcoAixrIgogCiACSxsiChAFIAIgCmsiAnRqIQkgB0EoahAEGiACRQ0BIAdBKGogAhAFIAlqIQkMAQsgB0EoaiACEAUgCWohCSAHQShqEAQaCyAHKQJUISEgByAJNgJUIAcgITcDWAwBCwJAIAJFBEAgDARAIAcoAlQhCQwDCyAHKAJYIQkMAQsCQAJAIAdBKGpBARAFIAkgDEVqaiICQQNGBEAgBygCVEF/aiICIAJFaiEJDAELIAJBAnQgB2ooAlQiCSAJRWohCSACQQFGDQELIAcgBygCWDYCXAsLIAcgBygCVDYCWCAHIAk2AlQLICCnIRQgCARAIAdBKGogCBAFIBRqIRQLIAggC2pBFE8EQCAHQShqEAQaCyALBEAgB0EoaiALEAUgDGohDAsgB0EoahAEGiAHIAcoAmggDGoiGSAUajYCaCAbIBogCSAZSxsoAgAhHCAHIAdBKGogHUIYiKdB/wFxEAggHadB//8DcWo2AjwgByAHQShqIB5CGIinQf8BcRAIIB6nQf//A3FqNgJMIAdBKGoQBBogByAHQShqIB9CGIinQf8BcRAIIB+nQf//A3FqNgJEIAcgB0HwAGogBEEDcUEEdGoiDSkDCCIdNwPIASAHIA0pAwAiHjcDwAECQAJAAkAgBygCvAEiDiAepyICaiIWIBNLDQAgAyAHKALEASIKIAJqIgtqIBhLDQAgEiADayALQSBqTw0BCyAHIAcpA8gBNwMQIAcgBykDwAE3AwggAyASIAdBCGogB0G8AWogEyAPIBUgERAeIQsMAQsgAiADaiEIIAMgDhAHIAJBEU8EQCADQRBqIQIDQCACIA5BEGoiDhAHIAJBEGoiAiAISQ0ACwsgCCAdpyIOayECIAcgFjYCvAEgDiAIIA9rSwRAIA4gCCAVa0sEQEFsIQsMAgsgESACIA9rIgJqIhYgCmogEU0EQCAIIBYgChAPGgwCCyAIIBZBACACaxAPIQggByACIApqIgo2AsQBIAggAmshCCAPIQILIA5BEE8EQCAIIApqIQoDQCAIIAIQByACQRBqIQIgCEEQaiIIIApJDQALDAELAkAgDkEHTQRAIAggAi0AADoAACAIIAItAAE6AAEgCCACLQACOgACIAggAi0AAzoAAyAIQQRqIAIgDkECdCIKQcAeaigCAGoiAhAXIAIgCkHgHmooAgBrIQIgBygCxAEhCgwBCyAIIAIQDAsgCkEJSQ0AIAggCmohCiAIQQhqIgggAkEIaiICa0EPTARAA0AgCCACEAwgAkEIaiECIAhBCGoiCCAKSQ0ADAIACwALA0AgCCACEAcgAkEQaiECIAhBEGoiCCAKSQ0ACwsgCxADBEAgCyEQDAQFIA0gDDYCACANIBkgHGogCWs2AgwgDSAJNgIIIA0gFDYCBCAEQQFqIQQgAyALaiEDDAILAAsLIAQgBUgNASAEIBdrIQtBACEEA0AgCyAFSARAIAcgB0HwAGogC0EDcUEEdGoiAikDCCIdNwPIASAHIAIpAwAiHjcDwAECQAJAAkAgBygCvAEiDCAepyICaiIKIBNLDQAgAyAHKALEASIJIAJqIhBqIBhLDQAgEiADayAQQSBqTw0BCyAHIAcpA8gBNwMgIAcgBykDwAE3AxggAyASIAdBGGogB0G8AWogEyAPIBUgERAeIRAMAQsgAiADaiEIIAMgDBAHIAJBEU8EQCADQRBqIQIDQCACIAxBEGoiDBAHIAJBEGoiAiAISQ0ACwsgCCAdpyIGayECIAcgCjYCvAEgBiAIIA9rSwRAIAYgCCAVa0sEQEFsIRAMAgsgESACIA9rIgJqIgwgCWogEU0EQCAIIAwgCRAPGgwCCyAIIAxBACACaxAPIQggByACIAlqIgk2AsQBIAggAmshCCAPIQILIAZBEE8EQCAIIAlqIQYDQCAIIAIQByACQRBqIQIgCEEQaiIIIAZJDQALDAELAkAgBkEHTQRAIAggAi0AADoAACAIIAItAAE6AAEgCCACLQACOgACIAggAi0AAzoAAyAIQQRqIAIgBkECdCIGQcAeaigCAGoiAhAXIAIgBkHgHmooAgBrIQIgBygCxAEhCQwBCyAIIAIQDAsgCUEJSQ0AIAggCWohBiAIQQhqIgggAkEIaiICa0EPTARAA0AgCCACEAwgAkEIaiECIAhBCGoiCCAGSQ0ADAIACwALA0AgCCACEAcgAkEQaiECIAhBEGoiCCAGSQ0ACwsgEBADDQMgC0EBaiELIAMgEGohAwwBCwsDQCAEQQNHBEAgACAEQQJ0IgJqQazQAWogAiAHaigCVDYCACAEQQFqIQQMAQsLIAcoArwBIQgLQbp/IRAgEyAIayIAIBIgA2tLDQAgAwR/IAMgCCAAEAsgAGoFQQALIAFrIRALIAdB0AFqJAAgEAslACAAQgA3AgAgAEEAOwEIIABBADoACyAAIAE2AgwgACACOgAKC7QFAQN/IwBBMGsiBCQAIABB/wFqIgVBfWohBgJAIAMvAQIEQCAEQRhqIAEgAhAGIgIQAw0BIARBEGogBEEYaiADEBwgBEEIaiAEQRhqIAMQHCAAIQMDQAJAIARBGGoQBCADIAZPckUEQCADIARBEGogBEEYahASOgAAIAMgBEEIaiAEQRhqEBI6AAEgBEEYahAERQ0BIANBAmohAwsgBUF+aiEFAn8DQEG6fyECIAMiASAFSw0FIAEgBEEQaiAEQRhqEBI6AAAgAUEBaiEDIARBGGoQBEEDRgRAQQIhAiAEQQhqDAILIAMgBUsNBSABIARBCGogBEEYahASOgABIAFBAmohA0EDIQIgBEEYahAEQQNHDQALIARBEGoLIQUgAyAFIARBGGoQEjoAACABIAJqIABrIQIMAwsgAyAEQRBqIARBGGoQEjoAAiADIARBCGogBEEYahASOgADIANBBGohAwwAAAsACyAEQRhqIAEgAhAGIgIQAw0AIARBEGogBEEYaiADEBwgBEEIaiAEQRhqIAMQHCAAIQMDQAJAIARBGGoQBCADIAZPckUEQCADIARBEGogBEEYahAROgAAIAMgBEEIaiAEQRhqEBE6AAEgBEEYahAERQ0BIANBAmohAwsgBUF+aiEFAn8DQEG6fyECIAMiASAFSw0EIAEgBEEQaiAEQRhqEBE6AAAgAUEBaiEDIARBGGoQBEEDRgRAQQIhAiAEQQhqDAILIAMgBUsNBCABIARBCGogBEEYahAROgABIAFBAmohA0EDIQIgBEEYahAEQQNHDQALIARBEGoLIQUgAyAFIARBGGoQEToAACABIAJqIABrIQIMAgsgAyAEQRBqIARBGGoQEToAAiADIARBCGogBEEYahAROgADIANBBGohAwwAAAsACyAEQTBqJAAgAgtpAQF/An8CQAJAIAJBB00NACABKAAAQbfIwuF+Rw0AIAAgASgABDYCmOIBQWIgAEEQaiABIAIQPiIDEAMNAhogAEKBgICAEDcDiOEBIAAgASADaiACIANrECoMAQsgACABIAIQKgtBAAsLrQMBBn8jAEGAAWsiAyQAQWIhCAJAIAJBCUkNACAAQZjQAGogAUEIaiIEIAJBeGogAEGY0AAQMyIFEAMiBg0AIANBHzYCfCADIANB/ABqIANB+ABqIAQgBCAFaiAGGyIEIAEgAmoiAiAEaxAVIgUQAw0AIAMoAnwiBkEfSw0AIAMoAngiB0EJTw0AIABBiCBqIAMgBkGAC0GADCAHEBggA0E0NgJ8IAMgA0H8AGogA0H4AGogBCAFaiIEIAIgBGsQFSIFEAMNACADKAJ8IgZBNEsNACADKAJ4IgdBCk8NACAAQZAwaiADIAZBgA1B4A4gBxAYIANBIzYCfCADIANB/ABqIANB+ABqIAQgBWoiBCACIARrEBUiBRADDQAgAygCfCIGQSNLDQAgAygCeCIHQQpPDQAgACADIAZBwBBB0BEgBxAYIAQgBWoiBEEMaiIFIAJLDQAgAiAFayEFQQAhAgNAIAJBA0cEQCAEKAAAIgZBf2ogBU8NAiAAIAJBAnRqQZzQAWogBjYCACACQQFqIQIgBEEEaiEEDAELCyAEIAFrIQgLIANBgAFqJAAgCAtGAQN/IABBCGohAyAAKAIEIQJBACEAA0AgACACdkUEQCABIAMgAEEDdGotAAJBFktqIQEgAEEBaiEADAELCyABQQggAmt0C4YDAQV/Qbh/IQcCQCADRQ0AIAItAAAiBEUEQCABQQA2AgBBAUG4fyADQQFGGw8LAn8gAkEBaiIFIARBGHRBGHUiBkF/Sg0AGiAGQX9GBEAgA0EDSA0CIAUvAABBgP4BaiEEIAJBA2oMAQsgA0ECSA0BIAItAAEgBEEIdHJBgIB+aiEEIAJBAmoLIQUgASAENgIAIAVBAWoiASACIANqIgNLDQBBbCEHIABBEGogACAFLQAAIgVBBnZBI0EJIAEgAyABa0HAEEHQEUHwEiAAKAKM4QEgACgCnOIBIAQQHyIGEAMiCA0AIABBmCBqIABBCGogBUEEdkEDcUEfQQggASABIAZqIAgbIgEgAyABa0GAC0GADEGAFyAAKAKM4QEgACgCnOIBIAQQHyIGEAMiCA0AIABBoDBqIABBBGogBUECdkEDcUE0QQkgASABIAZqIAgbIgEgAyABa0GADUHgDkGQGSAAKAKM4QEgACgCnOIBIAQQHyIAEAMNACAAIAFqIAJrIQcLIAcLrQMBCn8jAEGABGsiCCQAAn9BUiACQf8BSw0AGkFUIANBDEsNABogAkEBaiELIABBBGohCUGAgAQgA0F/anRBEHUhCkEAIQJBASEEQQEgA3QiB0F/aiIMIQUDQCACIAtGRQRAAkAgASACQQF0Ig1qLwEAIgZB//8DRgRAIAkgBUECdGogAjoAAiAFQX9qIQVBASEGDAELIARBACAKIAZBEHRBEHVKGyEECyAIIA1qIAY7AQAgAkEBaiECDAELCyAAIAQ7AQIgACADOwEAIAdBA3YgB0EBdmpBA2ohBkEAIQRBACECA0AgBCALRkUEQCABIARBAXRqLgEAIQpBACEAA0AgACAKTkUEQCAJIAJBAnRqIAQ6AAIDQCACIAZqIAxxIgIgBUsNAAsgAEEBaiEADAELCyAEQQFqIQQMAQsLQX8gAg0AGkEAIQIDfyACIAdGBH9BAAUgCCAJIAJBAnRqIgAtAAJBAXRqIgEgAS8BACIBQQFqOwEAIAAgAyABEBRrIgU6AAMgACABIAVB/wFxdCAHazsBACACQQFqIQIMAQsLCyEFIAhBgARqJAAgBQvjBgEIf0FsIQcCQCACQQNJDQACQAJAAkACQCABLQAAIgNBA3EiCUEBaw4DAwEAAgsgACgCiOEBDQBBYg8LIAJBBUkNAkEDIQYgASgAACEFAn8CQAJAIANBAnZBA3EiCEF+aiIEQQFNBEAgBEEBaw0BDAILIAVBDnZB/wdxIQQgBUEEdkH/B3EhAyAIRQwCCyAFQRJ2IQRBBCEGIAVBBHZB//8AcSEDQQAMAQsgBUEEdkH//w9xIgNBgIAISw0DIAEtAARBCnQgBUEWdnIhBEEFIQZBAAshBSAEIAZqIgogAksNAgJAIANBgQZJDQAgACgCnOIBRQ0AQQAhAgNAIAJBg4ABSw0BIAJBQGshAgwAAAsACwJ/IAlBA0YEQCABIAZqIQEgAEHw4gFqIQIgACgCDCEGIAUEQCACIAMgASAEIAYQXwwCCyACIAMgASAEIAYQXQwBCyAAQbjQAWohAiABIAZqIQEgAEHw4gFqIQYgAEGo0ABqIQggBQRAIAggBiADIAEgBCACEF4MAQsgCCAGIAMgASAEIAIQXAsQAw0CIAAgAzYCgOIBIABBATYCiOEBIAAgAEHw4gFqNgLw4QEgCUECRgRAIAAgAEGo0ABqNgIMCyAAIANqIgBBiOMBakIANwAAIABBgOMBakIANwAAIABB+OIBakIANwAAIABB8OIBakIANwAAIAoPCwJ/AkACQAJAIANBAnZBA3FBf2oiBEECSw0AIARBAWsOAgACAQtBASEEIANBA3YMAgtBAiEEIAEvAABBBHYMAQtBAyEEIAEQIUEEdgsiAyAEaiIFQSBqIAJLBEAgBSACSw0CIABB8OIBaiABIARqIAMQCyEBIAAgAzYCgOIBIAAgATYC8OEBIAEgA2oiAEIANwAYIABCADcAECAAQgA3AAggAEIANwAAIAUPCyAAIAM2AoDiASAAIAEgBGo2AvDhASAFDwsCfwJAAkACQCADQQJ2QQNxQX9qIgRBAksNACAEQQFrDgIAAgELQQEhByADQQN2DAILQQIhByABLwAAQQR2DAELIAJBBEkgARAhIgJBj4CAAUtyDQFBAyEHIAJBBHYLIQIgAEHw4gFqIAEgB2otAAAgAkEgahAQIQEgACACNgKA4gEgACABNgLw4QEgB0EBaiEHCyAHC0sAIABC+erQ0OfJoeThADcDICAAQgA3AxggAELP1tO+0ser2UI3AxAgAELW64Lu6v2J9eAANwMIIABCADcDACAAQShqQQBBKBAQGgviAgICfwV+IABBKGoiASAAKAJIaiECAn4gACkDACIDQiBaBEAgACkDECIEQgeJIAApAwgiBUIBiXwgACkDGCIGQgyJfCAAKQMgIgdCEol8IAUQGSAEEBkgBhAZIAcQGQwBCyAAKQMYQsXP2bLx5brqJ3wLIAN8IQMDQCABQQhqIgAgAk0EQEIAIAEpAAAQCSADhUIbiUKHla+vmLbem55/fkLj3MqV/M7y9YV/fCEDIAAhAQwBCwsCQCABQQRqIgAgAksEQCABIQAMAQsgASgAAK1Ch5Wvr5i23puef34gA4VCF4lCz9bTvtLHq9lCfkL5893xmfaZqxZ8IQMLA0AgACACSQRAIAAxAABCxc/ZsvHluuonfiADhUILiUKHla+vmLbem55/fiEDIABBAWohAAwBCwsgA0IhiCADhULP1tO+0ser2UJ+IgNCHYggA4VC+fPd8Zn2masWfiIDQiCIIAOFC+8CAgJ/BH4gACAAKQMAIAKtfDcDAAJAAkAgACgCSCIDIAJqIgRBH00EQCABRQ0BIAAgA2pBKGogASACECAgACgCSCACaiEEDAELIAEgAmohAgJ/IAMEQCAAQShqIgQgA2ogAUEgIANrECAgACAAKQMIIAQpAAAQCTcDCCAAIAApAxAgACkAMBAJNwMQIAAgACkDGCAAKQA4EAk3AxggACAAKQMgIABBQGspAAAQCTcDICAAKAJIIQMgAEEANgJIIAEgA2tBIGohAQsgAUEgaiACTQsEQCACQWBqIQMgACkDICEFIAApAxghBiAAKQMQIQcgACkDCCEIA0AgCCABKQAAEAkhCCAHIAEpAAgQCSEHIAYgASkAEBAJIQYgBSABKQAYEAkhBSABQSBqIgEgA00NAAsgACAFNwMgIAAgBjcDGCAAIAc3AxAgACAINwMICyABIAJPDQEgAEEoaiABIAIgAWsiBBAgCyAAIAQ2AkgLCy8BAX8gAEUEQEG2f0EAIAMbDwtBun8hBCADIAFNBH8gACACIAMQEBogAwVBun8LCy8BAX8gAEUEQEG2f0EAIAMbDwtBun8hBCADIAFNBH8gACACIAMQCxogAwVBun8LC6gCAQZ/IwBBEGsiByQAIABB2OABaikDAEKAgIAQViEIQbh/IQUCQCAEQf//B0sNACAAIAMgBBBCIgUQAyIGDQAgACgCnOIBIQkgACAHQQxqIAMgAyAFaiAGGyIKIARBACAFIAYbayIGEEAiAxADBEAgAyEFDAELIAcoAgwhBCABRQRAQbp/IQUgBEEASg0BCyAGIANrIQUgAyAKaiEDAkAgCQRAIABBADYCnOIBDAELAkACQAJAIARBBUgNACAAQdjgAWopAwBCgICACFgNAAwBCyAAQQA2ApziAQwBCyAAKAIIED8hBiAAQQA2ApziASAGQRRPDQELIAAgASACIAMgBSAEIAgQOSEFDAELIAAgASACIAMgBSAEIAgQOiEFCyAHQRBqJAAgBQtnACAAQdDgAWogASACIAAoAuzhARAuIgEQAwRAIAEPC0G4fyECAkAgAQ0AIABB7OABaigCACIBBEBBYCECIAAoApjiASABRw0BC0EAIQIgAEHw4AFqKAIARQ0AIABBkOEBahBDCyACCycBAX8QVyIERQRAQUAPCyAEIAAgASACIAMgBBBLEE8hACAEEFYgAAs/AQF/AkACQAJAIAAoAqDiAUEBaiIBQQJLDQAgAUEBaw4CAAECCyAAEDBBAA8LIABBADYCoOIBCyAAKAKU4gELvAMCB38BfiMAQRBrIgkkAEG4fyEGAkAgBCgCACIIQQVBCSAAKALs4QEiBRtJDQAgAygCACIHQQFBBSAFGyAFEC8iBRADBEAgBSEGDAELIAggBUEDakkNACAAIAcgBRBJIgYQAw0AIAEgAmohCiAAQZDhAWohCyAIIAVrIQIgBSAHaiEHIAEhBQNAIAcgAiAJECwiBhADDQEgAkF9aiICIAZJBEBBuH8hBgwCCyAJKAIAIghBAksEQEFsIQYMAgsgB0EDaiEHAn8CQAJAAkAgCEEBaw4CAgABCyAAIAUgCiAFayAHIAYQSAwCCyAFIAogBWsgByAGEEcMAQsgBSAKIAVrIActAAAgCSgCCBBGCyIIEAMEQCAIIQYMAgsgACgC8OABBEAgCyAFIAgQRQsgAiAGayECIAYgB2ohByAFIAhqIQUgCSgCBEUNAAsgACkD0OABIgxCf1IEQEFsIQYgDCAFIAFrrFINAQsgACgC8OABBEBBaiEGIAJBBEkNASALEEQhDCAHKAAAIAynRw0BIAdBBGohByACQXxqIQILIAMgBzYCACAEIAI2AgAgBSABayEGCyAJQRBqJAAgBgsuACAAECsCf0EAQQAQAw0AGiABRSACRXJFBEBBYiAAIAEgAhA9EAMNARoLQQALCzcAIAEEQCAAIAAoAsTgASABKAIEIAEoAghqRzYCnOIBCyAAECtBABADIAFFckUEQCAAIAEQWwsL0QIBB38jAEEQayIGJAAgBiAENgIIIAYgAzYCDCAFBEAgBSgCBCEKIAUoAgghCQsgASEIAkACQANAIAAoAuzhARAWIQsCQANAIAQgC0kNASADKAAAQXBxQdDUtMIBRgRAIAMgBBAiIgcQAw0EIAQgB2shBCADIAdqIQMMAQsLIAYgAzYCDCAGIAQ2AggCQCAFBEAgACAFEE5BACEHQQAQA0UNAQwFCyAAIAogCRBNIgcQAw0ECyAAIAgQUCAMQQFHQQAgACAIIAIgBkEMaiAGQQhqEEwiByIDa0EAIAMQAxtBCkdyRQRAQbh/IQcMBAsgBxADDQMgAiAHayECIAcgCGohCEEBIQwgBigCDCEDIAYoAgghBAwBCwsgBiADNgIMIAYgBDYCCEG4fyEHIAQNASAIIAFrIQcMAQsgBiADNgIMIAYgBDYCCAsgBkEQaiQAIAcLRgECfyABIAAoArjgASICRwRAIAAgAjYCxOABIAAgATYCuOABIAAoArzgASEDIAAgATYCvOABIAAgASADIAJrajYCwOABCwutAgIEfwF+IwBBQGoiBCQAAkACQCACQQhJDQAgASgAAEFwcUHQ1LTCAUcNACABIAIQIiEBIABCADcDCCAAQQA2AgQgACABNgIADAELIARBGGogASACEC0iAxADBEAgACADEBoMAQsgAwRAIABBuH8QGgwBCyACIAQoAjAiA2shAiABIANqIQMDQAJAIAAgAyACIARBCGoQLCIFEAMEfyAFBSACIAVBA2oiBU8NAUG4fwsQGgwCCyAGQQFqIQYgAiAFayECIAMgBWohAyAEKAIMRQ0ACyAEKAI4BEAgAkEDTQRAIABBuH8QGgwCCyADQQRqIQMLIAQoAighAiAEKQMYIQcgAEEANgIEIAAgAyABazYCACAAIAIgBmytIAcgB0J/URs3AwgLIARBQGskAAslAQF/IwBBEGsiAiQAIAIgACABEFEgAigCACEAIAJBEGokACAAC30BBH8jAEGQBGsiBCQAIARB/wE2AggCQCAEQRBqIARBCGogBEEMaiABIAIQFSIGEAMEQCAGIQUMAQtBVCEFIAQoAgwiB0EGSw0AIAMgBEEQaiAEKAIIIAcQQSIFEAMNACAAIAEgBmogAiAGayADEDwhBQsgBEGQBGokACAFC4cBAgJ/An5BABAWIQMCQANAIAEgA08EQAJAIAAoAABBcHFB0NS0wgFGBEAgACABECIiAhADRQ0BQn4PCyAAIAEQVSIEQn1WDQMgBCAFfCIFIARUIQJCfiEEIAINAyAAIAEQUiICEAMNAwsgASACayEBIAAgAmohAAwBCwtCfiAFIAEbIQQLIAQLPwIBfwF+IwBBMGsiAiQAAn5CfiACQQhqIAAgARAtDQAaQgAgAigCHEEBRg0AGiACKQMICyEDIAJBMGokACADC40BAQJ/IwBBMGsiASQAAkAgAEUNACAAKAKI4gENACABIABB/OEBaigCADYCKCABIAApAvThATcDICAAEDAgACgCqOIBIQIgASABKAIoNgIYIAEgASkDIDcDECACIAFBEGoQGyAAQQA2AqjiASABIAEoAig2AgggASABKQMgNwMAIAAgARAbCyABQTBqJAALKgECfyMAQRBrIgAkACAAQQA2AgggAEIANwMAIAAQWCEBIABBEGokACABC4cBAQN/IwBBEGsiAiQAAkAgACgCAEUgACgCBEVzDQAgAiAAKAIINgIIIAIgACkCADcDAAJ/IAIoAgAiAQRAIAIoAghBqOMJIAERBQAMAQtBqOMJECgLIgFFDQAgASAAKQIANwL04QEgAUH84QFqIAAoAgg2AgAgARBZIAEhAwsgAkEQaiQAIAMLywEBAn8jAEEgayIBJAAgAEGBgIDAADYCtOIBIABBADYCiOIBIABBADYC7OEBIABCADcDkOIBIABBADYCpOMJIABBADYC3OIBIABCADcCzOIBIABBADYCvOIBIABBADYCxOABIABCADcCnOIBIABBpOIBakIANwIAIABBrOIBakEANgIAIAFCADcCECABQgA3AhggASABKQMYNwMIIAEgASkDEDcDACABKAIIQQh2QQFxIQIgAEEANgLg4gEgACACNgKM4gEgAUEgaiQAC3YBA38jAEEwayIBJAAgAARAIAEgAEHE0AFqIgIoAgA2AiggASAAKQK80AE3AyAgACgCACEDIAEgAigCADYCGCABIAApArzQATcDECADIAFBEGoQGyABIAEoAig2AgggASABKQMgNwMAIAAgARAbCyABQTBqJAALzAEBAX8gACABKAK00AE2ApjiASAAIAEoAgQiAjYCwOABIAAgAjYCvOABIAAgAiABKAIIaiICNgK44AEgACACNgLE4AEgASgCuNABBEAgAEKBgICAEDcDiOEBIAAgAUGk0ABqNgIMIAAgAUGUIGo2AgggACABQZwwajYCBCAAIAFBDGo2AgAgAEGs0AFqIAFBqNABaigCADYCACAAQbDQAWogAUGs0AFqKAIANgIAIABBtNABaiABQbDQAWooAgA2AgAPCyAAQgA3A4jhAQs7ACACRQRAQbp/DwsgBEUEQEFsDwsgAiAEEGAEQCAAIAEgAiADIAQgBRBhDwsgACABIAIgAyAEIAUQZQtGAQF/IwBBEGsiBSQAIAVBCGogBBAOAn8gBS0ACQRAIAAgASACIAMgBBAyDAELIAAgASACIAMgBBA0CyEAIAVBEGokACAACzQAIAAgAyAEIAUQNiIFEAMEQCAFDwsgBSAESQR/IAEgAiADIAVqIAQgBWsgABA1BUG4fwsLRgEBfyMAQRBrIgUkACAFQQhqIAQQDgJ/IAUtAAkEQCAAIAEgAiADIAQQYgwBCyAAIAEgAiADIAQQNQshACAFQRBqJAAgAAtZAQF/QQ8hAiABIABJBEAgAUEEdCAAbiECCyAAQQh2IgEgAkEYbCIAQYwIaigCAGwgAEGICGooAgBqIgJBA3YgAmogAEGACGooAgAgAEGECGooAgAgAWxqSQs3ACAAIAMgBCAFQYAQEDMiBRADBEAgBQ8LIAUgBEkEfyABIAIgAyAFaiAEIAVrIAAQMgVBuH8LC78DAQN/IwBBIGsiBSQAIAVBCGogAiADEAYiAhADRQRAIAAgAWoiB0F9aiEGIAUgBBAOIARBBGohAiAFLQACIQMDQEEAIAAgBkkgBUEIahAEGwRAIAAgAiAFQQhqIAMQAkECdGoiBC8BADsAACAFQQhqIAQtAAIQASAAIAQtAANqIgQgAiAFQQhqIAMQAkECdGoiAC8BADsAACAFQQhqIAAtAAIQASAEIAAtAANqIQAMAQUgB0F+aiEEA0AgBUEIahAEIAAgBEtyRQRAIAAgAiAFQQhqIAMQAkECdGoiBi8BADsAACAFQQhqIAYtAAIQASAAIAYtAANqIQAMAQsLA0AgACAES0UEQCAAIAIgBUEIaiADEAJBAnRqIgYvAQA7AAAgBUEIaiAGLQACEAEgACAGLQADaiEADAELCwJAIAAgB08NACAAIAIgBUEIaiADEAIiA0ECdGoiAC0AADoAACAALQADQQFGBEAgBUEIaiAALQACEAEMAQsgBSgCDEEfSw0AIAVBCGogAiADQQJ0ai0AAhABIAUoAgxBIUkNACAFQSA2AgwLIAFBbCAFQQhqEAobIQILCwsgBUEgaiQAIAILkgIBBH8jAEFAaiIJJAAgCSADQTQQCyEDAkAgBEECSA0AIAMgBEECdGooAgAhCSADQTxqIAgQIyADQQE6AD8gAyACOgA+QQAhBCADKAI8IQoDQCAEIAlGDQEgACAEQQJ0aiAKNgEAIARBAWohBAwAAAsAC0EAIQkDQCAGIAlGRQRAIAMgBSAJQQF0aiIKLQABIgtBAnRqIgwoAgAhBCADQTxqIAotAABBCHQgCGpB//8DcRAjIANBAjoAPyADIAcgC2siCiACajoAPiAEQQEgASAKa3RqIQogAygCPCELA0AgACAEQQJ0aiALNgEAIARBAWoiBCAKSQ0ACyAMIAo2AgAgCUEBaiEJDAELCyADQUBrJAALowIBCX8jAEHQAGsiCSQAIAlBEGogBUE0EAsaIAcgBmshDyAHIAFrIRADQAJAIAMgCkcEQEEBIAEgByACIApBAXRqIgYtAAEiDGsiCGsiC3QhDSAGLQAAIQ4gCUEQaiAMQQJ0aiIMKAIAIQYgCyAPTwRAIAAgBkECdGogCyAIIAUgCEE0bGogCCAQaiIIQQEgCEEBShsiCCACIAQgCEECdGooAgAiCEEBdGogAyAIayAHIA4QYyAGIA1qIQgMAgsgCUEMaiAOECMgCUEBOgAPIAkgCDoADiAGIA1qIQggCSgCDCELA0AgBiAITw0CIAAgBkECdGogCzYBACAGQQFqIQYMAAALAAsgCUHQAGokAA8LIAwgCDYCACAKQQFqIQoMAAALAAs0ACAAIAMgBCAFEDYiBRADBEAgBQ8LIAUgBEkEfyABIAIgAyAFaiAEIAVrIAAQNAVBuH8LCyMAIAA/AEEQdGtB//8DakEQdkAAQX9GBEBBAA8LQQAQAEEBCzsBAX8gAgRAA0AgACABIAJBgCAgAkGAIEkbIgMQCyEAIAFBgCBqIQEgAEGAIGohACACIANrIgINAAsLCwYAIAAQAwsLqBUJAEGICAsNAQAAAAEAAAACAAAAAgBBoAgLswYBAAAAAQAAAAIAAAACAAAAJgAAAIIAAAAhBQAASgAAAGcIAAAmAAAAwAEAAIAAAABJBQAASgAAAL4IAAApAAAALAIAAIAAAABJBQAASgAAAL4IAAAvAAAAygIAAIAAAACKBQAASgAAAIQJAAA1AAAAcwMAAIAAAACdBQAASgAAAKAJAAA9AAAAgQMAAIAAAADrBQAASwAAAD4KAABEAAAAngMAAIAAAABNBgAASwAAAKoKAABLAAAAswMAAIAAAADBBgAATQAAAB8NAABNAAAAUwQAAIAAAAAjCAAAUQAAAKYPAABUAAAAmQQAAIAAAABLCQAAVwAAALESAABYAAAA2gQAAIAAAABvCQAAXQAAACMUAABUAAAARQUAAIAAAABUCgAAagAAAIwUAABqAAAArwUAAIAAAAB2CQAAfAAAAE4QAAB8AAAA0gIAAIAAAABjBwAAkQAAAJAHAACSAAAAAAAAAAEAAAABAAAABQAAAA0AAAAdAAAAPQAAAH0AAAD9AAAA/QEAAP0DAAD9BwAA/Q8AAP0fAAD9PwAA/X8AAP3/AAD9/wEA/f8DAP3/BwD9/w8A/f8fAP3/PwD9/38A/f//AP3//wH9//8D/f//B/3//w/9//8f/f//P/3//38AAAAAAQAAAAIAAAADAAAABAAAAAUAAAAGAAAABwAAAAgAAAAJAAAACgAAAAsAAAAMAAAADQAAAA4AAAAPAAAAEAAAABEAAAASAAAAEwAAABQAAAAVAAAAFgAAABcAAAAYAAAAGQAAABoAAAAbAAAAHAAAAB0AAAAeAAAAHwAAAAMAAAAEAAAABQAAAAYAAAAHAAAACAAAAAkAAAAKAAAACwAAAAwAAAANAAAADgAAAA8AAAAQAAAAEQAAABIAAAATAAAAFAAAABUAAAAWAAAAFwAAABgAAAAZAAAAGgAAABsAAAAcAAAAHQAAAB4AAAAfAAAAIAAAACEAAAAiAAAAIwAAACUAAAAnAAAAKQAAACsAAAAvAAAAMwAAADsAAABDAAAAUwAAAGMAAACDAAAAAwEAAAMCAAADBAAAAwgAAAMQAAADIAAAA0AAAAOAAAADAAEAQeAPC1EBAAAAAQAAAAEAAAABAAAAAgAAAAIAAAADAAAAAwAAAAQAAAAEAAAABQAAAAcAAAAIAAAACQAAAAoAAAALAAAADAAAAA0AAAAOAAAADwAAABAAQcQQC4sBAQAAAAIAAAADAAAABAAAAAUAAAAGAAAABwAAAAgAAAAJAAAACgAAAAsAAAAMAAAADQAAAA4AAAAPAAAAEAAAABIAAAAUAAAAFgAAABgAAAAcAAAAIAAAACgAAAAwAAAAQAAAAIAAAAAAAQAAAAIAAAAEAAAACAAAABAAAAAgAAAAQAAAAIAAAAAAAQBBkBIL5gQBAAAAAQAAAAEAAAABAAAAAgAAAAIAAAADAAAAAwAAAAQAAAAGAAAABwAAAAgAAAAJAAAACgAAAAsAAAAMAAAADQAAAA4AAAAPAAAAEAAAAAEAAAAEAAAACAAAAAAAAAABAAEBBgAAAAAAAAQAAAAAEAAABAAAAAAgAAAFAQAAAAAAAAUDAAAAAAAABQQAAAAAAAAFBgAAAAAAAAUHAAAAAAAABQkAAAAAAAAFCgAAAAAAAAUMAAAAAAAABg4AAAAAAAEFEAAAAAAAAQUUAAAAAAABBRYAAAAAAAIFHAAAAAAAAwUgAAAAAAAEBTAAAAAgAAYFQAAAAAAABwWAAAAAAAAIBgABAAAAAAoGAAQAAAAADAYAEAAAIAAABAAAAAAAAAAEAQAAAAAAAAUCAAAAIAAABQQAAAAAAAAFBQAAACAAAAUHAAAAAAAABQgAAAAgAAAFCgAAAAAAAAULAAAAAAAABg0AAAAgAAEFEAAAAAAAAQUSAAAAIAABBRYAAAAAAAIFGAAAACAAAwUgAAAAAAADBSgAAAAAAAYEQAAAABAABgRAAAAAIAAHBYAAAAAAAAkGAAIAAAAACwYACAAAMAAABAAAAAAQAAAEAQAAACAAAAUCAAAAIAAABQMAAAAgAAAFBQAAACAAAAUGAAAAIAAABQgAAAAgAAAFCQAAACAAAAULAAAAIAAABQwAAAAAAAAGDwAAACAAAQUSAAAAIAABBRQAAAAgAAIFGAAAACAAAgUcAAAAIAADBSgAAAAgAAQFMAAAAAAAEAYAAAEAAAAPBgCAAAAAAA4GAEAAAAAADQYAIABBgBcLhwIBAAEBBQAAAAAAAAUAAAAAAAAGBD0AAAAAAAkF/QEAAAAADwX9fwAAAAAVBf3/HwAAAAMFBQAAAAAABwR9AAAAAAAMBf0PAAAAABIF/f8DAAAAFwX9/38AAAAFBR0AAAAAAAgE/QAAAAAADgX9PwAAAAAUBf3/DwAAAAIFAQAAABAABwR9AAAAAAALBf0HAAAAABEF/f8BAAAAFgX9/z8AAAAEBQ0AAAAQAAgE/QAAAAAADQX9HwAAAAATBf3/BwAAAAEFAQAAABAABgQ9AAAAAAAKBf0DAAAAABAF/f8AAAAAHAX9//8PAAAbBf3//wcAABoF/f//AwAAGQX9//8BAAAYBf3//wBBkBkLhgQBAAEBBgAAAAAAAAYDAAAAAAAABAQAAAAgAAAFBQAAAAAAAAUGAAAAAAAABQgAAAAAAAAFCQAAAAAAAAULAAAAAAAABg0AAAAAAAAGEAAAAAAAAAYTAAAAAAAABhYAAAAAAAAGGQAAAAAAAAYcAAAAAAAABh8AAAAAAAAGIgAAAAAAAQYlAAAAAAABBikAAAAAAAIGLwAAAAAAAwY7AAAAAAAEBlMAAAAAAAcGgwAAAAAACQYDAgAAEAAABAQAAAAAAAAEBQAAACAAAAUGAAAAAAAABQcAAAAgAAAFCQAAAAAAAAUKAAAAAAAABgwAAAAAAAAGDwAAAAAAAAYSAAAAAAAABhUAAAAAAAAGGAAAAAAAAAYbAAAAAAAABh4AAAAAAAAGIQAAAAAAAQYjAAAAAAABBicAAAAAAAIGKwAAAAAAAwYzAAAAAAAEBkMAAAAAAAUGYwAAAAAACAYDAQAAIAAABAQAAAAwAAAEBAAAABAAAAQFAAAAIAAABQcAAAAgAAAFCAAAACAAAAUKAAAAIAAABQsAAAAAAAAGDgAAAAAAAAYRAAAAAAAABhQAAAAAAAAGFwAAAAAAAAYaAAAAAAAABh0AAAAAAAAGIAAAAAAAEAYDAAEAAAAPBgOAAAAAAA4GA0AAAAAADQYDIAAAAAAMBgMQAAAAAAsGAwgAAAAACgYDBABBpB0L2QEBAAAAAwAAAAcAAAAPAAAAHwAAAD8AAAB/AAAA/wAAAP8BAAD/AwAA/wcAAP8PAAD/HwAA/z8AAP9/AAD//wAA//8BAP//AwD//wcA//8PAP//HwD//z8A//9/AP///wD///8B////A////wf///8P////H////z////9/AAAAAAEAAAACAAAABAAAAAAAAAACAAAABAAAAAgAAAAAAAAAAQAAAAIAAAABAAAABAAAAAQAAAAEAAAABAAAAAgAAAAIAAAACAAAAAcAAAAIAAAACQAAAAoAAAALAEGgIAsDwBBQ";

// node_modules/three/examples/jsm/loaders/KTX2Loader.js
var _taskCache2 = /* @__PURE__ */ new WeakMap();
var _activeLoaders = 0;
var _zstd;
var KTX2Loader = class extends Loader {
  constructor(manager) {
    super(manager);
    this.transcoderPath = "";
    this.transcoderBinary = null;
    this.transcoderPending = null;
    this.workerPool = new WorkerPool();
    this.workerSourceURL = "";
    this.workerConfig = null;
    if (typeof MSC_TRANSCODER !== "undefined") {
      console.warn(
        'THREE.KTX2Loader: Please update to latest "basis_transcoder". "msc_basis_transcoder" is no longer supported in three.js r125+.'
      );
    }
  }
  setTranscoderPath(path) {
    this.transcoderPath = path;
    return this;
  }
  setWorkerLimit(num) {
    this.workerPool.setWorkerLimit(num);
    return this;
  }
  detectSupport(renderer) {
    if (renderer.isWebGPURenderer === true) {
      this.workerConfig = {
        astcSupported: renderer.hasFeature("texture-compression-astc"),
        etc1Supported: false,
        etc2Supported: renderer.hasFeature("texture-compression-etc2"),
        dxtSupported: renderer.hasFeature("texture-compression-bc"),
        bptcSupported: false,
        pvrtcSupported: false
      };
    } else {
      this.workerConfig = {
        astcSupported: renderer.extensions.has("WEBGL_compressed_texture_astc"),
        etc1Supported: renderer.extensions.has("WEBGL_compressed_texture_etc1"),
        etc2Supported: renderer.extensions.has("WEBGL_compressed_texture_etc"),
        dxtSupported: renderer.extensions.has("WEBGL_compressed_texture_s3tc"),
        bptcSupported: renderer.extensions.has("EXT_texture_compression_bptc"),
        pvrtcSupported: renderer.extensions.has("WEBGL_compressed_texture_pvrtc") || renderer.extensions.has("WEBKIT_WEBGL_compressed_texture_pvrtc")
      };
      if (renderer.capabilities.isWebGL2) {
        this.workerConfig.etc1Supported = false;
      }
    }
    return this;
  }
  init() {
    if (!this.transcoderPending) {
      const jsLoader = new FileLoader(this.manager);
      jsLoader.setPath(this.transcoderPath);
      jsLoader.setWithCredentials(this.withCredentials);
      const jsContent = jsLoader.loadAsync("basis_transcoder.js");
      const binaryLoader = new FileLoader(this.manager);
      binaryLoader.setPath(this.transcoderPath);
      binaryLoader.setResponseType("arraybuffer");
      binaryLoader.setWithCredentials(this.withCredentials);
      const binaryContent = binaryLoader.loadAsync("basis_transcoder.wasm");
      this.transcoderPending = Promise.all([jsContent, binaryContent]).then(([jsContent2, binaryContent2]) => {
        const fn = KTX2Loader.BasisWorker.toString();
        const body = [
          "/* constants */",
          "let _EngineFormat = " + JSON.stringify(KTX2Loader.EngineFormat),
          "let _TranscoderFormat = " + JSON.stringify(KTX2Loader.TranscoderFormat),
          "let _BasisFormat = " + JSON.stringify(KTX2Loader.BasisFormat),
          "/* basis_transcoder.js */",
          jsContent2,
          "/* worker */",
          fn.substring(fn.indexOf("{") + 1, fn.lastIndexOf("}"))
        ].join("\n");
        this.workerSourceURL = URL.createObjectURL(new Blob([body]));
        this.transcoderBinary = binaryContent2;
        this.workerPool.setWorkerCreator(() => {
          const worker = new Worker(this.workerSourceURL);
          const transcoderBinary = this.transcoderBinary.slice(0);
          worker.postMessage({ type: "init", config: this.workerConfig, transcoderBinary }, [transcoderBinary]);
          return worker;
        });
      });
      if (_activeLoaders > 0) {
        console.warn(
          "THREE.KTX2Loader: Multiple active KTX2 loaders may cause performance issues. Use a single KTX2Loader instance, or call .dispose() on old instances."
        );
      }
      _activeLoaders++;
    }
    return this.transcoderPending;
  }
  load(url, onLoad, onProgress, onError) {
    if (this.workerConfig === null) {
      throw new Error("THREE.KTX2Loader: Missing initialization with `.detectSupport( renderer )`.");
    }
    const loader2 = new FileLoader(this.manager);
    loader2.setResponseType("arraybuffer");
    loader2.setWithCredentials(this.withCredentials);
    loader2.load(url, (buffer) => {
      if (_taskCache2.has(buffer)) {
        const cachedTask = _taskCache2.get(buffer);
        return cachedTask.promise.then(onLoad).catch(onError);
      }
      this._createTexture(buffer).then((texture) => onLoad ? onLoad(texture) : null).catch(onError);
    }, onProgress, onError);
  }
  _createTextureFrom(transcodeResult, container) {
    const { faces, width, height, format, type, error, dfdTransferFn, dfdFlags } = transcodeResult;
    if (type === "error")
      return Promise.reject(error);
    let texture;
    if (container.faceCount === 6) {
      texture = new CompressedTexture();
      texture.image = faces;
      texture.format = format;
      texture.type = UnsignedByteType;
    } else {
      const mipmaps = faces[0].mipmaps;
      texture = container.layerCount > 1 ? new CompressedArrayTexture(mipmaps, width, height, container.layerCount, format, UnsignedByteType) : new CompressedTexture(mipmaps, width, height, format, UnsignedByteType);
    }
    texture.minFilter = faces[0].mipmaps.length === 1 ? LinearFilter : LinearMipmapLinearFilter;
    texture.magFilter = LinearFilter;
    texture.generateMipmaps = false;
    texture.needsUpdate = true;
    texture.colorSpace = dfdTransferFn === x ? SRGBColorSpace : NoColorSpace;
    texture.premultiplyAlpha = !!(dfdFlags & p);
    return texture;
  }
  /**
   * @param {ArrayBuffer} buffer
   * @param {object?} config
   * @return {Promise<CompressedTexture|CompressedArrayTexture|DataTexture|Data3DTexture>}
   */
  async _createTexture(buffer, config = {}) {
    const container = Pi(new Uint8Array(buffer));
    if (container.vkFormat !== nt) {
      const mipmaps = [];
      const pendings = [];
      for (let levelIndex = 0; levelIndex < container.levels.length; levelIndex++) {
        pendings.push(createDataTexture(container, levelIndex).then(function(dataTexture) {
          mipmaps[levelIndex] = dataTexture;
        }));
      }
      await Promise.all(pendings);
      const texture = mipmaps[0];
      texture.mipmaps = mipmaps.map((dt2) => {
        return {
          data: dt2.source.data,
          width: dt2.source.data.width,
          height: dt2.source.data.height,
          depth: dt2.source.data.depth
        };
      });
      return texture;
    }
    const taskConfig = config;
    const texturePending = this.init().then(() => {
      return this.workerPool.postMessage({ type: "transcode", buffer, taskConfig }, [buffer]);
    }).then((e) => this._createTextureFrom(e.data, container));
    _taskCache2.set(buffer, { promise: texturePending });
    return texturePending;
  }
  dispose() {
    this.workerPool.dispose();
    if (this.workerSourceURL)
      URL.revokeObjectURL(this.workerSourceURL);
    _activeLoaders--;
    return this;
  }
};
KTX2Loader.BasisFormat = {
  ETC1S: 0,
  UASTC_4x4: 1
};
KTX2Loader.TranscoderFormat = {
  ETC1: 0,
  ETC2: 1,
  BC1: 2,
  BC3: 3,
  BC4: 4,
  BC5: 5,
  BC7_M6_OPAQUE_ONLY: 6,
  BC7_M5: 7,
  PVRTC1_4_RGB: 8,
  PVRTC1_4_RGBA: 9,
  ASTC_4x4: 10,
  ATC_RGB: 11,
  ATC_RGBA_INTERPOLATED_ALPHA: 12,
  RGBA32: 13,
  RGB565: 14,
  BGR565: 15,
  RGBA4444: 16
};
KTX2Loader.EngineFormat = {
  RGBAFormat,
  RGBA_ASTC_4x4_Format,
  RGBA_BPTC_Format,
  RGBA_ETC2_EAC_Format,
  RGBA_PVRTC_4BPPV1_Format,
  RGBA_S3TC_DXT5_Format,
  RGB_ETC1_Format,
  RGB_ETC2_Format,
  RGB_PVRTC_4BPPV1_Format,
  RGB_S3TC_DXT1_Format
};
KTX2Loader.BasisWorker = function() {
  let config;
  let transcoderPending;
  let BasisModule;
  const EngineFormat = _EngineFormat;
  const TranscoderFormat = _TranscoderFormat;
  const BasisFormat = _BasisFormat;
  self.addEventListener("message", function(e) {
    const message = e.data;
    switch (message.type) {
      case "init":
        config = message.config;
        init2(message.transcoderBinary);
        break;
      case "transcode":
        transcoderPending.then(() => {
          try {
            const { faces, buffers, width, height, hasAlpha, format, dfdTransferFn, dfdFlags } = transcode(message.buffer);
            self.postMessage({ type: "transcode", id: message.id, faces, width, height, hasAlpha, format, dfdTransferFn, dfdFlags }, buffers);
          } catch (error) {
            console.error(error);
            self.postMessage({ type: "error", id: message.id, error: error.message });
          }
        });
        break;
    }
  });
  function init2(wasmBinary) {
    transcoderPending = new Promise((resolve) => {
      BasisModule = { wasmBinary, onRuntimeInitialized: resolve };
      BASIS(BasisModule);
    }).then(() => {
      BasisModule.initializeBasis();
      if (BasisModule.KTX2File === void 0) {
        console.warn("THREE.KTX2Loader: Please update Basis Universal transcoder.");
      }
    });
  }
  function transcode(buffer) {
    const ktx2File = new BasisModule.KTX2File(new Uint8Array(buffer));
    function cleanup() {
      ktx2File.close();
      ktx2File.delete();
    }
    if (!ktx2File.isValid()) {
      cleanup();
      throw new Error("THREE.KTX2Loader:	Invalid or unsupported .ktx2 file");
    }
    const basisFormat = ktx2File.isUASTC() ? BasisFormat.UASTC_4x4 : BasisFormat.ETC1S;
    const width = ktx2File.getWidth();
    const height = ktx2File.getHeight();
    const layerCount = ktx2File.getLayers() || 1;
    const levelCount = ktx2File.getLevels();
    const faceCount = ktx2File.getFaces();
    const hasAlpha = ktx2File.getHasAlpha();
    const dfdTransferFn = ktx2File.getDFDTransferFunc();
    const dfdFlags = ktx2File.getDFDFlags();
    const { transcoderFormat, engineFormat } = getTranscoderFormat(basisFormat, width, height, hasAlpha);
    if (!width || !height || !levelCount) {
      cleanup();
      throw new Error("THREE.KTX2Loader:	Invalid texture");
    }
    if (!ktx2File.startTranscoding()) {
      cleanup();
      throw new Error("THREE.KTX2Loader: .startTranscoding failed");
    }
    const faces = [];
    const buffers = [];
    for (let face = 0; face < faceCount; face++) {
      const mipmaps = [];
      for (let mip = 0; mip < levelCount; mip++) {
        const layerMips = [];
        let mipWidth, mipHeight;
        for (let layer = 0; layer < layerCount; layer++) {
          const levelInfo = ktx2File.getImageLevelInfo(mip, layer, face);
          if (face === 0 && mip === 0 && layer === 0 && (levelInfo.origWidth % 4 !== 0 || levelInfo.origHeight % 4 !== 0)) {
            console.warn("THREE.KTX2Loader: ETC1S and UASTC textures should use multiple-of-four dimensions.");
          }
          if (levelCount > 1) {
            mipWidth = levelInfo.origWidth;
            mipHeight = levelInfo.origHeight;
          } else {
            mipWidth = levelInfo.width;
            mipHeight = levelInfo.height;
          }
          const dst = new Uint8Array(ktx2File.getImageTranscodedSizeInBytes(mip, layer, 0, transcoderFormat));
          const status = ktx2File.transcodeImage(dst, mip, layer, face, transcoderFormat, 0, -1, -1);
          if (!status) {
            cleanup();
            throw new Error("THREE.KTX2Loader: .transcodeImage failed.");
          }
          layerMips.push(dst);
        }
        const mipData = concat(layerMips);
        mipmaps.push({ data: mipData, width: mipWidth, height: mipHeight });
        buffers.push(mipData.buffer);
      }
      faces.push({ mipmaps, width, height, format: engineFormat });
    }
    cleanup();
    return { faces, buffers, width, height, hasAlpha, format: engineFormat, dfdTransferFn, dfdFlags };
  }
  const FORMAT_OPTIONS = [
    {
      if: "astcSupported",
      basisFormat: [BasisFormat.UASTC_4x4],
      transcoderFormat: [TranscoderFormat.ASTC_4x4, TranscoderFormat.ASTC_4x4],
      engineFormat: [EngineFormat.RGBA_ASTC_4x4_Format, EngineFormat.RGBA_ASTC_4x4_Format],
      priorityETC1S: Infinity,
      priorityUASTC: 1,
      needsPowerOfTwo: false
    },
    {
      if: "bptcSupported",
      basisFormat: [BasisFormat.ETC1S, BasisFormat.UASTC_4x4],
      transcoderFormat: [TranscoderFormat.BC7_M5, TranscoderFormat.BC7_M5],
      engineFormat: [EngineFormat.RGBA_BPTC_Format, EngineFormat.RGBA_BPTC_Format],
      priorityETC1S: 3,
      priorityUASTC: 2,
      needsPowerOfTwo: false
    },
    {
      if: "dxtSupported",
      basisFormat: [BasisFormat.ETC1S, BasisFormat.UASTC_4x4],
      transcoderFormat: [TranscoderFormat.BC1, TranscoderFormat.BC3],
      engineFormat: [EngineFormat.RGB_S3TC_DXT1_Format, EngineFormat.RGBA_S3TC_DXT5_Format],
      priorityETC1S: 4,
      priorityUASTC: 5,
      needsPowerOfTwo: false
    },
    {
      if: "etc2Supported",
      basisFormat: [BasisFormat.ETC1S, BasisFormat.UASTC_4x4],
      transcoderFormat: [TranscoderFormat.ETC1, TranscoderFormat.ETC2],
      engineFormat: [EngineFormat.RGB_ETC2_Format, EngineFormat.RGBA_ETC2_EAC_Format],
      priorityETC1S: 1,
      priorityUASTC: 3,
      needsPowerOfTwo: false
    },
    {
      if: "etc1Supported",
      basisFormat: [BasisFormat.ETC1S, BasisFormat.UASTC_4x4],
      transcoderFormat: [TranscoderFormat.ETC1],
      engineFormat: [EngineFormat.RGB_ETC1_Format],
      priorityETC1S: 2,
      priorityUASTC: 4,
      needsPowerOfTwo: false
    },
    {
      if: "pvrtcSupported",
      basisFormat: [BasisFormat.ETC1S, BasisFormat.UASTC_4x4],
      transcoderFormat: [TranscoderFormat.PVRTC1_4_RGB, TranscoderFormat.PVRTC1_4_RGBA],
      engineFormat: [EngineFormat.RGB_PVRTC_4BPPV1_Format, EngineFormat.RGBA_PVRTC_4BPPV1_Format],
      priorityETC1S: 5,
      priorityUASTC: 6,
      needsPowerOfTwo: true
    }
  ];
  const ETC1S_OPTIONS = FORMAT_OPTIONS.sort(function(a, b) {
    return a.priorityETC1S - b.priorityETC1S;
  });
  const UASTC_OPTIONS = FORMAT_OPTIONS.sort(function(a, b) {
    return a.priorityUASTC - b.priorityUASTC;
  });
  function getTranscoderFormat(basisFormat, width, height, hasAlpha) {
    let transcoderFormat;
    let engineFormat;
    const options = basisFormat === BasisFormat.ETC1S ? ETC1S_OPTIONS : UASTC_OPTIONS;
    for (let i = 0; i < options.length; i++) {
      const opt = options[i];
      if (!config[opt.if])
        continue;
      if (!opt.basisFormat.includes(basisFormat))
        continue;
      if (hasAlpha && opt.transcoderFormat.length < 2)
        continue;
      if (opt.needsPowerOfTwo && !(isPowerOfTwo(width) && isPowerOfTwo(height)))
        continue;
      transcoderFormat = opt.transcoderFormat[hasAlpha ? 1 : 0];
      engineFormat = opt.engineFormat[hasAlpha ? 1 : 0];
      return { transcoderFormat, engineFormat };
    }
    console.warn("THREE.KTX2Loader: No suitable compressed texture format found. Decoding to RGBA32.");
    transcoderFormat = TranscoderFormat.RGBA32;
    engineFormat = EngineFormat.RGBAFormat;
    return { transcoderFormat, engineFormat };
  }
  function isPowerOfTwo(value) {
    if (value <= 2)
      return true;
    return (value & value - 1) === 0 && value !== 0;
  }
  function concat(arrays) {
    if (arrays.length === 1)
      return arrays[0];
    let totalByteLength = 0;
    for (let i = 0; i < arrays.length; i++) {
      const array = arrays[i];
      totalByteLength += array.byteLength;
    }
    const result = new Uint8Array(totalByteLength);
    let byteOffset = 0;
    for (let i = 0; i < arrays.length; i++) {
      const array = arrays[i];
      result.set(array, byteOffset);
      byteOffset += array.byteLength;
    }
    return result;
  }
};
var FORMAT_MAP = {
  [Ae]: RGBAFormat,
  [pe]: RGBAFormat,
  [Ot]: RGBAFormat,
  [Ft]: RGBAFormat,
  [de]: RGFormat,
  [se]: RGFormat,
  [yt]: RGFormat,
  [dt]: RGFormat,
  [xe]: RedFormat,
  [$t]: RedFormat,
  [gt]: RedFormat,
  [ct]: RedFormat
};
var TYPE_MAP = {
  [Ae]: FloatType,
  [pe]: HalfFloatType,
  [Ot]: UnsignedByteType,
  [Ft]: UnsignedByteType,
  [de]: FloatType,
  [se]: HalfFloatType,
  [yt]: UnsignedByteType,
  [dt]: UnsignedByteType,
  [xe]: FloatType,
  [$t]: HalfFloatType,
  [gt]: UnsignedByteType,
  [ct]: UnsignedByteType
};
var COLOR_SPACE_MAP = {
  [Ft]: SRGBColorSpace,
  [dt]: SRGBColorSpace,
  [gt]: SRGBColorSpace
};
async function createDataTexture(container, levelIndex = 0) {
  const { vkFormat } = container;
  const pixelWidth = Math.max(1, container.pixelWidth >> levelIndex);
  const pixelHeight = Math.max(1, container.pixelHeight >> levelIndex);
  const pixelDepth = Math.max(1, container.pixelDepth >> levelIndex);
  if (FORMAT_MAP[vkFormat] === void 0) {
    throw new Error("THREE.KTX2Loader: Unsupported vkFormat.");
  }
  const level = container.levels[levelIndex];
  let levelData;
  let view;
  if (container.supercompressionScheme === t) {
    levelData = level.levelData;
  } else if (container.supercompressionScheme === n) {
    if (!_zstd) {
      _zstd = new Promise(async (resolve) => {
        const zstd = new Q();
        await zstd.init();
        resolve(zstd);
      });
    }
    levelData = (await _zstd).decode(level.levelData, level.uncompressedByteLength);
  } else {
    throw new Error("THREE.KTX2Loader: Unsupported supercompressionScheme.");
  }
  if (TYPE_MAP[vkFormat] === FloatType) {
    view = new Float32Array(
      levelData.buffer,
      levelData.byteOffset,
      levelData.byteLength / Float32Array.BYTES_PER_ELEMENT
    );
  } else if (TYPE_MAP[vkFormat] === HalfFloatType) {
    view = new Uint16Array(
      levelData.buffer,
      levelData.byteOffset,
      levelData.byteLength / Uint16Array.BYTES_PER_ELEMENT
    );
  } else {
    view = levelData;
  }
  const texture = pixelDepth === 0 ? new DataTexture(view, pixelWidth, pixelHeight) : new Data3DTexture(view, pixelWidth, pixelHeight, pixelDepth);
  texture.type = TYPE_MAP[vkFormat];
  texture.format = FORMAT_MAP[vkFormat];
  texture.colorSpace = COLOR_SPACE_MAP[vkFormat] || NoColorSpace;
  texture.needsUpdate = true;
  return Promise.resolve(texture);
}

// node_modules/threlte/lib/buildSceneGraph.js
var buildSceneGraph = (object) => {
  const data = { nodes: {}, materials: {} };
  if (object) {
    object.traverse((obj) => {
      if (obj.name)
        data.nodes[obj.name] = obj;
      if (obj.material && !data.materials[obj.material.name])
        data.materials[obj.material.name] = obj.material;
    });
  }
  return data;
};

// node_modules/threlte/objects/GLTF.svelte
var { Object: Object_12, console: console_14 } = globals;
function get_each_context(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[49] = list[i];
  return child_ctx;
}
function get_each_context_1(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[52] = list[i];
  return child_ctx;
}
function create_if_block5(ctx) {
  let object3dinstance;
  let updating_inViewport;
  let t0;
  let t1;
  let each1_anchor;
  let current;
  function object3dinstance_inViewport_binding(value) {
    ctx[29](value);
  }
  let object3dinstance_props = {
    object: (
      /*scene*/
      ctx[0]
    ),
    position: (
      /*position*/
      ctx[2]
    ),
    scale: (
      /*scale*/
      ctx[3]
    ),
    rotation: (
      /*rotation*/
      ctx[4]
    ),
    lookAt: (
      /*lookAt*/
      ctx[11]
    ),
    frustumCulled: (
      /*frustumCulled*/
      ctx[8]
    ),
    renderOrder: (
      /*renderOrder*/
      ctx[9]
    ),
    visible: (
      /*visible*/
      ctx[10]
    ),
    castShadow: (
      /*castShadow*/
      ctx[6]
    ),
    receiveShadow: (
      /*receiveShadow*/
      ctx[7]
    ),
    viewportAware: (
      /*viewportAware*/
      ctx[5]
    ),
    $$slots: { default: [create_default_slot21] },
    $$scope: { ctx }
  };
  if (
    /*inViewport*/
    ctx[1] !== void 0
  ) {
    object3dinstance_props.inViewport = /*inViewport*/
    ctx[1];
  }
  object3dinstance = new Object3DInstance_default({
    props: object3dinstance_props,
    $$inline: true
  });
  binding_callbacks.push(() => bind(object3dinstance, "inViewport", object3dinstance_inViewport_binding));
  object3dinstance.$on(
    "viewportenter",
    /*viewportenter_handler*/
    ctx[30]
  );
  object3dinstance.$on(
    "viewportleave",
    /*viewportleave_handler*/
    ctx[31]
  );
  let each_value_1 = (
    /*interactiveMeshes*/
    ctx[14]
  );
  validate_each_argument(each_value_1);
  let each_blocks_1 = [];
  for (let i = 0; i < each_value_1.length; i += 1) {
    each_blocks_1[i] = create_each_block_1(get_each_context_1(ctx, each_value_1, i));
  }
  const out = (i) => transition_out(each_blocks_1[i], 1, 1, () => {
    each_blocks_1[i] = null;
  });
  let each_value = (
    /*layerableObjects*/
    ctx[15]
  );
  validate_each_argument(each_value);
  let each_blocks = [];
  for (let i = 0; i < each_value.length; i += 1) {
    each_blocks[i] = create_each_block(get_each_context(ctx, each_value, i));
  }
  const out_1 = (i) => transition_out(each_blocks[i], 1, 1, () => {
    each_blocks[i] = null;
  });
  const block = {
    c: function create() {
      create_component(object3dinstance.$$.fragment);
      t0 = space();
      for (let i = 0; i < each_blocks_1.length; i += 1) {
        each_blocks_1[i].c();
      }
      t1 = space();
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      each1_anchor = empty();
    },
    l: function claim(nodes) {
      claim_component(object3dinstance.$$.fragment, nodes);
      t0 = claim_space(nodes);
      for (let i = 0; i < each_blocks_1.length; i += 1) {
        each_blocks_1[i].l(nodes);
      }
      t1 = claim_space(nodes);
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].l(nodes);
      }
      each1_anchor = empty();
    },
    m: function mount(target, anchor) {
      mount_component(object3dinstance, target, anchor);
      insert_hydration_dev(target, t0, anchor);
      for (let i = 0; i < each_blocks_1.length; i += 1) {
        if (each_blocks_1[i]) {
          each_blocks_1[i].m(target, anchor);
        }
      }
      insert_hydration_dev(target, t1, anchor);
      for (let i = 0; i < each_blocks.length; i += 1) {
        if (each_blocks[i]) {
          each_blocks[i].m(target, anchor);
        }
      }
      insert_hydration_dev(target, each1_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const object3dinstance_changes = {};
      if (dirty[0] & /*scene*/
      1)
        object3dinstance_changes.object = /*scene*/
        ctx2[0];
      if (dirty[0] & /*position*/
      4)
        object3dinstance_changes.position = /*position*/
        ctx2[2];
      if (dirty[0] & /*scale*/
      8)
        object3dinstance_changes.scale = /*scale*/
        ctx2[3];
      if (dirty[0] & /*rotation*/
      16)
        object3dinstance_changes.rotation = /*rotation*/
        ctx2[4];
      if (dirty[0] & /*lookAt*/
      2048)
        object3dinstance_changes.lookAt = /*lookAt*/
        ctx2[11];
      if (dirty[0] & /*frustumCulled*/
      256)
        object3dinstance_changes.frustumCulled = /*frustumCulled*/
        ctx2[8];
      if (dirty[0] & /*renderOrder*/
      512)
        object3dinstance_changes.renderOrder = /*renderOrder*/
        ctx2[9];
      if (dirty[0] & /*visible*/
      1024)
        object3dinstance_changes.visible = /*visible*/
        ctx2[10];
      if (dirty[0] & /*castShadow*/
      64)
        object3dinstance_changes.castShadow = /*castShadow*/
        ctx2[6];
      if (dirty[0] & /*receiveShadow*/
      128)
        object3dinstance_changes.receiveShadow = /*receiveShadow*/
        ctx2[7];
      if (dirty[0] & /*viewportAware*/
      32)
        object3dinstance_changes.viewportAware = /*viewportAware*/
        ctx2[5];
      if (dirty[1] & /*$$scope*/
      256) {
        object3dinstance_changes.$$scope = { dirty, ctx: ctx2 };
      }
      if (!updating_inViewport && dirty[0] & /*inViewport*/
      2) {
        updating_inViewport = true;
        object3dinstance_changes.inViewport = /*inViewport*/
        ctx2[1];
        add_flush_callback(() => updating_inViewport = false);
      }
      object3dinstance.$set(object3dinstance_changes);
      if (dirty[0] & /*interactiveMeshes, interactive, ignorePointer*/
      28672) {
        each_value_1 = /*interactiveMeshes*/
        ctx2[14];
        validate_each_argument(each_value_1);
        let i;
        for (i = 0; i < each_value_1.length; i += 1) {
          const child_ctx = get_each_context_1(ctx2, each_value_1, i);
          if (each_blocks_1[i]) {
            each_blocks_1[i].p(child_ctx, dirty);
            transition_in(each_blocks_1[i], 1);
          } else {
            each_blocks_1[i] = create_each_block_1(child_ctx);
            each_blocks_1[i].c();
            transition_in(each_blocks_1[i], 1);
            each_blocks_1[i].m(t1.parentNode, t1);
          }
        }
        group_outros();
        for (i = each_value_1.length; i < each_blocks_1.length; i += 1) {
          out(i);
        }
        check_outros();
      }
      if (dirty[0] & /*layerableObjects*/
      32768) {
        each_value = /*layerableObjects*/
        ctx2[15];
        validate_each_argument(each_value);
        let i;
        for (i = 0; i < each_value.length; i += 1) {
          const child_ctx = get_each_context(ctx2, each_value, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
            transition_in(each_blocks[i], 1);
          } else {
            each_blocks[i] = create_each_block(child_ctx);
            each_blocks[i].c();
            transition_in(each_blocks[i], 1);
            each_blocks[i].m(each1_anchor.parentNode, each1_anchor);
          }
        }
        group_outros();
        for (i = each_value.length; i < each_blocks.length; i += 1) {
          out_1(i);
        }
        check_outros();
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(object3dinstance.$$.fragment, local);
      for (let i = 0; i < each_value_1.length; i += 1) {
        transition_in(each_blocks_1[i]);
      }
      for (let i = 0; i < each_value.length; i += 1) {
        transition_in(each_blocks[i]);
      }
      current = true;
    },
    o: function outro(local) {
      transition_out(object3dinstance.$$.fragment, local);
      each_blocks_1 = each_blocks_1.filter(Boolean);
      for (let i = 0; i < each_blocks_1.length; i += 1) {
        transition_out(each_blocks_1[i]);
      }
      each_blocks = each_blocks.filter(Boolean);
      for (let i = 0; i < each_blocks.length; i += 1) {
        transition_out(each_blocks[i]);
      }
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(object3dinstance, detaching);
      if (detaching)
        detach_dev(t0);
      destroy_each(each_blocks_1, detaching);
      if (detaching)
        detach_dev(t1);
      destroy_each(each_blocks, detaching);
      if (detaching)
        detach_dev(each1_anchor);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block5.name,
    type: "if",
    source: "(152:0) {#if scene}",
    ctx
  });
  return block;
}
function create_default_slot21(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[28].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[39],
    null
  );
  const block = {
    c: function create() {
      if (default_slot)
        default_slot.c();
    },
    l: function claim(nodes) {
      if (default_slot)
        default_slot.l(nodes);
    },
    m: function mount(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty[1] & /*$$scope*/
        256)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[39],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[39]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[39],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot21.name,
    type: "slot",
    source: "(153:2) <Object3DInstance     object={scene}     {position}     {scale}     {rotation}     {lookAt}     {frustumCulled}     {renderOrder}     {visible}     {castShadow}     {receiveShadow}     {viewportAware}     bind:inViewport     on:viewportenter     on:viewportleave   >",
    ctx
  });
  return block;
}
function create_key_block_1(ctx) {
  let interactiveobject;
  let current;
  interactiveobject = new InteractiveObject_default({
    props: {
      object: (
        /*mesh*/
        ctx[52]
      ),
      interactive: (
        /*interactive*/
        ctx[13]
      ),
      ignorePointer: (
        /*ignorePointer*/
        ctx[12]
      )
    },
    $$inline: true
  });
  interactiveobject.$on(
    "click",
    /*click_handler*/
    ctx[32]
  );
  interactiveobject.$on(
    "contextmenu",
    /*contextmenu_handler*/
    ctx[33]
  );
  interactiveobject.$on(
    "pointerup",
    /*pointerup_handler*/
    ctx[34]
  );
  interactiveobject.$on(
    "pointerdown",
    /*pointerdown_handler*/
    ctx[35]
  );
  interactiveobject.$on(
    "pointerenter",
    /*pointerenter_handler*/
    ctx[36]
  );
  interactiveobject.$on(
    "pointerleave",
    /*pointerleave_handler*/
    ctx[37]
  );
  interactiveobject.$on(
    "pointermove",
    /*pointermove_handler*/
    ctx[38]
  );
  const block = {
    c: function create() {
      create_component(interactiveobject.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(interactiveobject.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(interactiveobject, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const interactiveobject_changes = {};
      if (dirty[0] & /*interactiveMeshes*/
      16384)
        interactiveobject_changes.object = /*mesh*/
        ctx2[52];
      if (dirty[0] & /*interactive*/
      8192)
        interactiveobject_changes.interactive = /*interactive*/
        ctx2[13];
      if (dirty[0] & /*ignorePointer*/
      4096)
        interactiveobject_changes.ignorePointer = /*ignorePointer*/
        ctx2[12];
      interactiveobject.$set(interactiveobject_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(interactiveobject.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(interactiveobject.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(interactiveobject, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_key_block_1.name,
    type: "key",
    source: "(173:4) {#key mesh.uuid}",
    ctx
  });
  return block;
}
function create_each_block_1(ctx) {
  let previous_key = (
    /*mesh*/
    ctx[52].uuid
  );
  let key_block_anchor;
  let current;
  let key_block = create_key_block_1(ctx);
  const block = {
    c: function create() {
      key_block.c();
      key_block_anchor = empty();
    },
    l: function claim(nodes) {
      key_block.l(nodes);
      key_block_anchor = empty();
    },
    m: function mount(target, anchor) {
      key_block.m(target, anchor);
      insert_hydration_dev(target, key_block_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (dirty[0] & /*interactiveMeshes*/
      16384 && safe_not_equal(previous_key, previous_key = /*mesh*/
      ctx2[52].uuid)) {
        group_outros();
        transition_out(key_block, 1, 1, noop);
        check_outros();
        key_block = create_key_block_1(ctx2);
        key_block.c();
        transition_in(key_block, 1);
        key_block.m(key_block_anchor.parentNode, key_block_anchor);
      } else {
        key_block.p(ctx2, dirty);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(key_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(key_block);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(key_block_anchor);
      key_block.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_each_block_1.name,
    type: "each",
    source: "(172:2) {#each interactiveMeshes as mesh}",
    ctx
  });
  return block;
}
function create_key_block2(ctx) {
  let layerableobject;
  let current;
  layerableobject = new LayerableObject_default({
    props: { object: (
      /*object*/
      ctx[49]
    ) },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(layerableobject.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(layerableobject.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(layerableobject, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const layerableobject_changes = {};
      if (dirty[0] & /*layerableObjects*/
      32768)
        layerableobject_changes.object = /*object*/
        ctx2[49];
      layerableobject.$set(layerableobject_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(layerableobject.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(layerableobject.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(layerableobject, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_key_block2.name,
    type: "key",
    source: "(190:4) {#key object.uuid}",
    ctx
  });
  return block;
}
function create_each_block(ctx) {
  let previous_key = (
    /*object*/
    ctx[49].uuid
  );
  let key_block_anchor;
  let current;
  let key_block = create_key_block2(ctx);
  const block = {
    c: function create() {
      key_block.c();
      key_block_anchor = empty();
    },
    l: function claim(nodes) {
      key_block.l(nodes);
      key_block_anchor = empty();
    },
    m: function mount(target, anchor) {
      key_block.m(target, anchor);
      insert_hydration_dev(target, key_block_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (dirty[0] & /*layerableObjects*/
      32768 && safe_not_equal(previous_key, previous_key = /*object*/
      ctx2[49].uuid)) {
        group_outros();
        transition_out(key_block, 1, 1, noop);
        check_outros();
        key_block = create_key_block2(ctx2);
        key_block.c();
        transition_in(key_block, 1);
        key_block.m(key_block_anchor.parentNode, key_block_anchor);
      } else {
        key_block.p(ctx2, dirty);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(key_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(key_block);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(key_block_anchor);
      key_block.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_each_block.name,
    type: "each",
    source: "(189:2) {#each layerableObjects as object}",
    ctx
  });
  return block;
}
function create_fragment35(ctx) {
  let if_block_anchor;
  let current;
  let if_block = (
    /*scene*/
    ctx[0] && create_if_block5(ctx)
  );
  const block = {
    c: function create() {
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
    },
    l: function claim(nodes) {
      if (if_block)
        if_block.l(nodes);
      if_block_anchor = empty();
    },
    m: function mount(target, anchor) {
      if (if_block)
        if_block.m(target, anchor);
      insert_hydration_dev(target, if_block_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (
        /*scene*/
        ctx2[0]
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty[0] & /*scene*/
          1) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block5(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if (if_block)
        if_block.d(detaching);
      if (detaching)
        detach_dev(if_block_anchor);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment35.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance34($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("GLTF", slots, ["default"]);
  let { position = void 0 } = $$props;
  let { scale = void 0 } = $$props;
  let { rotation = void 0 } = $$props;
  let { viewportAware = false } = $$props;
  let { inViewport = false } = $$props;
  let { castShadow = void 0 } = $$props;
  let { receiveShadow = void 0 } = $$props;
  let { frustumCulled = void 0 } = $$props;
  let { renderOrder = void 0 } = $$props;
  let { visible = void 0 } = $$props;
  let { lookAt = void 0 } = $$props;
  let { url } = $$props;
  let { dracoDecoderPath = void 0 } = $$props;
  let { ktxTranscoderPath = void 0 } = $$props;
  let { ignorePointer = false } = $$props;
  let { interactive = false } = $$props;
  const { invalidate } = useThrelte();
  const dispatch = createEventDispatcher();
  let interactiveMeshes = [];
  let layerableObjects = [];
  let { gltf = void 0 } = $$props;
  let { scene = void 0 } = $$props;
  let { animations = void 0 } = $$props;
  let { asset = void 0 } = $$props;
  let { cameras = void 0 } = $$props;
  let { scenes = void 0 } = $$props;
  let { userData = void 0 } = $$props;
  let { parser = void 0 } = $$props;
  let { materials = void 0 } = $$props;
  let { nodes = void 0 } = $$props;
  const loader2 = useLoader(GLTFLoader, () => new GLTFLoader());
  if (dracoDecoderPath) {
    const dracoLoader = useLoader(DRACOLoader, () => new DRACOLoader().setDecoderPath(dracoDecoderPath));
    loader2.setDRACOLoader(dracoLoader);
  }
  const { renderer } = useThrelte();
  if (renderer && ktxTranscoderPath) {
    const ktx2Loader = useLoader(KTX2Loader, () => new KTX2Loader().setTranscoderPath(ktxTranscoderPath).detectSupport(renderer));
    loader2.setKTX2Loader(ktx2Loader);
  }
  const disposeGltf = () => {
    if (gltf) {
      gltf.scene.traverse((object) => {
        if (object.type !== "Mesh")
          return;
        const m = object;
        m.geometry.dispose();
        if (Array.isArray(m.material)) {
          m.material.forEach((mm) => {
            if (mm.isMaterial) {
              disposeMaterial(mm);
            }
          });
        } else if (m.material.isMaterial) {
          disposeMaterial(m.material);
        }
      });
      $$invalidate(16, gltf = void 0);
      $$invalidate(0, scene = void 0);
      $$invalidate(17, animations = void 0);
      $$invalidate(18, asset = void 0);
      $$invalidate(19, cameras = void 0);
      $$invalidate(20, scenes = void 0);
      $$invalidate(21, userData = void 0);
      $$invalidate(22, parser = void 0);
      $$invalidate(24, nodes = void 0);
      $$invalidate(23, materials = void 0);
      interactiveMeshes.splice(0, interactiveMeshes.length);
      $$invalidate(14, interactiveMeshes);
      layerableObjects.splice(0, layerableObjects.length);
      $$invalidate(15, layerableObjects);
      invalidate("GLTF: model disposed");
      dispatch("unload");
    }
  };
  const disposeMaterial = (material) => {
    material.dispose();
    Object.values(material).forEach((value) => {
      try {
        if (value instanceof Texture) {
          value.dispose();
        }
      } catch (error) {
        console.warn("<GLTF>: Unable to dispose texture.");
      }
    });
  };
  const onLoad = (data) => {
    disposeGltf();
    $$invalidate(16, gltf = data);
    $$invalidate(0, scene = gltf.scene);
    $$invalidate(17, animations = gltf.animations);
    $$invalidate(18, asset = gltf.asset);
    $$invalidate(19, cameras = gltf.cameras);
    $$invalidate(20, scenes = gltf.scenes);
    $$invalidate(21, userData = gltf.userData);
    $$invalidate(22, parser = gltf.parser);
    const { materials: m, nodes: n2 } = buildSceneGraph(data.scene);
    $$invalidate(23, materials = m);
    $$invalidate(24, nodes = n2);
    scene.traverse((object) => {
      layerableObjects.push(object);
      if (object.type === "Mesh" || object.type === "SkinnedMesh") {
        const mesh = object;
        interactiveMeshes.push(mesh);
      }
    });
    $$invalidate(14, interactiveMeshes);
    $$invalidate(15, layerableObjects);
    invalidate("GLTF: model loaded");
    dispatch("load", gltf);
  };
  const onError = (e) => {
    console.error(`Error loading GLTF: ${e.message}`);
    disposeGltf();
    dispatch("error", e.message);
  };
  const objIsMesh = (obj) => {
    return "isMesh" in obj && obj.isMesh;
  };
  $$self.$$.on_mount.push(function() {
    if (url === void 0 && !("url" in $$props || $$self.$$.bound[$$self.$$.props["url"]])) {
      console_14.warn("<GLTF> was created without expected prop 'url'");
    }
  });
  const writable_props = [
    "position",
    "scale",
    "rotation",
    "viewportAware",
    "inViewport",
    "castShadow",
    "receiveShadow",
    "frustumCulled",
    "renderOrder",
    "visible",
    "lookAt",
    "url",
    "dracoDecoderPath",
    "ktxTranscoderPath",
    "ignorePointer",
    "interactive",
    "gltf",
    "scene",
    "animations",
    "asset",
    "cameras",
    "scenes",
    "userData",
    "parser",
    "materials",
    "nodes"
  ];
  Object_12.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console_14.warn(`<GLTF> was created with unknown prop '${key}'`);
  });
  function object3dinstance_inViewport_binding(value) {
    inViewport = value;
    $$invalidate(1, inViewport);
  }
  function viewportenter_handler(event) {
    bubble.call(this, $$self, event);
  }
  function viewportleave_handler(event) {
    bubble.call(this, $$self, event);
  }
  function click_handler(event) {
    bubble.call(this, $$self, event);
  }
  function contextmenu_handler(event) {
    bubble.call(this, $$self, event);
  }
  function pointerup_handler(event) {
    bubble.call(this, $$self, event);
  }
  function pointerdown_handler(event) {
    bubble.call(this, $$self, event);
  }
  function pointerenter_handler(event) {
    bubble.call(this, $$self, event);
  }
  function pointerleave_handler(event) {
    bubble.call(this, $$self, event);
  }
  function pointermove_handler(event) {
    bubble.call(this, $$self, event);
  }
  $$self.$$set = ($$props2) => {
    if ("position" in $$props2)
      $$invalidate(2, position = $$props2.position);
    if ("scale" in $$props2)
      $$invalidate(3, scale = $$props2.scale);
    if ("rotation" in $$props2)
      $$invalidate(4, rotation = $$props2.rotation);
    if ("viewportAware" in $$props2)
      $$invalidate(5, viewportAware = $$props2.viewportAware);
    if ("inViewport" in $$props2)
      $$invalidate(1, inViewport = $$props2.inViewport);
    if ("castShadow" in $$props2)
      $$invalidate(6, castShadow = $$props2.castShadow);
    if ("receiveShadow" in $$props2)
      $$invalidate(7, receiveShadow = $$props2.receiveShadow);
    if ("frustumCulled" in $$props2)
      $$invalidate(8, frustumCulled = $$props2.frustumCulled);
    if ("renderOrder" in $$props2)
      $$invalidate(9, renderOrder = $$props2.renderOrder);
    if ("visible" in $$props2)
      $$invalidate(10, visible = $$props2.visible);
    if ("lookAt" in $$props2)
      $$invalidate(11, lookAt = $$props2.lookAt);
    if ("url" in $$props2)
      $$invalidate(25, url = $$props2.url);
    if ("dracoDecoderPath" in $$props2)
      $$invalidate(26, dracoDecoderPath = $$props2.dracoDecoderPath);
    if ("ktxTranscoderPath" in $$props2)
      $$invalidate(27, ktxTranscoderPath = $$props2.ktxTranscoderPath);
    if ("ignorePointer" in $$props2)
      $$invalidate(12, ignorePointer = $$props2.ignorePointer);
    if ("interactive" in $$props2)
      $$invalidate(13, interactive = $$props2.interactive);
    if ("gltf" in $$props2)
      $$invalidate(16, gltf = $$props2.gltf);
    if ("scene" in $$props2)
      $$invalidate(0, scene = $$props2.scene);
    if ("animations" in $$props2)
      $$invalidate(17, animations = $$props2.animations);
    if ("asset" in $$props2)
      $$invalidate(18, asset = $$props2.asset);
    if ("cameras" in $$props2)
      $$invalidate(19, cameras = $$props2.cameras);
    if ("scenes" in $$props2)
      $$invalidate(20, scenes = $$props2.scenes);
    if ("userData" in $$props2)
      $$invalidate(21, userData = $$props2.userData);
    if ("parser" in $$props2)
      $$invalidate(22, parser = $$props2.parser);
    if ("materials" in $$props2)
      $$invalidate(23, materials = $$props2.materials);
    if ("nodes" in $$props2)
      $$invalidate(24, nodes = $$props2.nodes);
    if ("$$scope" in $$props2)
      $$invalidate(39, $$scope = $$props2.$$scope);
  };
  $$self.$capture_state = () => ({
    createEventDispatcher,
    Mesh,
    Texture,
    DRACOLoader,
    GLTFLoader,
    KTX2Loader,
    useLoader,
    useThrelte,
    Object3DInstance: Object3DInstance_default,
    InteractiveObject: InteractiveObject_default,
    LayerableObject: LayerableObject_default,
    buildSceneGraph,
    position,
    scale,
    rotation,
    viewportAware,
    inViewport,
    castShadow,
    receiveShadow,
    frustumCulled,
    renderOrder,
    visible,
    lookAt,
    url,
    dracoDecoderPath,
    ktxTranscoderPath,
    ignorePointer,
    interactive,
    invalidate,
    dispatch,
    interactiveMeshes,
    layerableObjects,
    gltf,
    scene,
    animations,
    asset,
    cameras,
    scenes,
    userData,
    parser,
    materials,
    nodes,
    loader: loader2,
    renderer,
    disposeGltf,
    disposeMaterial,
    onLoad,
    onError,
    objIsMesh
  });
  $$self.$inject_state = ($$props2) => {
    if ("position" in $$props2)
      $$invalidate(2, position = $$props2.position);
    if ("scale" in $$props2)
      $$invalidate(3, scale = $$props2.scale);
    if ("rotation" in $$props2)
      $$invalidate(4, rotation = $$props2.rotation);
    if ("viewportAware" in $$props2)
      $$invalidate(5, viewportAware = $$props2.viewportAware);
    if ("inViewport" in $$props2)
      $$invalidate(1, inViewport = $$props2.inViewport);
    if ("castShadow" in $$props2)
      $$invalidate(6, castShadow = $$props2.castShadow);
    if ("receiveShadow" in $$props2)
      $$invalidate(7, receiveShadow = $$props2.receiveShadow);
    if ("frustumCulled" in $$props2)
      $$invalidate(8, frustumCulled = $$props2.frustumCulled);
    if ("renderOrder" in $$props2)
      $$invalidate(9, renderOrder = $$props2.renderOrder);
    if ("visible" in $$props2)
      $$invalidate(10, visible = $$props2.visible);
    if ("lookAt" in $$props2)
      $$invalidate(11, lookAt = $$props2.lookAt);
    if ("url" in $$props2)
      $$invalidate(25, url = $$props2.url);
    if ("dracoDecoderPath" in $$props2)
      $$invalidate(26, dracoDecoderPath = $$props2.dracoDecoderPath);
    if ("ktxTranscoderPath" in $$props2)
      $$invalidate(27, ktxTranscoderPath = $$props2.ktxTranscoderPath);
    if ("ignorePointer" in $$props2)
      $$invalidate(12, ignorePointer = $$props2.ignorePointer);
    if ("interactive" in $$props2)
      $$invalidate(13, interactive = $$props2.interactive);
    if ("interactiveMeshes" in $$props2)
      $$invalidate(14, interactiveMeshes = $$props2.interactiveMeshes);
    if ("layerableObjects" in $$props2)
      $$invalidate(15, layerableObjects = $$props2.layerableObjects);
    if ("gltf" in $$props2)
      $$invalidate(16, gltf = $$props2.gltf);
    if ("scene" in $$props2)
      $$invalidate(0, scene = $$props2.scene);
    if ("animations" in $$props2)
      $$invalidate(17, animations = $$props2.animations);
    if ("asset" in $$props2)
      $$invalidate(18, asset = $$props2.asset);
    if ("cameras" in $$props2)
      $$invalidate(19, cameras = $$props2.cameras);
    if ("scenes" in $$props2)
      $$invalidate(20, scenes = $$props2.scenes);
    if ("userData" in $$props2)
      $$invalidate(21, userData = $$props2.userData);
    if ("parser" in $$props2)
      $$invalidate(22, parser = $$props2.parser);
    if ("materials" in $$props2)
      $$invalidate(23, materials = $$props2.materials);
    if ("nodes" in $$props2)
      $$invalidate(24, nodes = $$props2.nodes);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty[0] & /*url*/
    33554432) {
      $:
        loader2.load(url, onLoad, void 0, onError);
    }
    if ($$self.$$.dirty[0] & /*scene, castShadow, receiveShadow, frustumCulled, renderOrder*/
    961) {
      $: {
        if (scene) {
          scene.traverse((obj) => {
            if (castShadow !== void 0)
              obj.castShadow = castShadow;
            if (receiveShadow !== void 0)
              obj.receiveShadow = receiveShadow;
            if (frustumCulled !== void 0)
              obj.frustumCulled = frustumCulled;
            if (renderOrder !== void 0)
              obj.renderOrder = renderOrder;
          });
        }
      }
    }
  };
  return [
    scene,
    inViewport,
    position,
    scale,
    rotation,
    viewportAware,
    castShadow,
    receiveShadow,
    frustumCulled,
    renderOrder,
    visible,
    lookAt,
    ignorePointer,
    interactive,
    interactiveMeshes,
    layerableObjects,
    gltf,
    animations,
    asset,
    cameras,
    scenes,
    userData,
    parser,
    materials,
    nodes,
    url,
    dracoDecoderPath,
    ktxTranscoderPath,
    slots,
    object3dinstance_inViewport_binding,
    viewportenter_handler,
    viewportleave_handler,
    click_handler,
    contextmenu_handler,
    pointerup_handler,
    pointerdown_handler,
    pointerenter_handler,
    pointerleave_handler,
    pointermove_handler,
    $$scope
  ];
}
var GLTF = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(
      this,
      options,
      instance34,
      create_fragment35,
      safe_not_equal,
      {
        position: 2,
        scale: 3,
        rotation: 4,
        viewportAware: 5,
        inViewport: 1,
        castShadow: 6,
        receiveShadow: 7,
        frustumCulled: 8,
        renderOrder: 9,
        visible: 10,
        lookAt: 11,
        url: 25,
        dracoDecoderPath: 26,
        ktxTranscoderPath: 27,
        ignorePointer: 12,
        interactive: 13,
        gltf: 16,
        scene: 0,
        animations: 17,
        asset: 18,
        cameras: 19,
        scenes: 20,
        userData: 21,
        parser: 22,
        materials: 23,
        nodes: 24
      },
      null,
      [-1, -1]
    );
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "GLTF",
      options,
      id: create_fragment35.name
    });
  }
  get position() {
    throw new Error("<GLTF>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set position(value) {
    throw new Error("<GLTF>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get scale() {
    throw new Error("<GLTF>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set scale(value) {
    throw new Error("<GLTF>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get rotation() {
    throw new Error("<GLTF>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set rotation(value) {
    throw new Error("<GLTF>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get viewportAware() {
    throw new Error("<GLTF>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set viewportAware(value) {
    throw new Error("<GLTF>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get inViewport() {
    throw new Error("<GLTF>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set inViewport(value) {
    throw new Error("<GLTF>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get castShadow() {
    throw new Error("<GLTF>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set castShadow(value) {
    throw new Error("<GLTF>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get receiveShadow() {
    throw new Error("<GLTF>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set receiveShadow(value) {
    throw new Error("<GLTF>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get frustumCulled() {
    throw new Error("<GLTF>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set frustumCulled(value) {
    throw new Error("<GLTF>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get renderOrder() {
    throw new Error("<GLTF>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set renderOrder(value) {
    throw new Error("<GLTF>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get visible() {
    throw new Error("<GLTF>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set visible(value) {
    throw new Error("<GLTF>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get lookAt() {
    throw new Error("<GLTF>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set lookAt(value) {
    throw new Error("<GLTF>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get url() {
    throw new Error("<GLTF>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set url(value) {
    throw new Error("<GLTF>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get dracoDecoderPath() {
    throw new Error("<GLTF>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set dracoDecoderPath(value) {
    throw new Error("<GLTF>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get ktxTranscoderPath() {
    throw new Error("<GLTF>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set ktxTranscoderPath(value) {
    throw new Error("<GLTF>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get ignorePointer() {
    throw new Error("<GLTF>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set ignorePointer(value) {
    throw new Error("<GLTF>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get interactive() {
    throw new Error("<GLTF>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set interactive(value) {
    throw new Error("<GLTF>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get gltf() {
    throw new Error("<GLTF>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set gltf(value) {
    throw new Error("<GLTF>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get scene() {
    throw new Error("<GLTF>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set scene(value) {
    throw new Error("<GLTF>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get animations() {
    throw new Error("<GLTF>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set animations(value) {
    throw new Error("<GLTF>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get asset() {
    throw new Error("<GLTF>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set asset(value) {
    throw new Error("<GLTF>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get cameras() {
    throw new Error("<GLTF>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set cameras(value) {
    throw new Error("<GLTF>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get scenes() {
    throw new Error("<GLTF>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set scenes(value) {
    throw new Error("<GLTF>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get userData() {
    throw new Error("<GLTF>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set userData(value) {
    throw new Error("<GLTF>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get parser() {
    throw new Error("<GLTF>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set parser(value) {
    throw new Error("<GLTF>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get materials() {
    throw new Error("<GLTF>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set materials(value) {
    throw new Error("<GLTF>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get nodes() {
    throw new Error("<GLTF>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set nodes(value) {
    throw new Error("<GLTF>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var GLTF_default = GLTF;

// node_modules/threlte/instances/LineInstance.svelte
function create_default_slot22(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[14].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[25],
    null
  );
  const block = {
    c: function create() {
      if (default_slot)
        default_slot.c();
    },
    l: function claim(nodes) {
      if (default_slot)
        default_slot.l(nodes);
    },
    m: function mount(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        33554432)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[25],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[25]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[25],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot22.name,
    type: "slot",
    source: "(19:0) <Object3DInstance   object={line}   {lookAt}   {position}   {scale}   {rotation}   {castShadow}   {receiveShadow}   {frustumCulled}   {renderOrder}   {visible}   {viewportAware}   on:viewportenter   on:viewportleave   bind:inViewport >",
    ctx
  });
  return block;
}
function create_fragment36(ctx) {
  let object3dinstance;
  let updating_inViewport;
  let t2;
  let interactiveobject;
  let current;
  function object3dinstance_inViewport_binding(value) {
    ctx[15](value);
  }
  let object3dinstance_props = {
    object: (
      /*line*/
      ctx[1]
    ),
    lookAt: (
      /*lookAt*/
      ctx[5]
    ),
    position: (
      /*position*/
      ctx[2]
    ),
    scale: (
      /*scale*/
      ctx[3]
    ),
    rotation: (
      /*rotation*/
      ctx[4]
    ),
    castShadow: (
      /*castShadow*/
      ctx[7]
    ),
    receiveShadow: (
      /*receiveShadow*/
      ctx[8]
    ),
    frustumCulled: (
      /*frustumCulled*/
      ctx[9]
    ),
    renderOrder: (
      /*renderOrder*/
      ctx[10]
    ),
    visible: (
      /*visible*/
      ctx[11]
    ),
    viewportAware: (
      /*viewportAware*/
      ctx[6]
    ),
    $$slots: { default: [create_default_slot22] },
    $$scope: { ctx }
  };
  if (
    /*inViewport*/
    ctx[0] !== void 0
  ) {
    object3dinstance_props.inViewport = /*inViewport*/
    ctx[0];
  }
  object3dinstance = new Object3DInstance_default({
    props: object3dinstance_props,
    $$inline: true
  });
  binding_callbacks.push(() => bind(object3dinstance, "inViewport", object3dinstance_inViewport_binding));
  object3dinstance.$on(
    "viewportenter",
    /*viewportenter_handler*/
    ctx[16]
  );
  object3dinstance.$on(
    "viewportleave",
    /*viewportleave_handler*/
    ctx[17]
  );
  interactiveobject = new InteractiveObject_default({
    props: {
      object: (
        /*line*/
        ctx[1]
      ),
      interactive: (
        /*interactive*/
        ctx[12]
      ),
      ignorePointer: (
        /*ignorePointer*/
        ctx[13]
      )
    },
    $$inline: true
  });
  interactiveobject.$on(
    "click",
    /*click_handler*/
    ctx[18]
  );
  interactiveobject.$on(
    "contextmenu",
    /*contextmenu_handler*/
    ctx[19]
  );
  interactiveobject.$on(
    "pointerup",
    /*pointerup_handler*/
    ctx[20]
  );
  interactiveobject.$on(
    "pointerdown",
    /*pointerdown_handler*/
    ctx[21]
  );
  interactiveobject.$on(
    "pointerenter",
    /*pointerenter_handler*/
    ctx[22]
  );
  interactiveobject.$on(
    "pointerleave",
    /*pointerleave_handler*/
    ctx[23]
  );
  interactiveobject.$on(
    "pointermove",
    /*pointermove_handler*/
    ctx[24]
  );
  const block = {
    c: function create() {
      create_component(object3dinstance.$$.fragment);
      t2 = space();
      create_component(interactiveobject.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(object3dinstance.$$.fragment, nodes);
      t2 = claim_space(nodes);
      claim_component(interactiveobject.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(object3dinstance, target, anchor);
      insert_hydration_dev(target, t2, anchor);
      mount_component(interactiveobject, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const object3dinstance_changes = {};
      if (dirty & /*line*/
      2)
        object3dinstance_changes.object = /*line*/
        ctx2[1];
      if (dirty & /*lookAt*/
      32)
        object3dinstance_changes.lookAt = /*lookAt*/
        ctx2[5];
      if (dirty & /*position*/
      4)
        object3dinstance_changes.position = /*position*/
        ctx2[2];
      if (dirty & /*scale*/
      8)
        object3dinstance_changes.scale = /*scale*/
        ctx2[3];
      if (dirty & /*rotation*/
      16)
        object3dinstance_changes.rotation = /*rotation*/
        ctx2[4];
      if (dirty & /*castShadow*/
      128)
        object3dinstance_changes.castShadow = /*castShadow*/
        ctx2[7];
      if (dirty & /*receiveShadow*/
      256)
        object3dinstance_changes.receiveShadow = /*receiveShadow*/
        ctx2[8];
      if (dirty & /*frustumCulled*/
      512)
        object3dinstance_changes.frustumCulled = /*frustumCulled*/
        ctx2[9];
      if (dirty & /*renderOrder*/
      1024)
        object3dinstance_changes.renderOrder = /*renderOrder*/
        ctx2[10];
      if (dirty & /*visible*/
      2048)
        object3dinstance_changes.visible = /*visible*/
        ctx2[11];
      if (dirty & /*viewportAware*/
      64)
        object3dinstance_changes.viewportAware = /*viewportAware*/
        ctx2[6];
      if (dirty & /*$$scope*/
      33554432) {
        object3dinstance_changes.$$scope = { dirty, ctx: ctx2 };
      }
      if (!updating_inViewport && dirty & /*inViewport*/
      1) {
        updating_inViewport = true;
        object3dinstance_changes.inViewport = /*inViewport*/
        ctx2[0];
        add_flush_callback(() => updating_inViewport = false);
      }
      object3dinstance.$set(object3dinstance_changes);
      const interactiveobject_changes = {};
      if (dirty & /*line*/
      2)
        interactiveobject_changes.object = /*line*/
        ctx2[1];
      if (dirty & /*interactive*/
      4096)
        interactiveobject_changes.interactive = /*interactive*/
        ctx2[12];
      if (dirty & /*ignorePointer*/
      8192)
        interactiveobject_changes.ignorePointer = /*ignorePointer*/
        ctx2[13];
      interactiveobject.$set(interactiveobject_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(object3dinstance.$$.fragment, local);
      transition_in(interactiveobject.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(object3dinstance.$$.fragment, local);
      transition_out(interactiveobject.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(object3dinstance, detaching);
      if (detaching)
        detach_dev(t2);
      destroy_component(interactiveobject, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment36.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance35($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("LineInstance", slots, ["default"]);
  let { line } = $$props;
  let { position = void 0 } = $$props;
  let { scale = void 0 } = $$props;
  let { rotation = void 0 } = $$props;
  let { lookAt = void 0 } = $$props;
  let { viewportAware = false } = $$props;
  let { inViewport = false } = $$props;
  let { castShadow = void 0 } = $$props;
  let { receiveShadow = void 0 } = $$props;
  let { frustumCulled = void 0 } = $$props;
  let { renderOrder = void 0 } = $$props;
  let { visible = void 0 } = $$props;
  let { interactive = false } = $$props;
  let { ignorePointer = false } = $$props;
  $$self.$$.on_mount.push(function() {
    if (line === void 0 && !("line" in $$props || $$self.$$.bound[$$self.$$.props["line"]])) {
      console.warn("<LineInstance> was created without expected prop 'line'");
    }
  });
  const writable_props = [
    "line",
    "position",
    "scale",
    "rotation",
    "lookAt",
    "viewportAware",
    "inViewport",
    "castShadow",
    "receiveShadow",
    "frustumCulled",
    "renderOrder",
    "visible",
    "interactive",
    "ignorePointer"
  ];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<LineInstance> was created with unknown prop '${key}'`);
  });
  function object3dinstance_inViewport_binding(value) {
    inViewport = value;
    $$invalidate(0, inViewport);
  }
  function viewportenter_handler(event) {
    bubble.call(this, $$self, event);
  }
  function viewportleave_handler(event) {
    bubble.call(this, $$self, event);
  }
  function click_handler(event) {
    bubble.call(this, $$self, event);
  }
  function contextmenu_handler(event) {
    bubble.call(this, $$self, event);
  }
  function pointerup_handler(event) {
    bubble.call(this, $$self, event);
  }
  function pointerdown_handler(event) {
    bubble.call(this, $$self, event);
  }
  function pointerenter_handler(event) {
    bubble.call(this, $$self, event);
  }
  function pointerleave_handler(event) {
    bubble.call(this, $$self, event);
  }
  function pointermove_handler(event) {
    bubble.call(this, $$self, event);
  }
  $$self.$$set = ($$props2) => {
    if ("line" in $$props2)
      $$invalidate(1, line = $$props2.line);
    if ("position" in $$props2)
      $$invalidate(2, position = $$props2.position);
    if ("scale" in $$props2)
      $$invalidate(3, scale = $$props2.scale);
    if ("rotation" in $$props2)
      $$invalidate(4, rotation = $$props2.rotation);
    if ("lookAt" in $$props2)
      $$invalidate(5, lookAt = $$props2.lookAt);
    if ("viewportAware" in $$props2)
      $$invalidate(6, viewportAware = $$props2.viewportAware);
    if ("inViewport" in $$props2)
      $$invalidate(0, inViewport = $$props2.inViewport);
    if ("castShadow" in $$props2)
      $$invalidate(7, castShadow = $$props2.castShadow);
    if ("receiveShadow" in $$props2)
      $$invalidate(8, receiveShadow = $$props2.receiveShadow);
    if ("frustumCulled" in $$props2)
      $$invalidate(9, frustumCulled = $$props2.frustumCulled);
    if ("renderOrder" in $$props2)
      $$invalidate(10, renderOrder = $$props2.renderOrder);
    if ("visible" in $$props2)
      $$invalidate(11, visible = $$props2.visible);
    if ("interactive" in $$props2)
      $$invalidate(12, interactive = $$props2.interactive);
    if ("ignorePointer" in $$props2)
      $$invalidate(13, ignorePointer = $$props2.ignorePointer);
    if ("$$scope" in $$props2)
      $$invalidate(25, $$scope = $$props2.$$scope);
  };
  $$self.$capture_state = () => ({
    InteractiveObject: InteractiveObject_default,
    Object3DInstance: Object3DInstance_default,
    line,
    position,
    scale,
    rotation,
    lookAt,
    viewportAware,
    inViewport,
    castShadow,
    receiveShadow,
    frustumCulled,
    renderOrder,
    visible,
    interactive,
    ignorePointer
  });
  $$self.$inject_state = ($$props2) => {
    if ("line" in $$props2)
      $$invalidate(1, line = $$props2.line);
    if ("position" in $$props2)
      $$invalidate(2, position = $$props2.position);
    if ("scale" in $$props2)
      $$invalidate(3, scale = $$props2.scale);
    if ("rotation" in $$props2)
      $$invalidate(4, rotation = $$props2.rotation);
    if ("lookAt" in $$props2)
      $$invalidate(5, lookAt = $$props2.lookAt);
    if ("viewportAware" in $$props2)
      $$invalidate(6, viewportAware = $$props2.viewportAware);
    if ("inViewport" in $$props2)
      $$invalidate(0, inViewport = $$props2.inViewport);
    if ("castShadow" in $$props2)
      $$invalidate(7, castShadow = $$props2.castShadow);
    if ("receiveShadow" in $$props2)
      $$invalidate(8, receiveShadow = $$props2.receiveShadow);
    if ("frustumCulled" in $$props2)
      $$invalidate(9, frustumCulled = $$props2.frustumCulled);
    if ("renderOrder" in $$props2)
      $$invalidate(10, renderOrder = $$props2.renderOrder);
    if ("visible" in $$props2)
      $$invalidate(11, visible = $$props2.visible);
    if ("interactive" in $$props2)
      $$invalidate(12, interactive = $$props2.interactive);
    if ("ignorePointer" in $$props2)
      $$invalidate(13, ignorePointer = $$props2.ignorePointer);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [
    inViewport,
    line,
    position,
    scale,
    rotation,
    lookAt,
    viewportAware,
    castShadow,
    receiveShadow,
    frustumCulled,
    renderOrder,
    visible,
    interactive,
    ignorePointer,
    slots,
    object3dinstance_inViewport_binding,
    viewportenter_handler,
    viewportleave_handler,
    click_handler,
    contextmenu_handler,
    pointerup_handler,
    pointerdown_handler,
    pointerenter_handler,
    pointerleave_handler,
    pointermove_handler,
    $$scope
  ];
}
var LineInstance = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance35, create_fragment36, safe_not_equal, {
      line: 1,
      position: 2,
      scale: 3,
      rotation: 4,
      lookAt: 5,
      viewportAware: 6,
      inViewport: 0,
      castShadow: 7,
      receiveShadow: 8,
      frustumCulled: 9,
      renderOrder: 10,
      visible: 11,
      interactive: 12,
      ignorePointer: 13
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "LineInstance",
      options,
      id: create_fragment36.name
    });
  }
  get line() {
    throw new Error("<LineInstance>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set line(value) {
    throw new Error("<LineInstance>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get position() {
    throw new Error("<LineInstance>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set position(value) {
    throw new Error("<LineInstance>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get scale() {
    throw new Error("<LineInstance>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set scale(value) {
    throw new Error("<LineInstance>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get rotation() {
    throw new Error("<LineInstance>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set rotation(value) {
    throw new Error("<LineInstance>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get lookAt() {
    throw new Error("<LineInstance>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set lookAt(value) {
    throw new Error("<LineInstance>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get viewportAware() {
    throw new Error("<LineInstance>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set viewportAware(value) {
    throw new Error("<LineInstance>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get inViewport() {
    throw new Error("<LineInstance>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set inViewport(value) {
    throw new Error("<LineInstance>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get castShadow() {
    throw new Error("<LineInstance>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set castShadow(value) {
    throw new Error("<LineInstance>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get receiveShadow() {
    throw new Error("<LineInstance>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set receiveShadow(value) {
    throw new Error("<LineInstance>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get frustumCulled() {
    throw new Error("<LineInstance>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set frustumCulled(value) {
    throw new Error("<LineInstance>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get renderOrder() {
    throw new Error("<LineInstance>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set renderOrder(value) {
    throw new Error("<LineInstance>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get visible() {
    throw new Error("<LineInstance>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set visible(value) {
    throw new Error("<LineInstance>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get interactive() {
    throw new Error("<LineInstance>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set interactive(value) {
    throw new Error("<LineInstance>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get ignorePointer() {
    throw new Error("<LineInstance>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set ignorePointer(value) {
    throw new Error("<LineInstance>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var LineInstance_default = LineInstance;

// node_modules/threlte/objects/Line.svelte
function create_default_slot23(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[20].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[31],
    null
  );
  const block = {
    c: function create() {
      if (default_slot)
        default_slot.c();
    },
    l: function claim(nodes) {
      if (default_slot)
        default_slot.l(nodes);
    },
    m: function mount(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty[1] & /*$$scope*/
        1)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[31],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[31]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[31],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot23.name,
    type: "slot",
    source: "(73:0) <LineInstance   {line}   {position}   {scale}   {rotation}   {lookAt}   {castShadow}   {receiveShadow}   {frustumCulled}   {renderOrder}   {visible}   {interactive}   {ignorePointer}   on:click   on:contextmenu   on:pointerup   on:pointerdown   on:pointerenter   on:pointerleave   on:pointermove   {viewportAware}   bind:inViewport   on:viewportenter   on:viewportleave >",
    ctx
  });
  return block;
}
function create_fragment37(ctx) {
  let lineinstance;
  let updating_inViewport;
  let current;
  function lineinstance_inViewport_binding(value) {
    ctx[21](value);
  }
  let lineinstance_props = {
    line: (
      /*line*/
      ctx[13]
    ),
    position: (
      /*position*/
      ctx[1]
    ),
    scale: (
      /*scale*/
      ctx[2]
    ),
    rotation: (
      /*rotation*/
      ctx[3]
    ),
    lookAt: (
      /*lookAt*/
      ctx[12]
    ),
    castShadow: (
      /*castShadow*/
      ctx[5]
    ),
    receiveShadow: (
      /*receiveShadow*/
      ctx[6]
    ),
    frustumCulled: (
      /*frustumCulled*/
      ctx[7]
    ),
    renderOrder: (
      /*renderOrder*/
      ctx[8]
    ),
    visible: (
      /*visible*/
      ctx[9]
    ),
    interactive: (
      /*interactive*/
      ctx[10]
    ),
    ignorePointer: (
      /*ignorePointer*/
      ctx[11]
    ),
    viewportAware: (
      /*viewportAware*/
      ctx[4]
    ),
    $$slots: { default: [create_default_slot23] },
    $$scope: { ctx }
  };
  if (
    /*inViewport*/
    ctx[0] !== void 0
  ) {
    lineinstance_props.inViewport = /*inViewport*/
    ctx[0];
  }
  lineinstance = new LineInstance_default({
    props: lineinstance_props,
    $$inline: true
  });
  binding_callbacks.push(() => bind(lineinstance, "inViewport", lineinstance_inViewport_binding));
  lineinstance.$on(
    "click",
    /*click_handler*/
    ctx[22]
  );
  lineinstance.$on(
    "contextmenu",
    /*contextmenu_handler*/
    ctx[23]
  );
  lineinstance.$on(
    "pointerup",
    /*pointerup_handler*/
    ctx[24]
  );
  lineinstance.$on(
    "pointerdown",
    /*pointerdown_handler*/
    ctx[25]
  );
  lineinstance.$on(
    "pointerenter",
    /*pointerenter_handler*/
    ctx[26]
  );
  lineinstance.$on(
    "pointerleave",
    /*pointerleave_handler*/
    ctx[27]
  );
  lineinstance.$on(
    "pointermove",
    /*pointermove_handler*/
    ctx[28]
  );
  lineinstance.$on(
    "viewportenter",
    /*viewportenter_handler*/
    ctx[29]
  );
  lineinstance.$on(
    "viewportleave",
    /*viewportleave_handler*/
    ctx[30]
  );
  const block = {
    c: function create() {
      create_component(lineinstance.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(lineinstance.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(lineinstance, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const lineinstance_changes = {};
      if (dirty[0] & /*position*/
      2)
        lineinstance_changes.position = /*position*/
        ctx2[1];
      if (dirty[0] & /*scale*/
      4)
        lineinstance_changes.scale = /*scale*/
        ctx2[2];
      if (dirty[0] & /*rotation*/
      8)
        lineinstance_changes.rotation = /*rotation*/
        ctx2[3];
      if (dirty[0] & /*lookAt*/
      4096)
        lineinstance_changes.lookAt = /*lookAt*/
        ctx2[12];
      if (dirty[0] & /*castShadow*/
      32)
        lineinstance_changes.castShadow = /*castShadow*/
        ctx2[5];
      if (dirty[0] & /*receiveShadow*/
      64)
        lineinstance_changes.receiveShadow = /*receiveShadow*/
        ctx2[6];
      if (dirty[0] & /*frustumCulled*/
      128)
        lineinstance_changes.frustumCulled = /*frustumCulled*/
        ctx2[7];
      if (dirty[0] & /*renderOrder*/
      256)
        lineinstance_changes.renderOrder = /*renderOrder*/
        ctx2[8];
      if (dirty[0] & /*visible*/
      512)
        lineinstance_changes.visible = /*visible*/
        ctx2[9];
      if (dirty[0] & /*interactive*/
      1024)
        lineinstance_changes.interactive = /*interactive*/
        ctx2[10];
      if (dirty[0] & /*ignorePointer*/
      2048)
        lineinstance_changes.ignorePointer = /*ignorePointer*/
        ctx2[11];
      if (dirty[0] & /*viewportAware*/
      16)
        lineinstance_changes.viewportAware = /*viewportAware*/
        ctx2[4];
      if (dirty[1] & /*$$scope*/
      1) {
        lineinstance_changes.$$scope = { dirty, ctx: ctx2 };
      }
      if (!updating_inViewport && dirty[0] & /*inViewport*/
      1) {
        updating_inViewport = true;
        lineinstance_changes.inViewport = /*inViewport*/
        ctx2[0];
        add_flush_callback(() => updating_inViewport = false);
      }
      lineinstance.$set(lineinstance_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(lineinstance.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(lineinstance.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(lineinstance, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment37.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance36($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Line", slots, ["default"]);
  let { position = void 0 } = $$props;
  let { scale = void 0 } = $$props;
  let { rotation = void 0 } = $$props;
  let { viewportAware = false } = $$props;
  let { inViewport = false } = $$props;
  let { castShadow = void 0 } = $$props;
  let { receiveShadow = void 0 } = $$props;
  let { frustumCulled = void 0 } = $$props;
  let { renderOrder = void 0 } = $$props;
  let { visible = void 0 } = $$props;
  let { interactive = false } = $$props;
  let { ignorePointer = false } = $$props;
  let { lookAt = void 0 } = $$props;
  let { geometry = void 0 } = $$props;
  let { points = [] } = $$props;
  let { material } = $$props;
  let previousMaterial = material;
  let previousGeometry = geometry;
  let previousPoints = points;
  const tempGeometry = new BufferGeometry();
  const { invalidate } = useThrelte();
  const setGeometryFromPoints = () => {
    const v3Array = points.map((p2) => p2 instanceof Vector3 ? p2 : new Vector3().fromArray(p2));
    tempGeometry.setFromPoints(v3Array);
  };
  const usePoints = () => !geometry;
  const useGeometry = () => !!geometry;
  if (usePoints()) {
    setGeometryFromPoints();
  }
  const line = new Line(useGeometry() ? geometry : tempGeometry, material);
  const getLine = () => line;
  $$self.$$.on_mount.push(function() {
    if (material === void 0 && !("material" in $$props || $$self.$$.bound[$$self.$$.props["material"]])) {
      console.warn("<Line> was created without expected prop 'material'");
    }
  });
  const writable_props = [
    "position",
    "scale",
    "rotation",
    "viewportAware",
    "inViewport",
    "castShadow",
    "receiveShadow",
    "frustumCulled",
    "renderOrder",
    "visible",
    "interactive",
    "ignorePointer",
    "lookAt",
    "geometry",
    "points",
    "material"
  ];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<Line> was created with unknown prop '${key}'`);
  });
  function lineinstance_inViewport_binding(value) {
    inViewport = value;
    $$invalidate(0, inViewport);
  }
  function click_handler(event) {
    bubble.call(this, $$self, event);
  }
  function contextmenu_handler(event) {
    bubble.call(this, $$self, event);
  }
  function pointerup_handler(event) {
    bubble.call(this, $$self, event);
  }
  function pointerdown_handler(event) {
    bubble.call(this, $$self, event);
  }
  function pointerenter_handler(event) {
    bubble.call(this, $$self, event);
  }
  function pointerleave_handler(event) {
    bubble.call(this, $$self, event);
  }
  function pointermove_handler(event) {
    bubble.call(this, $$self, event);
  }
  function viewportenter_handler(event) {
    bubble.call(this, $$self, event);
  }
  function viewportleave_handler(event) {
    bubble.call(this, $$self, event);
  }
  $$self.$$set = ($$props2) => {
    if ("position" in $$props2)
      $$invalidate(1, position = $$props2.position);
    if ("scale" in $$props2)
      $$invalidate(2, scale = $$props2.scale);
    if ("rotation" in $$props2)
      $$invalidate(3, rotation = $$props2.rotation);
    if ("viewportAware" in $$props2)
      $$invalidate(4, viewportAware = $$props2.viewportAware);
    if ("inViewport" in $$props2)
      $$invalidate(0, inViewport = $$props2.inViewport);
    if ("castShadow" in $$props2)
      $$invalidate(5, castShadow = $$props2.castShadow);
    if ("receiveShadow" in $$props2)
      $$invalidate(6, receiveShadow = $$props2.receiveShadow);
    if ("frustumCulled" in $$props2)
      $$invalidate(7, frustumCulled = $$props2.frustumCulled);
    if ("renderOrder" in $$props2)
      $$invalidate(8, renderOrder = $$props2.renderOrder);
    if ("visible" in $$props2)
      $$invalidate(9, visible = $$props2.visible);
    if ("interactive" in $$props2)
      $$invalidate(10, interactive = $$props2.interactive);
    if ("ignorePointer" in $$props2)
      $$invalidate(11, ignorePointer = $$props2.ignorePointer);
    if ("lookAt" in $$props2)
      $$invalidate(12, lookAt = $$props2.lookAt);
    if ("geometry" in $$props2)
      $$invalidate(14, geometry = $$props2.geometry);
    if ("points" in $$props2)
      $$invalidate(15, points = $$props2.points);
    if ("material" in $$props2)
      $$invalidate(16, material = $$props2.material);
    if ("$$scope" in $$props2)
      $$invalidate(31, $$scope = $$props2.$$scope);
  };
  $$self.$capture_state = () => ({
    BufferGeometry,
    ThreeLine: Line,
    Vector3,
    useThrelte,
    LineInstance: LineInstance_default,
    position,
    scale,
    rotation,
    viewportAware,
    inViewport,
    castShadow,
    receiveShadow,
    frustumCulled,
    renderOrder,
    visible,
    interactive,
    ignorePointer,
    lookAt,
    geometry,
    points,
    material,
    previousMaterial,
    previousGeometry,
    previousPoints,
    tempGeometry,
    invalidate,
    setGeometryFromPoints,
    usePoints,
    useGeometry,
    line,
    getLine
  });
  $$self.$inject_state = ($$props2) => {
    if ("position" in $$props2)
      $$invalidate(1, position = $$props2.position);
    if ("scale" in $$props2)
      $$invalidate(2, scale = $$props2.scale);
    if ("rotation" in $$props2)
      $$invalidate(3, rotation = $$props2.rotation);
    if ("viewportAware" in $$props2)
      $$invalidate(4, viewportAware = $$props2.viewportAware);
    if ("inViewport" in $$props2)
      $$invalidate(0, inViewport = $$props2.inViewport);
    if ("castShadow" in $$props2)
      $$invalidate(5, castShadow = $$props2.castShadow);
    if ("receiveShadow" in $$props2)
      $$invalidate(6, receiveShadow = $$props2.receiveShadow);
    if ("frustumCulled" in $$props2)
      $$invalidate(7, frustumCulled = $$props2.frustumCulled);
    if ("renderOrder" in $$props2)
      $$invalidate(8, renderOrder = $$props2.renderOrder);
    if ("visible" in $$props2)
      $$invalidate(9, visible = $$props2.visible);
    if ("interactive" in $$props2)
      $$invalidate(10, interactive = $$props2.interactive);
    if ("ignorePointer" in $$props2)
      $$invalidate(11, ignorePointer = $$props2.ignorePointer);
    if ("lookAt" in $$props2)
      $$invalidate(12, lookAt = $$props2.lookAt);
    if ("geometry" in $$props2)
      $$invalidate(14, geometry = $$props2.geometry);
    if ("points" in $$props2)
      $$invalidate(15, points = $$props2.points);
    if ("material" in $$props2)
      $$invalidate(16, material = $$props2.material);
    if ("previousMaterial" in $$props2)
      $$invalidate(17, previousMaterial = $$props2.previousMaterial);
    if ("previousGeometry" in $$props2)
      $$invalidate(18, previousGeometry = $$props2.previousGeometry);
    if ("previousPoints" in $$props2)
      $$invalidate(19, previousPoints = $$props2.previousPoints);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty[0] & /*material, previousMaterial*/
    196608) {
      $: {
        if (material !== previousMaterial) {
          getLine().material = material;
          invalidate("Line: material changed");
        } else {
          invalidate("Line: material props changed");
        }
        $$invalidate(17, previousMaterial = material);
      }
    }
    if ($$self.$$.dirty[0] & /*geometry, previousGeometry*/
    278528) {
      $: {
        if (geometry !== previousGeometry) {
          if (useGeometry()) {
            getLine().geometry = geometry;
            invalidate("Line: geometry changed");
          }
        } else {
          if (useGeometry()) {
            invalidate("Line: geometry props changed");
          }
        }
        $$invalidate(18, previousGeometry = geometry);
      }
    }
    if ($$self.$$.dirty[0] & /*previousPoints, points*/
    557056) {
      $: {
        if (previousPoints !== points) {
          if (usePoints()) {
            setGeometryFromPoints();
            getLine().geometry = tempGeometry;
          }
          $$invalidate(19, previousPoints = points);
        }
      }
    }
  };
  return [
    inViewport,
    position,
    scale,
    rotation,
    viewportAware,
    castShadow,
    receiveShadow,
    frustumCulled,
    renderOrder,
    visible,
    interactive,
    ignorePointer,
    lookAt,
    line,
    geometry,
    points,
    material,
    previousMaterial,
    previousGeometry,
    previousPoints,
    slots,
    lineinstance_inViewport_binding,
    click_handler,
    contextmenu_handler,
    pointerup_handler,
    pointerdown_handler,
    pointerenter_handler,
    pointerleave_handler,
    pointermove_handler,
    viewportenter_handler,
    viewportleave_handler,
    $$scope
  ];
}
var Line2 = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(
      this,
      options,
      instance36,
      create_fragment37,
      safe_not_equal,
      {
        position: 1,
        scale: 2,
        rotation: 3,
        viewportAware: 4,
        inViewport: 0,
        castShadow: 5,
        receiveShadow: 6,
        frustumCulled: 7,
        renderOrder: 8,
        visible: 9,
        interactive: 10,
        ignorePointer: 11,
        lookAt: 12,
        geometry: 14,
        points: 15,
        material: 16,
        line: 13
      },
      null,
      [-1, -1]
    );
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Line",
      options,
      id: create_fragment37.name
    });
  }
  get position() {
    throw new Error("<Line>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set position(value) {
    throw new Error("<Line>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get scale() {
    throw new Error("<Line>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set scale(value) {
    throw new Error("<Line>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get rotation() {
    throw new Error("<Line>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set rotation(value) {
    throw new Error("<Line>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get viewportAware() {
    throw new Error("<Line>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set viewportAware(value) {
    throw new Error("<Line>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get inViewport() {
    throw new Error("<Line>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set inViewport(value) {
    throw new Error("<Line>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get castShadow() {
    throw new Error("<Line>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set castShadow(value) {
    throw new Error("<Line>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get receiveShadow() {
    throw new Error("<Line>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set receiveShadow(value) {
    throw new Error("<Line>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get frustumCulled() {
    throw new Error("<Line>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set frustumCulled(value) {
    throw new Error("<Line>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get renderOrder() {
    throw new Error("<Line>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set renderOrder(value) {
    throw new Error("<Line>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get visible() {
    throw new Error("<Line>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set visible(value) {
    throw new Error("<Line>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get interactive() {
    throw new Error("<Line>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set interactive(value) {
    throw new Error("<Line>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get ignorePointer() {
    throw new Error("<Line>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set ignorePointer(value) {
    throw new Error("<Line>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get lookAt() {
    throw new Error("<Line>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set lookAt(value) {
    throw new Error("<Line>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get geometry() {
    throw new Error("<Line>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set geometry(value) {
    throw new Error("<Line>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get points() {
    throw new Error("<Line>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set points(value) {
    throw new Error("<Line>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get material() {
    throw new Error("<Line>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set material(value) {
    throw new Error("<Line>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get line() {
    return this.$$.ctx[13];
  }
  set line(value) {
    throw new Error("<Line>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Line_default = Line2;

// node_modules/three/examples/jsm/lines/LineSegmentsGeometry.js
var _box = new Box3();
var _vector = new Vector3();
var LineSegmentsGeometry = class extends InstancedBufferGeometry {
  constructor() {
    super();
    this.isLineSegmentsGeometry = true;
    this.type = "LineSegmentsGeometry";
    const positions = [-1, 2, 0, 1, 2, 0, -1, 1, 0, 1, 1, 0, -1, 0, 0, 1, 0, 0, -1, -1, 0, 1, -1, 0];
    const uvs = [-1, 2, 1, 2, -1, 1, 1, 1, -1, -1, 1, -1, -1, -2, 1, -2];
    const index = [0, 2, 1, 2, 3, 1, 2, 4, 3, 4, 5, 3, 4, 6, 5, 6, 7, 5];
    this.setIndex(index);
    this.setAttribute("position", new Float32BufferAttribute(positions, 3));
    this.setAttribute("uv", new Float32BufferAttribute(uvs, 2));
  }
  applyMatrix4(matrix) {
    const start = this.attributes.instanceStart;
    const end = this.attributes.instanceEnd;
    if (start !== void 0) {
      start.applyMatrix4(matrix);
      end.applyMatrix4(matrix);
      start.needsUpdate = true;
    }
    if (this.boundingBox !== null) {
      this.computeBoundingBox();
    }
    if (this.boundingSphere !== null) {
      this.computeBoundingSphere();
    }
    return this;
  }
  setPositions(array) {
    let lineSegments;
    if (array instanceof Float32Array) {
      lineSegments = array;
    } else if (Array.isArray(array)) {
      lineSegments = new Float32Array(array);
    }
    const instanceBuffer = new InstancedInterleavedBuffer(lineSegments, 6, 1);
    this.setAttribute("instanceStart", new InterleavedBufferAttribute(instanceBuffer, 3, 0));
    this.setAttribute("instanceEnd", new InterleavedBufferAttribute(instanceBuffer, 3, 3));
    this.computeBoundingBox();
    this.computeBoundingSphere();
    return this;
  }
  setColors(array) {
    let colors;
    if (array instanceof Float32Array) {
      colors = array;
    } else if (Array.isArray(array)) {
      colors = new Float32Array(array);
    }
    const instanceColorBuffer = new InstancedInterleavedBuffer(colors, 6, 1);
    this.setAttribute("instanceColorStart", new InterleavedBufferAttribute(instanceColorBuffer, 3, 0));
    this.setAttribute("instanceColorEnd", new InterleavedBufferAttribute(instanceColorBuffer, 3, 3));
    return this;
  }
  fromWireframeGeometry(geometry) {
    this.setPositions(geometry.attributes.position.array);
    return this;
  }
  fromEdgesGeometry(geometry) {
    this.setPositions(geometry.attributes.position.array);
    return this;
  }
  fromMesh(mesh) {
    this.fromWireframeGeometry(new WireframeGeometry(mesh.geometry));
    return this;
  }
  fromLineSegments(lineSegments) {
    const geometry = lineSegments.geometry;
    this.setPositions(geometry.attributes.position.array);
    return this;
  }
  computeBoundingBox() {
    if (this.boundingBox === null) {
      this.boundingBox = new Box3();
    }
    const start = this.attributes.instanceStart;
    const end = this.attributes.instanceEnd;
    if (start !== void 0 && end !== void 0) {
      this.boundingBox.setFromBufferAttribute(start);
      _box.setFromBufferAttribute(end);
      this.boundingBox.union(_box);
    }
  }
  computeBoundingSphere() {
    if (this.boundingSphere === null) {
      this.boundingSphere = new Sphere();
    }
    if (this.boundingBox === null) {
      this.computeBoundingBox();
    }
    const start = this.attributes.instanceStart;
    const end = this.attributes.instanceEnd;
    if (start !== void 0 && end !== void 0) {
      const center = this.boundingSphere.center;
      this.boundingBox.getCenter(center);
      let maxRadiusSq = 0;
      for (let i = 0, il = start.count; i < il; i++) {
        _vector.fromBufferAttribute(start, i);
        maxRadiusSq = Math.max(maxRadiusSq, center.distanceToSquared(_vector));
        _vector.fromBufferAttribute(end, i);
        maxRadiusSq = Math.max(maxRadiusSq, center.distanceToSquared(_vector));
      }
      this.boundingSphere.radius = Math.sqrt(maxRadiusSq);
      if (isNaN(this.boundingSphere.radius)) {
        console.error("THREE.LineSegmentsGeometry.computeBoundingSphere(): Computed radius is NaN. The instanced position data is likely to have NaN values.", this);
      }
    }
  }
  toJSON() {
  }
  applyMatrix(matrix) {
    console.warn("THREE.LineSegmentsGeometry: applyMatrix() has been renamed to applyMatrix4().");
    return this.applyMatrix4(matrix);
  }
};

// node_modules/three/examples/jsm/lines/LineGeometry.js
var LineGeometry = class extends LineSegmentsGeometry {
  constructor() {
    super();
    this.isLineGeometry = true;
    this.type = "LineGeometry";
  }
  setPositions(array) {
    const length = array.length - 3;
    const points = new Float32Array(2 * length);
    for (let i = 0; i < length; i += 3) {
      points[2 * i] = array[i];
      points[2 * i + 1] = array[i + 1];
      points[2 * i + 2] = array[i + 2];
      points[2 * i + 3] = array[i + 3];
      points[2 * i + 4] = array[i + 4];
      points[2 * i + 5] = array[i + 5];
    }
    super.setPositions(points);
    return this;
  }
  setColors(array) {
    const length = array.length - 3;
    const colors = new Float32Array(2 * length);
    for (let i = 0; i < length; i += 3) {
      colors[2 * i] = array[i];
      colors[2 * i + 1] = array[i + 1];
      colors[2 * i + 2] = array[i + 2];
      colors[2 * i + 3] = array[i + 3];
      colors[2 * i + 4] = array[i + 4];
      colors[2 * i + 5] = array[i + 5];
    }
    super.setColors(colors);
    return this;
  }
  fromLine(line) {
    const geometry = line.geometry;
    this.setPositions(geometry.attributes.position.array);
    return this;
  }
};

// node_modules/three/examples/jsm/lines/LineMaterial.js
UniformsLib.line = {
  worldUnits: { value: 1 },
  linewidth: { value: 1 },
  resolution: { value: new Vector2(1, 1) },
  dashOffset: { value: 0 },
  dashScale: { value: 1 },
  dashSize: { value: 1 },
  gapSize: { value: 1 }
  // todo FIX - maybe change to totalSize
};
ShaderLib["line"] = {
  uniforms: UniformsUtils.merge([
    UniformsLib.common,
    UniformsLib.fog,
    UniformsLib.line
  ]),
  vertexShader: (
    /* glsl */
    `
		#include <common>
		#include <color_pars_vertex>
		#include <fog_pars_vertex>
		#include <logdepthbuf_pars_vertex>
		#include <clipping_planes_pars_vertex>

		uniform float linewidth;
		uniform vec2 resolution;

		attribute vec3 instanceStart;
		attribute vec3 instanceEnd;

		attribute vec3 instanceColorStart;
		attribute vec3 instanceColorEnd;

		#ifdef WORLD_UNITS

			varying vec4 worldPos;
			varying vec3 worldStart;
			varying vec3 worldEnd;

			#ifdef USE_DASH

				varying vec2 vUv;

			#endif

		#else

			varying vec2 vUv;

		#endif

		#ifdef USE_DASH

			uniform float dashScale;
			attribute float instanceDistanceStart;
			attribute float instanceDistanceEnd;
			varying float vLineDistance;

		#endif

		void trimSegment( const in vec4 start, inout vec4 end ) {

			// trim end segment so it terminates between the camera plane and the near plane

			// conservative estimate of the near plane
			float a = projectionMatrix[ 2 ][ 2 ]; // 3nd entry in 3th column
			float b = projectionMatrix[ 3 ][ 2 ]; // 3nd entry in 4th column
			float nearEstimate = - 0.5 * b / a;

			float alpha = ( nearEstimate - start.z ) / ( end.z - start.z );

			end.xyz = mix( start.xyz, end.xyz, alpha );

		}

		void main() {

			#ifdef USE_COLOR

				vColor.xyz = ( position.y < 0.5 ) ? instanceColorStart : instanceColorEnd;

			#endif

			#ifdef USE_DASH

				vLineDistance = ( position.y < 0.5 ) ? dashScale * instanceDistanceStart : dashScale * instanceDistanceEnd;
				vUv = uv;

			#endif

			float aspect = resolution.x / resolution.y;

			// camera space
			vec4 start = modelViewMatrix * vec4( instanceStart, 1.0 );
			vec4 end = modelViewMatrix * vec4( instanceEnd, 1.0 );

			#ifdef WORLD_UNITS

				worldStart = start.xyz;
				worldEnd = end.xyz;

			#else

				vUv = uv;

			#endif

			// special case for perspective projection, and segments that terminate either in, or behind, the camera plane
			// clearly the gpu firmware has a way of addressing this issue when projecting into ndc space
			// but we need to perform ndc-space calculations in the shader, so we must address this issue directly
			// perhaps there is a more elegant solution -- WestLangley

			bool perspective = ( projectionMatrix[ 2 ][ 3 ] == - 1.0 ); // 4th entry in the 3rd column

			if ( perspective ) {

				if ( start.z < 0.0 && end.z >= 0.0 ) {

					trimSegment( start, end );

				} else if ( end.z < 0.0 && start.z >= 0.0 ) {

					trimSegment( end, start );

				}

			}

			// clip space
			vec4 clipStart = projectionMatrix * start;
			vec4 clipEnd = projectionMatrix * end;

			// ndc space
			vec3 ndcStart = clipStart.xyz / clipStart.w;
			vec3 ndcEnd = clipEnd.xyz / clipEnd.w;

			// direction
			vec2 dir = ndcEnd.xy - ndcStart.xy;

			// account for clip-space aspect ratio
			dir.x *= aspect;
			dir = normalize( dir );

			#ifdef WORLD_UNITS

				// get the offset direction as perpendicular to the view vector
				vec3 worldDir = normalize( end.xyz - start.xyz );
				vec3 offset;
				if ( position.y < 0.5 ) {

					offset = normalize( cross( start.xyz, worldDir ) );

				} else {

					offset = normalize( cross( end.xyz, worldDir ) );

				}

				// sign flip
				if ( position.x < 0.0 ) offset *= - 1.0;

				float forwardOffset = dot( worldDir, vec3( 0.0, 0.0, 1.0 ) );

				// don't extend the line if we're rendering dashes because we
				// won't be rendering the endcaps
				#ifndef USE_DASH

					// extend the line bounds to encompass  endcaps
					start.xyz += - worldDir * linewidth * 0.5;
					end.xyz += worldDir * linewidth * 0.5;

					// shift the position of the quad so it hugs the forward edge of the line
					offset.xy -= dir * forwardOffset;
					offset.z += 0.5;

				#endif

				// endcaps
				if ( position.y > 1.0 || position.y < 0.0 ) {

					offset.xy += dir * 2.0 * forwardOffset;

				}

				// adjust for linewidth
				offset *= linewidth * 0.5;

				// set the world position
				worldPos = ( position.y < 0.5 ) ? start : end;
				worldPos.xyz += offset;

				// project the worldpos
				vec4 clip = projectionMatrix * worldPos;

				// shift the depth of the projected points so the line
				// segments overlap neatly
				vec3 clipPose = ( position.y < 0.5 ) ? ndcStart : ndcEnd;
				clip.z = clipPose.z * clip.w;

			#else

				vec2 offset = vec2( dir.y, - dir.x );
				// undo aspect ratio adjustment
				dir.x /= aspect;
				offset.x /= aspect;

				// sign flip
				if ( position.x < 0.0 ) offset *= - 1.0;

				// endcaps
				if ( position.y < 0.0 ) {

					offset += - dir;

				} else if ( position.y > 1.0 ) {

					offset += dir;

				}

				// adjust for linewidth
				offset *= linewidth;

				// adjust for clip-space to screen-space conversion // maybe resolution should be based on viewport ...
				offset /= resolution.y;

				// select end
				vec4 clip = ( position.y < 0.5 ) ? clipStart : clipEnd;

				// back to clip space
				offset *= clip.w;

				clip.xy += offset;

			#endif

			gl_Position = clip;

			vec4 mvPosition = ( position.y < 0.5 ) ? start : end; // this is an approximation

			#include <logdepthbuf_vertex>
			#include <clipping_planes_vertex>
			#include <fog_vertex>

		}
		`
  ),
  fragmentShader: (
    /* glsl */
    `
		uniform vec3 diffuse;
		uniform float opacity;
		uniform float linewidth;

		#ifdef USE_DASH

			uniform float dashOffset;
			uniform float dashSize;
			uniform float gapSize;

		#endif

		varying float vLineDistance;

		#ifdef WORLD_UNITS

			varying vec4 worldPos;
			varying vec3 worldStart;
			varying vec3 worldEnd;

			#ifdef USE_DASH

				varying vec2 vUv;

			#endif

		#else

			varying vec2 vUv;

		#endif

		#include <common>
		#include <color_pars_fragment>
		#include <fog_pars_fragment>
		#include <logdepthbuf_pars_fragment>
		#include <clipping_planes_pars_fragment>

		vec2 closestLineToLine(vec3 p1, vec3 p2, vec3 p3, vec3 p4) {

			float mua;
			float mub;

			vec3 p13 = p1 - p3;
			vec3 p43 = p4 - p3;

			vec3 p21 = p2 - p1;

			float d1343 = dot( p13, p43 );
			float d4321 = dot( p43, p21 );
			float d1321 = dot( p13, p21 );
			float d4343 = dot( p43, p43 );
			float d2121 = dot( p21, p21 );

			float denom = d2121 * d4343 - d4321 * d4321;

			float numer = d1343 * d4321 - d1321 * d4343;

			mua = numer / denom;
			mua = clamp( mua, 0.0, 1.0 );
			mub = ( d1343 + d4321 * ( mua ) ) / d4343;
			mub = clamp( mub, 0.0, 1.0 );

			return vec2( mua, mub );

		}

		void main() {

			#include <clipping_planes_fragment>

			#ifdef USE_DASH

				if ( vUv.y < - 1.0 || vUv.y > 1.0 ) discard; // discard endcaps

				if ( mod( vLineDistance + dashOffset, dashSize + gapSize ) > dashSize ) discard; // todo - FIX

			#endif

			float alpha = opacity;

			#ifdef WORLD_UNITS

				// Find the closest points on the view ray and the line segment
				vec3 rayEnd = normalize( worldPos.xyz ) * 1e5;
				vec3 lineDir = worldEnd - worldStart;
				vec2 params = closestLineToLine( worldStart, worldEnd, vec3( 0.0, 0.0, 0.0 ), rayEnd );

				vec3 p1 = worldStart + lineDir * params.x;
				vec3 p2 = rayEnd * params.y;
				vec3 delta = p1 - p2;
				float len = length( delta );
				float norm = len / linewidth;

				#ifndef USE_DASH

					#ifdef USE_ALPHA_TO_COVERAGE

						float dnorm = fwidth( norm );
						alpha = 1.0 - smoothstep( 0.5 - dnorm, 0.5 + dnorm, norm );

					#else

						if ( norm > 0.5 ) {

							discard;

						}

					#endif

				#endif

			#else

				#ifdef USE_ALPHA_TO_COVERAGE

					// artifacts appear on some hardware if a derivative is taken within a conditional
					float a = vUv.x;
					float b = ( vUv.y > 0.0 ) ? vUv.y - 1.0 : vUv.y + 1.0;
					float len2 = a * a + b * b;
					float dlen = fwidth( len2 );

					if ( abs( vUv.y ) > 1.0 ) {

						alpha = 1.0 - smoothstep( 1.0 - dlen, 1.0 + dlen, len2 );

					}

				#else

					if ( abs( vUv.y ) > 1.0 ) {

						float a = vUv.x;
						float b = ( vUv.y > 0.0 ) ? vUv.y - 1.0 : vUv.y + 1.0;
						float len2 = a * a + b * b;

						if ( len2 > 1.0 ) discard;

					}

				#endif

			#endif

			vec4 diffuseColor = vec4( diffuse, alpha );

			#include <logdepthbuf_fragment>
			#include <color_fragment>

			gl_FragColor = vec4( diffuseColor.rgb, alpha );

			#include <tonemapping_fragment>
			#include <encodings_fragment>
			#include <fog_fragment>
			#include <premultiplied_alpha_fragment>

		}
		`
  )
};
var LineMaterial = class extends ShaderMaterial {
  constructor(parameters) {
    super({
      type: "LineMaterial",
      uniforms: UniformsUtils.clone(ShaderLib["line"].uniforms),
      vertexShader: ShaderLib["line"].vertexShader,
      fragmentShader: ShaderLib["line"].fragmentShader,
      clipping: true
      // required for clipping support
    });
    this.isLineMaterial = true;
    Object.defineProperties(this, {
      color: {
        enumerable: true,
        get: function() {
          return this.uniforms.diffuse.value;
        },
        set: function(value) {
          this.uniforms.diffuse.value = value;
        }
      },
      worldUnits: {
        enumerable: true,
        get: function() {
          return "WORLD_UNITS" in this.defines;
        },
        set: function(value) {
          if (value === true) {
            this.defines.WORLD_UNITS = "";
          } else {
            delete this.defines.WORLD_UNITS;
          }
        }
      },
      linewidth: {
        enumerable: true,
        get: function() {
          return this.uniforms.linewidth.value;
        },
        set: function(value) {
          this.uniforms.linewidth.value = value;
        }
      },
      dashed: {
        enumerable: true,
        get: function() {
          return Boolean("USE_DASH" in this.defines);
        },
        set(value) {
          if (Boolean(value) !== Boolean("USE_DASH" in this.defines)) {
            this.needsUpdate = true;
          }
          if (value === true) {
            this.defines.USE_DASH = "";
          } else {
            delete this.defines.USE_DASH;
          }
        }
      },
      dashScale: {
        enumerable: true,
        get: function() {
          return this.uniforms.dashScale.value;
        },
        set: function(value) {
          this.uniforms.dashScale.value = value;
        }
      },
      dashSize: {
        enumerable: true,
        get: function() {
          return this.uniforms.dashSize.value;
        },
        set: function(value) {
          this.uniforms.dashSize.value = value;
        }
      },
      dashOffset: {
        enumerable: true,
        get: function() {
          return this.uniforms.dashOffset.value;
        },
        set: function(value) {
          this.uniforms.dashOffset.value = value;
        }
      },
      gapSize: {
        enumerable: true,
        get: function() {
          return this.uniforms.gapSize.value;
        },
        set: function(value) {
          this.uniforms.gapSize.value = value;
        }
      },
      opacity: {
        enumerable: true,
        get: function() {
          return this.uniforms.opacity.value;
        },
        set: function(value) {
          this.uniforms.opacity.value = value;
        }
      },
      resolution: {
        enumerable: true,
        get: function() {
          return this.uniforms.resolution.value;
        },
        set: function(value) {
          this.uniforms.resolution.value.copy(value);
        }
      },
      alphaToCoverage: {
        enumerable: true,
        get: function() {
          return Boolean("USE_ALPHA_TO_COVERAGE" in this.defines);
        },
        set: function(value) {
          if (Boolean(value) !== Boolean("USE_ALPHA_TO_COVERAGE" in this.defines)) {
            this.needsUpdate = true;
          }
          if (value === true) {
            this.defines.USE_ALPHA_TO_COVERAGE = "";
            this.extensions.derivatives = true;
          } else {
            delete this.defines.USE_ALPHA_TO_COVERAGE;
            this.extensions.derivatives = false;
          }
        }
      }
    });
    this.setValues(parameters);
  }
};

// node_modules/three/examples/jsm/lines/LineSegments2.js
var _start = new Vector3();
var _end = new Vector3();
var _start4 = new Vector4();
var _end4 = new Vector4();
var _ssOrigin = new Vector4();
var _ssOrigin3 = new Vector3();
var _mvMatrix = new Matrix4();
var _line = new Line3();
var _closestPoint = new Vector3();
var _box2 = new Box3();
var _sphere = new Sphere();
var _clipToWorldVector = new Vector4();
var _ray;
var _lineWidth;
function getWorldSpaceHalfWidth(camera, distance, resolution) {
  _clipToWorldVector.set(0, 0, -distance, 1).applyMatrix4(camera.projectionMatrix);
  _clipToWorldVector.multiplyScalar(1 / _clipToWorldVector.w);
  _clipToWorldVector.x = _lineWidth / resolution.width;
  _clipToWorldVector.y = _lineWidth / resolution.height;
  _clipToWorldVector.applyMatrix4(camera.projectionMatrixInverse);
  _clipToWorldVector.multiplyScalar(1 / _clipToWorldVector.w);
  return Math.abs(Math.max(_clipToWorldVector.x, _clipToWorldVector.y));
}
function raycastWorldUnits(lineSegments, intersects) {
  const matrixWorld = lineSegments.matrixWorld;
  const geometry = lineSegments.geometry;
  const instanceStart = geometry.attributes.instanceStart;
  const instanceEnd = geometry.attributes.instanceEnd;
  const segmentCount = Math.min(geometry.instanceCount, instanceStart.count);
  for (let i = 0, l = segmentCount; i < l; i++) {
    _line.start.fromBufferAttribute(instanceStart, i);
    _line.end.fromBufferAttribute(instanceEnd, i);
    _line.applyMatrix4(matrixWorld);
    const pointOnLine = new Vector3();
    const point = new Vector3();
    _ray.distanceSqToSegment(_line.start, _line.end, point, pointOnLine);
    const isInside = point.distanceTo(pointOnLine) < _lineWidth * 0.5;
    if (isInside) {
      intersects.push({
        point,
        pointOnLine,
        distance: _ray.origin.distanceTo(point),
        object: lineSegments,
        face: null,
        faceIndex: i,
        uv: null,
        uv1: null
      });
    }
  }
}
function raycastScreenSpace(lineSegments, camera, intersects) {
  const projectionMatrix = camera.projectionMatrix;
  const material = lineSegments.material;
  const resolution = material.resolution;
  const matrixWorld = lineSegments.matrixWorld;
  const geometry = lineSegments.geometry;
  const instanceStart = geometry.attributes.instanceStart;
  const instanceEnd = geometry.attributes.instanceEnd;
  const segmentCount = Math.min(geometry.instanceCount, instanceStart.count);
  const near = -camera.near;
  _ray.at(1, _ssOrigin);
  _ssOrigin.w = 1;
  _ssOrigin.applyMatrix4(camera.matrixWorldInverse);
  _ssOrigin.applyMatrix4(projectionMatrix);
  _ssOrigin.multiplyScalar(1 / _ssOrigin.w);
  _ssOrigin.x *= resolution.x / 2;
  _ssOrigin.y *= resolution.y / 2;
  _ssOrigin.z = 0;
  _ssOrigin3.copy(_ssOrigin);
  _mvMatrix.multiplyMatrices(camera.matrixWorldInverse, matrixWorld);
  for (let i = 0, l = segmentCount; i < l; i++) {
    _start4.fromBufferAttribute(instanceStart, i);
    _end4.fromBufferAttribute(instanceEnd, i);
    _start4.w = 1;
    _end4.w = 1;
    _start4.applyMatrix4(_mvMatrix);
    _end4.applyMatrix4(_mvMatrix);
    const isBehindCameraNear = _start4.z > near && _end4.z > near;
    if (isBehindCameraNear) {
      continue;
    }
    if (_start4.z > near) {
      const deltaDist = _start4.z - _end4.z;
      const t2 = (_start4.z - near) / deltaDist;
      _start4.lerp(_end4, t2);
    } else if (_end4.z > near) {
      const deltaDist = _end4.z - _start4.z;
      const t2 = (_end4.z - near) / deltaDist;
      _end4.lerp(_start4, t2);
    }
    _start4.applyMatrix4(projectionMatrix);
    _end4.applyMatrix4(projectionMatrix);
    _start4.multiplyScalar(1 / _start4.w);
    _end4.multiplyScalar(1 / _end4.w);
    _start4.x *= resolution.x / 2;
    _start4.y *= resolution.y / 2;
    _end4.x *= resolution.x / 2;
    _end4.y *= resolution.y / 2;
    _line.start.copy(_start4);
    _line.start.z = 0;
    _line.end.copy(_end4);
    _line.end.z = 0;
    const param = _line.closestPointToPointParameter(_ssOrigin3, true);
    _line.at(param, _closestPoint);
    const zPos = MathUtils.lerp(_start4.z, _end4.z, param);
    const isInClipSpace = zPos >= -1 && zPos <= 1;
    const isInside = _ssOrigin3.distanceTo(_closestPoint) < _lineWidth * 0.5;
    if (isInClipSpace && isInside) {
      _line.start.fromBufferAttribute(instanceStart, i);
      _line.end.fromBufferAttribute(instanceEnd, i);
      _line.start.applyMatrix4(matrixWorld);
      _line.end.applyMatrix4(matrixWorld);
      const pointOnLine = new Vector3();
      const point = new Vector3();
      _ray.distanceSqToSegment(_line.start, _line.end, point, pointOnLine);
      intersects.push({
        point,
        pointOnLine,
        distance: _ray.origin.distanceTo(point),
        object: lineSegments,
        face: null,
        faceIndex: i,
        uv: null,
        uv1: null
      });
    }
  }
}
var LineSegments2 = class extends Mesh {
  constructor(geometry = new LineSegmentsGeometry(), material = new LineMaterial({ color: Math.random() * 16777215 })) {
    super(geometry, material);
    this.isLineSegments2 = true;
    this.type = "LineSegments2";
  }
  // for backwards-compatibility, but could be a method of LineSegmentsGeometry...
  computeLineDistances() {
    const geometry = this.geometry;
    const instanceStart = geometry.attributes.instanceStart;
    const instanceEnd = geometry.attributes.instanceEnd;
    const lineDistances = new Float32Array(2 * instanceStart.count);
    for (let i = 0, j = 0, l = instanceStart.count; i < l; i++, j += 2) {
      _start.fromBufferAttribute(instanceStart, i);
      _end.fromBufferAttribute(instanceEnd, i);
      lineDistances[j] = j === 0 ? 0 : lineDistances[j - 1];
      lineDistances[j + 1] = lineDistances[j] + _start.distanceTo(_end);
    }
    const instanceDistanceBuffer = new InstancedInterleavedBuffer(lineDistances, 2, 1);
    geometry.setAttribute("instanceDistanceStart", new InterleavedBufferAttribute(instanceDistanceBuffer, 1, 0));
    geometry.setAttribute("instanceDistanceEnd", new InterleavedBufferAttribute(instanceDistanceBuffer, 1, 1));
    return this;
  }
  raycast(raycaster, intersects) {
    const worldUnits = this.material.worldUnits;
    const camera = raycaster.camera;
    if (camera === null && !worldUnits) {
      console.error('LineSegments2: "Raycaster.camera" needs to be set in order to raycast against LineSegments2 while worldUnits is set to false.');
    }
    const threshold = raycaster.params.Line2 !== void 0 ? raycaster.params.Line2.threshold || 0 : 0;
    _ray = raycaster.ray;
    const matrixWorld = this.matrixWorld;
    const geometry = this.geometry;
    const material = this.material;
    _lineWidth = material.linewidth + threshold;
    if (geometry.boundingSphere === null) {
      geometry.computeBoundingSphere();
    }
    _sphere.copy(geometry.boundingSphere).applyMatrix4(matrixWorld);
    let sphereMargin;
    if (worldUnits) {
      sphereMargin = _lineWidth * 0.5;
    } else {
      const distanceToSphere = Math.max(camera.near, _sphere.distanceToPoint(_ray.origin));
      sphereMargin = getWorldSpaceHalfWidth(camera, distanceToSphere, material.resolution);
    }
    _sphere.radius += sphereMargin;
    if (_ray.intersectsSphere(_sphere) === false) {
      return;
    }
    if (geometry.boundingBox === null) {
      geometry.computeBoundingBox();
    }
    _box2.copy(geometry.boundingBox).applyMatrix4(matrixWorld);
    let boxMargin;
    if (worldUnits) {
      boxMargin = _lineWidth * 0.5;
    } else {
      const distanceToBox = Math.max(camera.near, _box2.distanceToPoint(_ray.origin));
      boxMargin = getWorldSpaceHalfWidth(camera, distanceToBox, material.resolution);
    }
    _box2.expandByScalar(boxMargin);
    if (_ray.intersectsBox(_box2) === false) {
      return;
    }
    if (worldUnits) {
      raycastWorldUnits(this, intersects);
    } else {
      raycastScreenSpace(this, camera, intersects);
    }
  }
};

// node_modules/three/examples/jsm/lines/Line2.js
var Line22 = class extends LineSegments2 {
  constructor(geometry = new LineGeometry(), material = new LineMaterial({ color: Math.random() * 16777215 })) {
    super(geometry, material);
    this.isLine2 = true;
    this.type = "Line2";
  }
};

// node_modules/threlte/objects/Line2.svelte
function create_default_slot24(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[18].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[29],
    null
  );
  const block = {
    c: function create() {
      if (default_slot)
        default_slot.c();
    },
    l: function claim(nodes) {
      if (default_slot)
        default_slot.l(nodes);
    },
    m: function mount(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty[0] & /*$$scope*/
        536870912)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[29],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[29]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[29],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot24.name,
    type: "slot",
    source: "(57:0) <MeshInstance   mesh={line2}   {position}   {scale}   {rotation}   {lookAt}   {castShadow}   {receiveShadow}   {frustumCulled}   {renderOrder}   {visible}   {interactive}   {ignorePointer}   on:click   on:contextmenu   on:pointerup   on:pointerdown   on:pointerenter   on:pointerleave   on:pointermove   {viewportAware}   bind:inViewport   on:viewportenter   on:viewportleave >",
    ctx
  });
  return block;
}
function create_fragment38(ctx) {
  let meshinstance;
  let updating_inViewport;
  let current;
  function meshinstance_inViewport_binding(value) {
    ctx[19](value);
  }
  let meshinstance_props = {
    mesh: (
      /*line2*/
      ctx[13]
    ),
    position: (
      /*position*/
      ctx[1]
    ),
    scale: (
      /*scale*/
      ctx[2]
    ),
    rotation: (
      /*rotation*/
      ctx[3]
    ),
    lookAt: (
      /*lookAt*/
      ctx[12]
    ),
    castShadow: (
      /*castShadow*/
      ctx[5]
    ),
    receiveShadow: (
      /*receiveShadow*/
      ctx[6]
    ),
    frustumCulled: (
      /*frustumCulled*/
      ctx[7]
    ),
    renderOrder: (
      /*renderOrder*/
      ctx[8]
    ),
    visible: (
      /*visible*/
      ctx[9]
    ),
    interactive: (
      /*interactive*/
      ctx[10]
    ),
    ignorePointer: (
      /*ignorePointer*/
      ctx[11]
    ),
    viewportAware: (
      /*viewportAware*/
      ctx[4]
    ),
    $$slots: { default: [create_default_slot24] },
    $$scope: { ctx }
  };
  if (
    /*inViewport*/
    ctx[0] !== void 0
  ) {
    meshinstance_props.inViewport = /*inViewport*/
    ctx[0];
  }
  meshinstance = new MeshInstance_default({
    props: meshinstance_props,
    $$inline: true
  });
  binding_callbacks.push(() => bind(meshinstance, "inViewport", meshinstance_inViewport_binding));
  meshinstance.$on(
    "click",
    /*click_handler*/
    ctx[20]
  );
  meshinstance.$on(
    "contextmenu",
    /*contextmenu_handler*/
    ctx[21]
  );
  meshinstance.$on(
    "pointerup",
    /*pointerup_handler*/
    ctx[22]
  );
  meshinstance.$on(
    "pointerdown",
    /*pointerdown_handler*/
    ctx[23]
  );
  meshinstance.$on(
    "pointerenter",
    /*pointerenter_handler*/
    ctx[24]
  );
  meshinstance.$on(
    "pointerleave",
    /*pointerleave_handler*/
    ctx[25]
  );
  meshinstance.$on(
    "pointermove",
    /*pointermove_handler*/
    ctx[26]
  );
  meshinstance.$on(
    "viewportenter",
    /*viewportenter_handler*/
    ctx[27]
  );
  meshinstance.$on(
    "viewportleave",
    /*viewportleave_handler*/
    ctx[28]
  );
  const block = {
    c: function create() {
      create_component(meshinstance.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(meshinstance.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(meshinstance, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const meshinstance_changes = {};
      if (dirty[0] & /*position*/
      2)
        meshinstance_changes.position = /*position*/
        ctx2[1];
      if (dirty[0] & /*scale*/
      4)
        meshinstance_changes.scale = /*scale*/
        ctx2[2];
      if (dirty[0] & /*rotation*/
      8)
        meshinstance_changes.rotation = /*rotation*/
        ctx2[3];
      if (dirty[0] & /*lookAt*/
      4096)
        meshinstance_changes.lookAt = /*lookAt*/
        ctx2[12];
      if (dirty[0] & /*castShadow*/
      32)
        meshinstance_changes.castShadow = /*castShadow*/
        ctx2[5];
      if (dirty[0] & /*receiveShadow*/
      64)
        meshinstance_changes.receiveShadow = /*receiveShadow*/
        ctx2[6];
      if (dirty[0] & /*frustumCulled*/
      128)
        meshinstance_changes.frustumCulled = /*frustumCulled*/
        ctx2[7];
      if (dirty[0] & /*renderOrder*/
      256)
        meshinstance_changes.renderOrder = /*renderOrder*/
        ctx2[8];
      if (dirty[0] & /*visible*/
      512)
        meshinstance_changes.visible = /*visible*/
        ctx2[9];
      if (dirty[0] & /*interactive*/
      1024)
        meshinstance_changes.interactive = /*interactive*/
        ctx2[10];
      if (dirty[0] & /*ignorePointer*/
      2048)
        meshinstance_changes.ignorePointer = /*ignorePointer*/
        ctx2[11];
      if (dirty[0] & /*viewportAware*/
      16)
        meshinstance_changes.viewportAware = /*viewportAware*/
        ctx2[4];
      if (dirty[0] & /*$$scope*/
      536870912) {
        meshinstance_changes.$$scope = { dirty, ctx: ctx2 };
      }
      if (!updating_inViewport && dirty[0] & /*inViewport*/
      1) {
        updating_inViewport = true;
        meshinstance_changes.inViewport = /*inViewport*/
        ctx2[0];
        add_flush_callback(() => updating_inViewport = false);
      }
      meshinstance.$set(meshinstance_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(meshinstance.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(meshinstance.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(meshinstance, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment38.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance37($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Line2", slots, ["default"]);
  let { position = void 0 } = $$props;
  let { scale = void 0 } = $$props;
  let { rotation = void 0 } = $$props;
  let { viewportAware = false } = $$props;
  let { inViewport = false } = $$props;
  let { castShadow = void 0 } = $$props;
  let { receiveShadow = void 0 } = $$props;
  let { frustumCulled = void 0 } = $$props;
  let { renderOrder = void 0 } = $$props;
  let { visible = void 0 } = $$props;
  let { interactive = false } = $$props;
  let { ignorePointer = false } = $$props;
  let { lookAt = void 0 } = $$props;
  let { points = [] } = $$props;
  let { material } = $$props;
  const geometry = new LineGeometry();
  const pointTuples = points.map((p2) => p2 instanceof Vector3 ? p2.toArray() : p2);
  geometry.setPositions(pointTuples.flat());
  const line2 = new Line22(geometry, material);
  line2.computeLineDistances();
  onDestroy(() => {
    geometry.dispose();
  });
  const getLine = () => line2;
  const { invalidate } = useThrelte();
  let previousMaterial = material;
  let previousPoints = points;
  $$self.$$.on_mount.push(function() {
    if (material === void 0 && !("material" in $$props || $$self.$$.bound[$$self.$$.props["material"]])) {
      console.warn("<Line2> was created without expected prop 'material'");
    }
  });
  const writable_props = [
    "position",
    "scale",
    "rotation",
    "viewportAware",
    "inViewport",
    "castShadow",
    "receiveShadow",
    "frustumCulled",
    "renderOrder",
    "visible",
    "interactive",
    "ignorePointer",
    "lookAt",
    "points",
    "material"
  ];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<Line2> was created with unknown prop '${key}'`);
  });
  function meshinstance_inViewport_binding(value) {
    inViewport = value;
    $$invalidate(0, inViewport);
  }
  function click_handler(event) {
    bubble.call(this, $$self, event);
  }
  function contextmenu_handler(event) {
    bubble.call(this, $$self, event);
  }
  function pointerup_handler(event) {
    bubble.call(this, $$self, event);
  }
  function pointerdown_handler(event) {
    bubble.call(this, $$self, event);
  }
  function pointerenter_handler(event) {
    bubble.call(this, $$self, event);
  }
  function pointerleave_handler(event) {
    bubble.call(this, $$self, event);
  }
  function pointermove_handler(event) {
    bubble.call(this, $$self, event);
  }
  function viewportenter_handler(event) {
    bubble.call(this, $$self, event);
  }
  function viewportleave_handler(event) {
    bubble.call(this, $$self, event);
  }
  $$self.$$set = ($$props2) => {
    if ("position" in $$props2)
      $$invalidate(1, position = $$props2.position);
    if ("scale" in $$props2)
      $$invalidate(2, scale = $$props2.scale);
    if ("rotation" in $$props2)
      $$invalidate(3, rotation = $$props2.rotation);
    if ("viewportAware" in $$props2)
      $$invalidate(4, viewportAware = $$props2.viewportAware);
    if ("inViewport" in $$props2)
      $$invalidate(0, inViewport = $$props2.inViewport);
    if ("castShadow" in $$props2)
      $$invalidate(5, castShadow = $$props2.castShadow);
    if ("receiveShadow" in $$props2)
      $$invalidate(6, receiveShadow = $$props2.receiveShadow);
    if ("frustumCulled" in $$props2)
      $$invalidate(7, frustumCulled = $$props2.frustumCulled);
    if ("renderOrder" in $$props2)
      $$invalidate(8, renderOrder = $$props2.renderOrder);
    if ("visible" in $$props2)
      $$invalidate(9, visible = $$props2.visible);
    if ("interactive" in $$props2)
      $$invalidate(10, interactive = $$props2.interactive);
    if ("ignorePointer" in $$props2)
      $$invalidate(11, ignorePointer = $$props2.ignorePointer);
    if ("lookAt" in $$props2)
      $$invalidate(12, lookAt = $$props2.lookAt);
    if ("points" in $$props2)
      $$invalidate(14, points = $$props2.points);
    if ("material" in $$props2)
      $$invalidate(15, material = $$props2.material);
    if ("$$scope" in $$props2)
      $$invalidate(29, $$scope = $$props2.$$scope);
  };
  $$self.$capture_state = () => ({
    onDestroy,
    LineGeometry,
    useThrelte,
    MeshInstance: MeshInstance_default,
    ThreeLine2: Line22,
    Vector3,
    position,
    scale,
    rotation,
    viewportAware,
    inViewport,
    castShadow,
    receiveShadow,
    frustumCulled,
    renderOrder,
    visible,
    interactive,
    ignorePointer,
    lookAt,
    points,
    material,
    geometry,
    pointTuples,
    line2,
    getLine,
    invalidate,
    previousMaterial,
    previousPoints
  });
  $$self.$inject_state = ($$props2) => {
    if ("position" in $$props2)
      $$invalidate(1, position = $$props2.position);
    if ("scale" in $$props2)
      $$invalidate(2, scale = $$props2.scale);
    if ("rotation" in $$props2)
      $$invalidate(3, rotation = $$props2.rotation);
    if ("viewportAware" in $$props2)
      $$invalidate(4, viewportAware = $$props2.viewportAware);
    if ("inViewport" in $$props2)
      $$invalidate(0, inViewport = $$props2.inViewport);
    if ("castShadow" in $$props2)
      $$invalidate(5, castShadow = $$props2.castShadow);
    if ("receiveShadow" in $$props2)
      $$invalidate(6, receiveShadow = $$props2.receiveShadow);
    if ("frustumCulled" in $$props2)
      $$invalidate(7, frustumCulled = $$props2.frustumCulled);
    if ("renderOrder" in $$props2)
      $$invalidate(8, renderOrder = $$props2.renderOrder);
    if ("visible" in $$props2)
      $$invalidate(9, visible = $$props2.visible);
    if ("interactive" in $$props2)
      $$invalidate(10, interactive = $$props2.interactive);
    if ("ignorePointer" in $$props2)
      $$invalidate(11, ignorePointer = $$props2.ignorePointer);
    if ("lookAt" in $$props2)
      $$invalidate(12, lookAt = $$props2.lookAt);
    if ("points" in $$props2)
      $$invalidate(14, points = $$props2.points);
    if ("material" in $$props2)
      $$invalidate(15, material = $$props2.material);
    if ("previousMaterial" in $$props2)
      $$invalidate(16, previousMaterial = $$props2.previousMaterial);
    if ("previousPoints" in $$props2)
      $$invalidate(17, previousPoints = $$props2.previousPoints);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty[0] & /*material, previousMaterial*/
    98304) {
      $: {
        if (material !== previousMaterial) {
          getLine().material = material;
          invalidate("Line2: material changed");
        } else {
          invalidate("Line2: material props changed");
        }
        $$invalidate(16, previousMaterial = material);
      }
    }
    if ($$self.$$.dirty[0] & /*points, previousPoints*/
    147456) {
      $: {
        if (points !== previousPoints) {
          const pointTuples2 = points.map((p2) => p2 instanceof Vector3 ? p2.toArray() : p2);
          geometry.setPositions(pointTuples2.flat());
          line2.computeLineDistances();
          invalidate("Line2: points changed");
          $$invalidate(17, previousPoints = points);
        }
      }
    }
  };
  return [
    inViewport,
    position,
    scale,
    rotation,
    viewportAware,
    castShadow,
    receiveShadow,
    frustumCulled,
    renderOrder,
    visible,
    interactive,
    ignorePointer,
    lookAt,
    line2,
    points,
    material,
    previousMaterial,
    previousPoints,
    slots,
    meshinstance_inViewport_binding,
    click_handler,
    contextmenu_handler,
    pointerup_handler,
    pointerdown_handler,
    pointerenter_handler,
    pointerleave_handler,
    pointermove_handler,
    viewportenter_handler,
    viewportleave_handler,
    $$scope
  ];
}
var Line23 = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(
      this,
      options,
      instance37,
      create_fragment38,
      safe_not_equal,
      {
        position: 1,
        scale: 2,
        rotation: 3,
        viewportAware: 4,
        inViewport: 0,
        castShadow: 5,
        receiveShadow: 6,
        frustumCulled: 7,
        renderOrder: 8,
        visible: 9,
        interactive: 10,
        ignorePointer: 11,
        lookAt: 12,
        points: 14,
        material: 15,
        line2: 13
      },
      null,
      [-1, -1]
    );
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Line2",
      options,
      id: create_fragment38.name
    });
  }
  get position() {
    throw new Error("<Line2>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set position(value) {
    throw new Error("<Line2>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get scale() {
    throw new Error("<Line2>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set scale(value) {
    throw new Error("<Line2>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get rotation() {
    throw new Error("<Line2>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set rotation(value) {
    throw new Error("<Line2>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get viewportAware() {
    throw new Error("<Line2>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set viewportAware(value) {
    throw new Error("<Line2>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get inViewport() {
    throw new Error("<Line2>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set inViewport(value) {
    throw new Error("<Line2>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get castShadow() {
    throw new Error("<Line2>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set castShadow(value) {
    throw new Error("<Line2>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get receiveShadow() {
    throw new Error("<Line2>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set receiveShadow(value) {
    throw new Error("<Line2>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get frustumCulled() {
    throw new Error("<Line2>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set frustumCulled(value) {
    throw new Error("<Line2>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get renderOrder() {
    throw new Error("<Line2>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set renderOrder(value) {
    throw new Error("<Line2>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get visible() {
    throw new Error("<Line2>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set visible(value) {
    throw new Error("<Line2>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get interactive() {
    throw new Error("<Line2>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set interactive(value) {
    throw new Error("<Line2>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get ignorePointer() {
    throw new Error("<Line2>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set ignorePointer(value) {
    throw new Error("<Line2>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get lookAt() {
    throw new Error("<Line2>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set lookAt(value) {
    throw new Error("<Line2>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get points() {
    throw new Error("<Line2>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set points(value) {
    throw new Error("<Line2>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get material() {
    throw new Error("<Line2>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set material(value) {
    throw new Error("<Line2>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get line2() {
    return this.$$.ctx[13];
  }
  set line2(value) {
    throw new Error("<Line2>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Line2_default = Line23;

// node_modules/threlte/objects/LineSegments.svelte
function create_default_slot25(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[18].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[29],
    null
  );
  const block = {
    c: function create() {
      if (default_slot)
        default_slot.c();
    },
    l: function claim(nodes) {
      if (default_slot)
        default_slot.l(nodes);
    },
    m: function mount(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty[0] & /*$$scope*/
        536870912)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[29],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[29]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[29],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot25.name,
    type: "slot",
    source: "(48:0) <LineInstance   line={lineSegments}   {position}   {scale}   {rotation}   {lookAt}   {castShadow}   {receiveShadow}   {frustumCulled}   {renderOrder}   {visible}   {interactive}   {ignorePointer}   on:click   on:contextmenu   on:pointerup   on:pointerdown   on:pointerenter   on:pointerleave   on:pointermove   {viewportAware}   bind:inViewport   on:viewportenter   on:viewportleave >",
    ctx
  });
  return block;
}
function create_fragment39(ctx) {
  let lineinstance;
  let updating_inViewport;
  let current;
  function lineinstance_inViewport_binding(value) {
    ctx[19](value);
  }
  let lineinstance_props = {
    line: (
      /*lineSegments*/
      ctx[13]
    ),
    position: (
      /*position*/
      ctx[1]
    ),
    scale: (
      /*scale*/
      ctx[2]
    ),
    rotation: (
      /*rotation*/
      ctx[3]
    ),
    lookAt: (
      /*lookAt*/
      ctx[12]
    ),
    castShadow: (
      /*castShadow*/
      ctx[5]
    ),
    receiveShadow: (
      /*receiveShadow*/
      ctx[6]
    ),
    frustumCulled: (
      /*frustumCulled*/
      ctx[7]
    ),
    renderOrder: (
      /*renderOrder*/
      ctx[8]
    ),
    visible: (
      /*visible*/
      ctx[9]
    ),
    interactive: (
      /*interactive*/
      ctx[10]
    ),
    ignorePointer: (
      /*ignorePointer*/
      ctx[11]
    ),
    viewportAware: (
      /*viewportAware*/
      ctx[4]
    ),
    $$slots: { default: [create_default_slot25] },
    $$scope: { ctx }
  };
  if (
    /*inViewport*/
    ctx[0] !== void 0
  ) {
    lineinstance_props.inViewport = /*inViewport*/
    ctx[0];
  }
  lineinstance = new LineInstance_default({
    props: lineinstance_props,
    $$inline: true
  });
  binding_callbacks.push(() => bind(lineinstance, "inViewport", lineinstance_inViewport_binding));
  lineinstance.$on(
    "click",
    /*click_handler*/
    ctx[20]
  );
  lineinstance.$on(
    "contextmenu",
    /*contextmenu_handler*/
    ctx[21]
  );
  lineinstance.$on(
    "pointerup",
    /*pointerup_handler*/
    ctx[22]
  );
  lineinstance.$on(
    "pointerdown",
    /*pointerdown_handler*/
    ctx[23]
  );
  lineinstance.$on(
    "pointerenter",
    /*pointerenter_handler*/
    ctx[24]
  );
  lineinstance.$on(
    "pointerleave",
    /*pointerleave_handler*/
    ctx[25]
  );
  lineinstance.$on(
    "pointermove",
    /*pointermove_handler*/
    ctx[26]
  );
  lineinstance.$on(
    "viewportenter",
    /*viewportenter_handler*/
    ctx[27]
  );
  lineinstance.$on(
    "viewportleave",
    /*viewportleave_handler*/
    ctx[28]
  );
  const block = {
    c: function create() {
      create_component(lineinstance.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(lineinstance.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(lineinstance, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const lineinstance_changes = {};
      if (dirty[0] & /*position*/
      2)
        lineinstance_changes.position = /*position*/
        ctx2[1];
      if (dirty[0] & /*scale*/
      4)
        lineinstance_changes.scale = /*scale*/
        ctx2[2];
      if (dirty[0] & /*rotation*/
      8)
        lineinstance_changes.rotation = /*rotation*/
        ctx2[3];
      if (dirty[0] & /*lookAt*/
      4096)
        lineinstance_changes.lookAt = /*lookAt*/
        ctx2[12];
      if (dirty[0] & /*castShadow*/
      32)
        lineinstance_changes.castShadow = /*castShadow*/
        ctx2[5];
      if (dirty[0] & /*receiveShadow*/
      64)
        lineinstance_changes.receiveShadow = /*receiveShadow*/
        ctx2[6];
      if (dirty[0] & /*frustumCulled*/
      128)
        lineinstance_changes.frustumCulled = /*frustumCulled*/
        ctx2[7];
      if (dirty[0] & /*renderOrder*/
      256)
        lineinstance_changes.renderOrder = /*renderOrder*/
        ctx2[8];
      if (dirty[0] & /*visible*/
      512)
        lineinstance_changes.visible = /*visible*/
        ctx2[9];
      if (dirty[0] & /*interactive*/
      1024)
        lineinstance_changes.interactive = /*interactive*/
        ctx2[10];
      if (dirty[0] & /*ignorePointer*/
      2048)
        lineinstance_changes.ignorePointer = /*ignorePointer*/
        ctx2[11];
      if (dirty[0] & /*viewportAware*/
      16)
        lineinstance_changes.viewportAware = /*viewportAware*/
        ctx2[4];
      if (dirty[0] & /*$$scope*/
      536870912) {
        lineinstance_changes.$$scope = { dirty, ctx: ctx2 };
      }
      if (!updating_inViewport && dirty[0] & /*inViewport*/
      1) {
        updating_inViewport = true;
        lineinstance_changes.inViewport = /*inViewport*/
        ctx2[0];
        add_flush_callback(() => updating_inViewport = false);
      }
      lineinstance.$set(lineinstance_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(lineinstance.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(lineinstance.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(lineinstance, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment39.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance38($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("LineSegments", slots, ["default"]);
  let { position = void 0 } = $$props;
  let { scale = void 0 } = $$props;
  let { rotation = void 0 } = $$props;
  let { viewportAware = false } = $$props;
  let { inViewport = false } = $$props;
  let { castShadow = void 0 } = $$props;
  let { receiveShadow = void 0 } = $$props;
  let { frustumCulled = void 0 } = $$props;
  let { renderOrder = void 0 } = $$props;
  let { visible = void 0 } = $$props;
  let { interactive = false } = $$props;
  let { ignorePointer = false } = $$props;
  let { lookAt = void 0 } = $$props;
  let { geometry } = $$props;
  let { material } = $$props;
  let previousMaterial = material;
  let previousGeometry = geometry;
  const { invalidate } = useThrelte();
  const lineSegments = new LineSegments(geometry, material);
  const getLineSegments = () => lineSegments;
  $$self.$$.on_mount.push(function() {
    if (geometry === void 0 && !("geometry" in $$props || $$self.$$.bound[$$self.$$.props["geometry"]])) {
      console.warn("<LineSegments> was created without expected prop 'geometry'");
    }
    if (material === void 0 && !("material" in $$props || $$self.$$.bound[$$self.$$.props["material"]])) {
      console.warn("<LineSegments> was created without expected prop 'material'");
    }
  });
  const writable_props = [
    "position",
    "scale",
    "rotation",
    "viewportAware",
    "inViewport",
    "castShadow",
    "receiveShadow",
    "frustumCulled",
    "renderOrder",
    "visible",
    "interactive",
    "ignorePointer",
    "lookAt",
    "geometry",
    "material"
  ];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<LineSegments> was created with unknown prop '${key}'`);
  });
  function lineinstance_inViewport_binding(value) {
    inViewport = value;
    $$invalidate(0, inViewport);
  }
  function click_handler(event) {
    bubble.call(this, $$self, event);
  }
  function contextmenu_handler(event) {
    bubble.call(this, $$self, event);
  }
  function pointerup_handler(event) {
    bubble.call(this, $$self, event);
  }
  function pointerdown_handler(event) {
    bubble.call(this, $$self, event);
  }
  function pointerenter_handler(event) {
    bubble.call(this, $$self, event);
  }
  function pointerleave_handler(event) {
    bubble.call(this, $$self, event);
  }
  function pointermove_handler(event) {
    bubble.call(this, $$self, event);
  }
  function viewportenter_handler(event) {
    bubble.call(this, $$self, event);
  }
  function viewportleave_handler(event) {
    bubble.call(this, $$self, event);
  }
  $$self.$$set = ($$props2) => {
    if ("position" in $$props2)
      $$invalidate(1, position = $$props2.position);
    if ("scale" in $$props2)
      $$invalidate(2, scale = $$props2.scale);
    if ("rotation" in $$props2)
      $$invalidate(3, rotation = $$props2.rotation);
    if ("viewportAware" in $$props2)
      $$invalidate(4, viewportAware = $$props2.viewportAware);
    if ("inViewport" in $$props2)
      $$invalidate(0, inViewport = $$props2.inViewport);
    if ("castShadow" in $$props2)
      $$invalidate(5, castShadow = $$props2.castShadow);
    if ("receiveShadow" in $$props2)
      $$invalidate(6, receiveShadow = $$props2.receiveShadow);
    if ("frustumCulled" in $$props2)
      $$invalidate(7, frustumCulled = $$props2.frustumCulled);
    if ("renderOrder" in $$props2)
      $$invalidate(8, renderOrder = $$props2.renderOrder);
    if ("visible" in $$props2)
      $$invalidate(9, visible = $$props2.visible);
    if ("interactive" in $$props2)
      $$invalidate(10, interactive = $$props2.interactive);
    if ("ignorePointer" in $$props2)
      $$invalidate(11, ignorePointer = $$props2.ignorePointer);
    if ("lookAt" in $$props2)
      $$invalidate(12, lookAt = $$props2.lookAt);
    if ("geometry" in $$props2)
      $$invalidate(14, geometry = $$props2.geometry);
    if ("material" in $$props2)
      $$invalidate(15, material = $$props2.material);
    if ("$$scope" in $$props2)
      $$invalidate(29, $$scope = $$props2.$$scope);
  };
  $$self.$capture_state = () => ({
    ThreeLineSegments: LineSegments,
    useThrelte,
    LineInstance: LineInstance_default,
    position,
    scale,
    rotation,
    viewportAware,
    inViewport,
    castShadow,
    receiveShadow,
    frustumCulled,
    renderOrder,
    visible,
    interactive,
    ignorePointer,
    lookAt,
    geometry,
    material,
    previousMaterial,
    previousGeometry,
    invalidate,
    lineSegments,
    getLineSegments
  });
  $$self.$inject_state = ($$props2) => {
    if ("position" in $$props2)
      $$invalidate(1, position = $$props2.position);
    if ("scale" in $$props2)
      $$invalidate(2, scale = $$props2.scale);
    if ("rotation" in $$props2)
      $$invalidate(3, rotation = $$props2.rotation);
    if ("viewportAware" in $$props2)
      $$invalidate(4, viewportAware = $$props2.viewportAware);
    if ("inViewport" in $$props2)
      $$invalidate(0, inViewport = $$props2.inViewport);
    if ("castShadow" in $$props2)
      $$invalidate(5, castShadow = $$props2.castShadow);
    if ("receiveShadow" in $$props2)
      $$invalidate(6, receiveShadow = $$props2.receiveShadow);
    if ("frustumCulled" in $$props2)
      $$invalidate(7, frustumCulled = $$props2.frustumCulled);
    if ("renderOrder" in $$props2)
      $$invalidate(8, renderOrder = $$props2.renderOrder);
    if ("visible" in $$props2)
      $$invalidate(9, visible = $$props2.visible);
    if ("interactive" in $$props2)
      $$invalidate(10, interactive = $$props2.interactive);
    if ("ignorePointer" in $$props2)
      $$invalidate(11, ignorePointer = $$props2.ignorePointer);
    if ("lookAt" in $$props2)
      $$invalidate(12, lookAt = $$props2.lookAt);
    if ("geometry" in $$props2)
      $$invalidate(14, geometry = $$props2.geometry);
    if ("material" in $$props2)
      $$invalidate(15, material = $$props2.material);
    if ("previousMaterial" in $$props2)
      $$invalidate(16, previousMaterial = $$props2.previousMaterial);
    if ("previousGeometry" in $$props2)
      $$invalidate(17, previousGeometry = $$props2.previousGeometry);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty[0] & /*material, previousMaterial*/
    98304) {
      $: {
        if (material !== previousMaterial) {
          getLineSegments().material = material;
          invalidate("LineSegments: material changed");
        } else {
          invalidate("LineSegments: material props changed");
        }
        $$invalidate(16, previousMaterial = material);
      }
    }
    if ($$self.$$.dirty[0] & /*geometry, previousGeometry*/
    147456) {
      $: {
        if (geometry !== previousGeometry) {
          getLineSegments().geometry = geometry;
          invalidate("LineSegments: geometry changed");
        } else {
          invalidate("LineSegments: geometry props changed");
        }
        $$invalidate(17, previousGeometry = geometry);
      }
    }
  };
  return [
    inViewport,
    position,
    scale,
    rotation,
    viewportAware,
    castShadow,
    receiveShadow,
    frustumCulled,
    renderOrder,
    visible,
    interactive,
    ignorePointer,
    lookAt,
    lineSegments,
    geometry,
    material,
    previousMaterial,
    previousGeometry,
    slots,
    lineinstance_inViewport_binding,
    click_handler,
    contextmenu_handler,
    pointerup_handler,
    pointerdown_handler,
    pointerenter_handler,
    pointerleave_handler,
    pointermove_handler,
    viewportenter_handler,
    viewportleave_handler,
    $$scope
  ];
}
var LineSegments3 = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(
      this,
      options,
      instance38,
      create_fragment39,
      safe_not_equal,
      {
        position: 1,
        scale: 2,
        rotation: 3,
        viewportAware: 4,
        inViewport: 0,
        castShadow: 5,
        receiveShadow: 6,
        frustumCulled: 7,
        renderOrder: 8,
        visible: 9,
        interactive: 10,
        ignorePointer: 11,
        lookAt: 12,
        geometry: 14,
        material: 15,
        lineSegments: 13
      },
      null,
      [-1, -1]
    );
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "LineSegments",
      options,
      id: create_fragment39.name
    });
  }
  get position() {
    throw new Error("<LineSegments>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set position(value) {
    throw new Error("<LineSegments>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get scale() {
    throw new Error("<LineSegments>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set scale(value) {
    throw new Error("<LineSegments>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get rotation() {
    throw new Error("<LineSegments>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set rotation(value) {
    throw new Error("<LineSegments>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get viewportAware() {
    throw new Error("<LineSegments>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set viewportAware(value) {
    throw new Error("<LineSegments>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get inViewport() {
    throw new Error("<LineSegments>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set inViewport(value) {
    throw new Error("<LineSegments>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get castShadow() {
    throw new Error("<LineSegments>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set castShadow(value) {
    throw new Error("<LineSegments>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get receiveShadow() {
    throw new Error("<LineSegments>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set receiveShadow(value) {
    throw new Error("<LineSegments>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get frustumCulled() {
    throw new Error("<LineSegments>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set frustumCulled(value) {
    throw new Error("<LineSegments>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get renderOrder() {
    throw new Error("<LineSegments>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set renderOrder(value) {
    throw new Error("<LineSegments>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get visible() {
    throw new Error("<LineSegments>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set visible(value) {
    throw new Error("<LineSegments>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get interactive() {
    throw new Error("<LineSegments>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set interactive(value) {
    throw new Error("<LineSegments>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get ignorePointer() {
    throw new Error("<LineSegments>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set ignorePointer(value) {
    throw new Error("<LineSegments>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get lookAt() {
    throw new Error("<LineSegments>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set lookAt(value) {
    throw new Error("<LineSegments>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get geometry() {
    throw new Error("<LineSegments>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set geometry(value) {
    throw new Error("<LineSegments>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get material() {
    throw new Error("<LineSegments>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set material(value) {
    throw new Error("<LineSegments>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get lineSegments() {
    return this.$$.ctx[13];
  }
  set lineSegments(value) {
    throw new Error("<LineSegments>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var LineSegments_default = LineSegments3;

// node_modules/troika-worker-utils/dist/troika-worker-utils.esm.js
function BespokeThenable() {
  var state = 0;
  var queue = [];
  var value;
  var scheduled = 0;
  var completeCalled = 0;
  function then(onResolve, onReject) {
    var nextThenable = BespokeThenable();
    function handleNext() {
      var cb = state > 0 ? onResolve : onReject;
      if (isFn(cb)) {
        try {
          var result = cb(value);
          if (result === nextThenable) {
            recursiveError();
          }
          var resultThen = getThenableThen(result);
          if (resultThen) {
            resultThen.call(result, nextThenable.resolve, nextThenable.reject);
          } else {
            nextThenable.resolve(result);
          }
        } catch (err) {
          nextThenable.reject(err);
        }
      } else {
        nextThenable[state > 0 ? "resolve" : "reject"](value);
      }
    }
    queue.push(handleNext);
    if (state) {
      scheduleQueueFlush();
    }
    return nextThenable;
  }
  var resolve = oneTime(function(val) {
    if (!completeCalled) {
      complete(1, val);
    }
  });
  var reject = oneTime(function(reason) {
    if (!completeCalled) {
      complete(-1, reason);
    }
  });
  function complete(st, val) {
    completeCalled++;
    var ignoreThrow = 0;
    try {
      if (val === thenableObj) {
        recursiveError();
      }
      var valThen = st > 0 && getThenableThen(val);
      if (valThen) {
        valThen.call(val, oneTime(function(v) {
          ignoreThrow++;
          complete(1, v);
        }), oneTime(function(v) {
          ignoreThrow++;
          complete(-1, v);
        }));
      } else {
        state = st;
        value = val;
        scheduleQueueFlush();
      }
    } catch (e) {
      if (!state && !ignoreThrow) {
        complete(-1, e);
      }
    }
  }
  function scheduleQueueFlush() {
    if (!scheduled) {
      setTimeout(flushQueue, 0);
      scheduled = 1;
    }
  }
  function flushQueue() {
    var q = queue;
    scheduled = 0;
    queue = [];
    q.forEach(callIt);
  }
  function callIt(fn) {
    fn();
  }
  function getThenableThen(val) {
    var valThen = val && (isFn(val) || typeof val === "object") && val.then;
    return isFn(valThen) && valThen;
  }
  function oneTime(fn) {
    var called = 0;
    return function() {
      var args = [], len = arguments.length;
      while (len--)
        args[len] = arguments[len];
      if (!called++) {
        fn.apply(this, args);
      }
    };
  }
  function recursiveError() {
    throw new TypeError("Chaining cycle detected");
  }
  var isFn = function(v) {
    return typeof v === "function";
  };
  var thenableObj = {
    then,
    resolve,
    reject
  };
  return thenableObj;
}
function NativePromiseThenable() {
  var resolve, reject;
  var promise = new Promise(function(res, rej) {
    resolve = res;
    reject = rej;
  });
  return {
    then: promise.then.bind(promise),
    resolve,
    reject
  };
}
BespokeThenable.all = NativePromiseThenable.all = function(items) {
  var resultCount = 0;
  var results = [];
  var out = DefaultThenable();
  if (items.length === 0) {
    out.resolve([]);
  } else {
    items.forEach(function(item, i) {
      var itemThenable = DefaultThenable();
      itemThenable.resolve(item);
      itemThenable.then(function(res) {
        resultCount++;
        results[i] = res;
        if (resultCount === items.length) {
          out.resolve(results);
        }
      }, out.reject);
    });
  }
  return out;
};
var DefaultThenable = typeof Promise === "function" ? NativePromiseThenable : BespokeThenable;
function workerBootstrap() {
  var modules = /* @__PURE__ */ Object.create(null);
  function registerModule(ref, callback) {
    var id = ref.id;
    var name = ref.name;
    var dependencies = ref.dependencies;
    if (dependencies === void 0)
      dependencies = [];
    var init2 = ref.init;
    if (init2 === void 0)
      init2 = function() {
      };
    var getTransferables = ref.getTransferables;
    if (getTransferables === void 0)
      getTransferables = null;
    if (modules[id]) {
      return;
    }
    try {
      dependencies = dependencies.map(function(dep) {
        if (dep && dep.isWorkerModule) {
          registerModule(dep, function(depResult) {
            if (depResult instanceof Error) {
              throw depResult;
            }
          });
          dep = modules[dep.id].value;
        }
        return dep;
      });
      init2 = rehydrate("<" + name + ">.init", init2);
      if (getTransferables) {
        getTransferables = rehydrate("<" + name + ">.getTransferables", getTransferables);
      }
      var value = null;
      if (typeof init2 === "function") {
        value = init2.apply(void 0, dependencies);
      } else {
        console.error("worker module init function failed to rehydrate");
      }
      modules[id] = {
        id,
        value,
        getTransferables
      };
      callback(value);
    } catch (err) {
      if (!(err && err.noLog)) {
        console.error(err);
      }
      callback(err);
    }
  }
  function callModule(ref, callback) {
    var ref$1;
    var id = ref.id;
    var args = ref.args;
    if (!modules[id] || typeof modules[id].value !== "function") {
      callback(new Error("Worker module " + id + ": not found or its 'init' did not return a function"));
    }
    try {
      var result = (ref$1 = modules[id]).value.apply(ref$1, args);
      if (result && typeof result.then === "function") {
        result.then(handleResult, function(rej) {
          return callback(rej instanceof Error ? rej : new Error("" + rej));
        });
      } else {
        handleResult(result);
      }
    } catch (err) {
      callback(err);
    }
    function handleResult(result2) {
      try {
        var tx = modules[id].getTransferables && modules[id].getTransferables(result2);
        if (!tx || !Array.isArray(tx) || !tx.length) {
          tx = void 0;
        }
        callback(result2, tx);
      } catch (err) {
        console.error(err);
        callback(err);
      }
    }
  }
  function rehydrate(name, str) {
    var result = void 0;
    self.troikaDefine = function(r) {
      return result = r;
    };
    var url = URL.createObjectURL(
      new Blob(
        ["/** " + name.replace(/\*/g, "") + " **/\n\ntroikaDefine(\n" + str + "\n)"],
        { type: "application/javascript" }
      )
    );
    try {
      importScripts(url);
    } catch (err) {
      console.error(err);
    }
    URL.revokeObjectURL(url);
    delete self.troikaDefine;
    return result;
  }
  self.addEventListener("message", function(e) {
    var ref = e.data;
    var messageId = ref.messageId;
    var action = ref.action;
    var data = ref.data;
    try {
      if (action === "registerModule") {
        registerModule(data, function(result) {
          if (result instanceof Error) {
            postMessage({
              messageId,
              success: false,
              error: result.message
            });
          } else {
            postMessage({
              messageId,
              success: true,
              result: { isCallable: typeof result === "function" }
            });
          }
        });
      }
      if (action === "callModule") {
        callModule(data, function(result, transferables) {
          if (result instanceof Error) {
            postMessage({
              messageId,
              success: false,
              error: result.message
            });
          } else {
            postMessage({
              messageId,
              success: true,
              result
            }, transferables || void 0);
          }
        });
      }
    } catch (err) {
      postMessage({
        messageId,
        success: false,
        error: err.stack
      });
    }
  });
}
function defineMainThreadModule(options) {
  var moduleFunc = function() {
    var args = [], len = arguments.length;
    while (len--)
      args[len] = arguments[len];
    return moduleFunc._getInitResult().then(function(initResult) {
      if (typeof initResult === "function") {
        return initResult.apply(void 0, args);
      } else {
        throw new Error("Worker module function was called but `init` did not return a callable function");
      }
    });
  };
  moduleFunc._getInitResult = function() {
    var dependencies = options.dependencies;
    var init2 = options.init;
    dependencies = Array.isArray(dependencies) ? dependencies.map(
      function(dep) {
        return dep && dep._getInitResult ? dep._getInitResult() : dep;
      }
    ) : [];
    var initThenable = DefaultThenable.all(dependencies).then(function(deps) {
      return init2.apply(null, deps);
    });
    moduleFunc._getInitResult = function() {
      return initThenable;
    };
    return initThenable;
  };
  return moduleFunc;
}
var supportsWorkers = function() {
  var supported = false;
  if (typeof window !== "undefined" && typeof window.document !== "undefined") {
    try {
      var worker = new Worker(
        URL.createObjectURL(new Blob([""], { type: "application/javascript" }))
      );
      worker.terminate();
      supported = true;
    } catch (err) {
      if (typeof process !== "undefined" && false)
        ;
      else {
        console.log(
          "Troika createWorkerModule: web workers not allowed; falling back to main thread execution. Cause: [" + err.message + "]"
        );
      }
    }
  }
  supportsWorkers = function() {
    return supported;
  };
  return supported;
};
var _workerModuleId = 0;
var _messageId = 0;
var _allowInitAsString = false;
var workers = /* @__PURE__ */ Object.create(null);
var registeredModules = /* @__PURE__ */ Object.create(null);
var openRequests = /* @__PURE__ */ Object.create(null);
function defineWorkerModule(options) {
  if ((!options || typeof options.init !== "function") && !_allowInitAsString) {
    throw new Error("requires `options.init` function");
  }
  var dependencies = options.dependencies;
  var init2 = options.init;
  var getTransferables = options.getTransferables;
  var workerId = options.workerId;
  if (!supportsWorkers()) {
    return defineMainThreadModule(options);
  }
  if (workerId == null) {
    workerId = "#default";
  }
  var id = "workerModule" + ++_workerModuleId;
  var name = options.name || id;
  var registrationThenable = null;
  dependencies = dependencies && dependencies.map(function(dep) {
    if (typeof dep === "function" && !dep.workerModuleData) {
      _allowInitAsString = true;
      dep = defineWorkerModule({
        workerId,
        name: "<" + name + "> function dependency: " + dep.name,
        init: "function(){return (\n" + stringifyFunction(dep) + "\n)}"
      });
      _allowInitAsString = false;
    }
    if (dep && dep.workerModuleData) {
      dep = dep.workerModuleData;
    }
    return dep;
  });
  function moduleFunc() {
    var args = [], len = arguments.length;
    while (len--)
      args[len] = arguments[len];
    if (!registrationThenable) {
      registrationThenable = callWorker(workerId, "registerModule", moduleFunc.workerModuleData);
      var unregister = function() {
        registrationThenable = null;
        registeredModules[workerId].delete(unregister);
      };
      (registeredModules[workerId] || (registeredModules[workerId] = /* @__PURE__ */ new Set())).add(unregister);
    }
    return registrationThenable.then(function(ref) {
      var isCallable = ref.isCallable;
      if (isCallable) {
        return callWorker(workerId, "callModule", { id, args });
      } else {
        throw new Error("Worker module function was called but `init` did not return a callable function");
      }
    });
  }
  moduleFunc.workerModuleData = {
    isWorkerModule: true,
    id,
    name,
    dependencies,
    init: stringifyFunction(init2),
    getTransferables: getTransferables && stringifyFunction(getTransferables)
  };
  return moduleFunc;
}
function terminateWorker(workerId) {
  if (registeredModules[workerId]) {
    registeredModules[workerId].forEach(function(unregister) {
      unregister();
    });
  }
  if (workers[workerId]) {
    workers[workerId].terminate();
    delete workers[workerId];
  }
}
function stringifyFunction(fn) {
  var str = fn.toString();
  if (!/^function/.test(str) && /^\w+\s*\(/.test(str)) {
    str = "function " + str;
  }
  return str;
}
function getWorker(workerId) {
  var worker = workers[workerId];
  if (!worker) {
    var bootstrap = stringifyFunction(workerBootstrap);
    worker = workers[workerId] = new Worker(
      URL.createObjectURL(
        new Blob(
          ["/** Worker Module Bootstrap: " + workerId.replace(/\*/g, "") + " **/\n\n;(" + bootstrap + ")()"],
          { type: "application/javascript" }
        )
      )
    );
    worker.onmessage = function(e) {
      var response = e.data;
      var msgId = response.messageId;
      var callback = openRequests[msgId];
      if (!callback) {
        throw new Error("WorkerModule response with empty or unknown messageId");
      }
      delete openRequests[msgId];
      callback(response);
    };
  }
  return worker;
}
function callWorker(workerId, action, data) {
  var thenable = DefaultThenable();
  var messageId = ++_messageId;
  openRequests[messageId] = function(response) {
    if (response.success) {
      thenable.resolve(response.result);
    } else {
      thenable.reject(new Error("Error in worker " + action + " call: " + response.error));
    }
  };
  getWorker(workerId).postMessage({
    messageId,
    action,
    data
  });
  return thenable;
}
var ThenableWorkerModule = defineWorkerModule({
  name: "Thenable",
  dependencies: [DefaultThenable],
  init: function(Thenable) {
    return Thenable;
  }
});

// node_modules/webgl-sdf-generator/dist/webgl-sdf-generator.mjs
function SDFGenerator() {
  var exports = function(exports2) {
    function pointOnQuadraticBezier(x0, y0, x1, y1, x2, y2, t2, pointOut) {
      var t22 = 1 - t2;
      pointOut.x = t22 * t22 * x0 + 2 * t22 * t2 * x1 + t2 * t2 * x2;
      pointOut.y = t22 * t22 * y0 + 2 * t22 * t2 * y1 + t2 * t2 * y2;
    }
    function pointOnCubicBezier(x0, y0, x1, y1, x2, y2, x3, y3, t2, pointOut) {
      var t22 = 1 - t2;
      pointOut.x = t22 * t22 * t22 * x0 + 3 * t22 * t22 * t2 * x1 + 3 * t22 * t2 * t2 * x2 + t2 * t2 * t2 * x3;
      pointOut.y = t22 * t22 * t22 * y0 + 3 * t22 * t22 * t2 * y1 + 3 * t22 * t2 * t2 * y2 + t2 * t2 * t2 * y3;
    }
    function forEachPathCommand(pathString, commandCallback) {
      var segmentRE = /([MLQCZ])([^MLQCZ]*)/g;
      var match, firstX, firstY, prevX, prevY;
      while (match = segmentRE.exec(pathString)) {
        var args = match[2].replace(/^\s*|\s*$/g, "").split(/[,\s]+/).map(function(v) {
          return parseFloat(v);
        });
        switch (match[1]) {
          case "M":
            prevX = firstX = args[0];
            prevY = firstY = args[1];
            break;
          case "L":
            if (args[0] !== prevX || args[1] !== prevY) {
              commandCallback("L", prevX, prevY, prevX = args[0], prevY = args[1]);
            }
            break;
          case "Q": {
            commandCallback("Q", prevX, prevY, prevX = args[2], prevY = args[3], args[0], args[1]);
            break;
          }
          case "C": {
            commandCallback("C", prevX, prevY, prevX = args[4], prevY = args[5], args[0], args[1], args[2], args[3]);
            break;
          }
          case "Z":
            if (prevX !== firstX || prevY !== firstY) {
              commandCallback("L", prevX, prevY, firstX, firstY);
            }
            break;
        }
      }
    }
    function pathToLineSegments(pathString, segmentCallback, curvePoints) {
      if (curvePoints === void 0)
        curvePoints = 16;
      var tempPoint = { x: 0, y: 0 };
      forEachPathCommand(pathString, function(command, startX, startY, endX, endY, ctrl1X, ctrl1Y, ctrl2X, ctrl2Y) {
        switch (command) {
          case "L":
            segmentCallback(startX, startY, endX, endY);
            break;
          case "Q": {
            var prevCurveX = startX;
            var prevCurveY = startY;
            for (var i = 1; i < curvePoints; i++) {
              pointOnQuadraticBezier(
                startX,
                startY,
                ctrl1X,
                ctrl1Y,
                endX,
                endY,
                i / (curvePoints - 1),
                tempPoint
              );
              segmentCallback(prevCurveX, prevCurveY, tempPoint.x, tempPoint.y);
              prevCurveX = tempPoint.x;
              prevCurveY = tempPoint.y;
            }
            break;
          }
          case "C": {
            var prevCurveX$1 = startX;
            var prevCurveY$1 = startY;
            for (var i$1 = 1; i$1 < curvePoints; i$1++) {
              pointOnCubicBezier(
                startX,
                startY,
                ctrl1X,
                ctrl1Y,
                ctrl2X,
                ctrl2Y,
                endX,
                endY,
                i$1 / (curvePoints - 1),
                tempPoint
              );
              segmentCallback(prevCurveX$1, prevCurveY$1, tempPoint.x, tempPoint.y);
              prevCurveX$1 = tempPoint.x;
              prevCurveY$1 = tempPoint.y;
            }
            break;
          }
        }
      });
    }
    var viewportQuadVertex = "precision highp float;attribute vec2 aUV;varying vec2 vUV;void main(){vUV=aUV;gl_Position=vec4(mix(vec2(-1.0),vec2(1.0),aUV),0.0,1.0);}";
    var copyTexFragment = "precision highp float;uniform sampler2D tex;varying vec2 vUV;void main(){gl_FragColor=texture2D(tex,vUV);}";
    var cache = /* @__PURE__ */ new WeakMap();
    var glContextParams = {
      premultipliedAlpha: false,
      preserveDrawingBuffer: true,
      antialias: false,
      depth: false
    };
    function withWebGLContext(glOrCanvas, callback) {
      var gl = glOrCanvas.getContext ? glOrCanvas.getContext("webgl", glContextParams) : glOrCanvas;
      var wrapper = cache.get(gl);
      if (!wrapper) {
        let getExtension = function(name) {
          var ext = extensions[name];
          if (!ext) {
            ext = extensions[name] = gl.getExtension(name);
            if (!ext) {
              throw new Error(name + " not supported");
            }
          }
          return ext;
        }, compileShader = function(src, type) {
          var shader = gl.createShader(type);
          gl.shaderSource(shader, src);
          gl.compileShader(shader);
          return shader;
        }, withProgram = function(name, vert, frag, func) {
          if (!programs[name]) {
            var attributes = {};
            var uniforms = {};
            var program = gl.createProgram();
            gl.attachShader(program, compileShader(vert, gl.VERTEX_SHADER));
            gl.attachShader(program, compileShader(frag, gl.FRAGMENT_SHADER));
            gl.linkProgram(program);
            programs[name] = {
              program,
              transaction: function transaction(func2) {
                gl.useProgram(program);
                func2({
                  setUniform: function setUniform(type, name2) {
                    var values = [], len = arguments.length - 2;
                    while (len-- > 0)
                      values[len] = arguments[len + 2];
                    var uniformLoc = uniforms[name2] || (uniforms[name2] = gl.getUniformLocation(program, name2));
                    gl["uniform" + type].apply(gl, [uniformLoc].concat(values));
                  },
                  setAttribute: function setAttribute(name2, size, usage, instancingDivisor, data) {
                    var attr = attributes[name2];
                    if (!attr) {
                      attr = attributes[name2] = {
                        buf: gl.createBuffer(),
                        // TODO should we destroy our buffers?
                        loc: gl.getAttribLocation(program, name2),
                        data: null
                      };
                    }
                    gl.bindBuffer(gl.ARRAY_BUFFER, attr.buf);
                    gl.vertexAttribPointer(attr.loc, size, gl.FLOAT, false, 0, 0);
                    gl.enableVertexAttribArray(attr.loc);
                    if (isWebGL2) {
                      gl.vertexAttribDivisor(attr.loc, instancingDivisor);
                    } else {
                      getExtension("ANGLE_instanced_arrays").vertexAttribDivisorANGLE(attr.loc, instancingDivisor);
                    }
                    if (data !== attr.data) {
                      gl.bufferData(gl.ARRAY_BUFFER, data, usage);
                      attr.data = data;
                    }
                  }
                });
              }
            };
          }
          programs[name].transaction(func);
        }, withTexture = function(name, func) {
          textureUnit++;
          try {
            gl.activeTexture(gl.TEXTURE0 + textureUnit);
            var texture = textures[name];
            if (!texture) {
              texture = textures[name] = gl.createTexture();
              gl.bindTexture(gl.TEXTURE_2D, texture);
              gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
              gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
            }
            gl.bindTexture(gl.TEXTURE_2D, texture);
            func(texture, textureUnit);
          } finally {
            textureUnit--;
          }
        }, withTextureFramebuffer = function(texture, textureUnit2, func) {
          var framebuffer = gl.createFramebuffer();
          framebufferStack.push(framebuffer);
          gl.bindFramebuffer(gl.FRAMEBUFFER, framebuffer);
          gl.activeTexture(gl.TEXTURE0 + textureUnit2);
          gl.bindTexture(gl.TEXTURE_2D, texture);
          gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, texture, 0);
          try {
            func(framebuffer);
          } finally {
            gl.deleteFramebuffer(framebuffer);
            gl.bindFramebuffer(gl.FRAMEBUFFER, framebufferStack[--framebufferStack.length - 1] || null);
          }
        }, handleContextLoss = function() {
          extensions = {};
          programs = {};
          textures = {};
          textureUnit = -1;
          framebufferStack.length = 0;
        };
        var isWebGL2 = typeof WebGL2RenderingContext !== "undefined" && gl instanceof WebGL2RenderingContext;
        var extensions = {};
        var programs = {};
        var textures = {};
        var textureUnit = -1;
        var framebufferStack = [];
        gl.canvas.addEventListener("webglcontextlost", function(e) {
          handleContextLoss();
          e.preventDefault();
        }, false);
        cache.set(gl, wrapper = {
          gl,
          isWebGL2,
          getExtension,
          withProgram,
          withTexture,
          withTextureFramebuffer,
          handleContextLoss
        });
      }
      callback(wrapper);
    }
    function renderImageData(glOrCanvas, imageData, x2, y, width, height, channels, framebuffer) {
      if (channels === void 0)
        channels = 15;
      if (framebuffer === void 0)
        framebuffer = null;
      withWebGLContext(glOrCanvas, function(ref) {
        var gl = ref.gl;
        var withProgram = ref.withProgram;
        var withTexture = ref.withTexture;
        withTexture("copy", function(tex, texUnit) {
          gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, width, height, 0, gl.RGBA, gl.UNSIGNED_BYTE, imageData);
          withProgram("copy", viewportQuadVertex, copyTexFragment, function(ref2) {
            var setUniform = ref2.setUniform;
            var setAttribute = ref2.setAttribute;
            setAttribute("aUV", 2, gl.STATIC_DRAW, 0, new Float32Array([0, 0, 2, 0, 0, 2]));
            setUniform("1i", "image", texUnit);
            gl.bindFramebuffer(gl.FRAMEBUFFER, framebuffer || null);
            gl.disable(gl.BLEND);
            gl.colorMask(channels & 8, channels & 4, channels & 2, channels & 1);
            gl.viewport(x2, y, width, height);
            gl.scissor(x2, y, width, height);
            gl.drawArrays(gl.TRIANGLES, 0, 3);
          });
        });
      });
    }
    function resizeWebGLCanvasWithoutClearing2(canvas, newWidth, newHeight) {
      var width = canvas.width;
      var height = canvas.height;
      withWebGLContext(canvas, function(ref) {
        var gl = ref.gl;
        var data = new Uint8Array(width * height * 4);
        gl.readPixels(0, 0, width, height, gl.RGBA, gl.UNSIGNED_BYTE, data);
        canvas.width = newWidth;
        canvas.height = newHeight;
        renderImageData(gl, data, 0, 0, width, height);
      });
    }
    var webglUtils = Object.freeze({
      __proto__: null,
      withWebGLContext,
      renderImageData,
      resizeWebGLCanvasWithoutClearing: resizeWebGLCanvasWithoutClearing2
    });
    function generate$2(sdfWidth, sdfHeight, path, viewBox, maxDistance, sdfExponent) {
      if (sdfExponent === void 0)
        sdfExponent = 1;
      var textureData = new Uint8Array(sdfWidth * sdfHeight);
      var viewBoxWidth = viewBox[2] - viewBox[0];
      var viewBoxHeight = viewBox[3] - viewBox[1];
      var segments = [];
      pathToLineSegments(path, function(x1, y1, x2, y2) {
        segments.push({
          x1,
          y1,
          x2,
          y2,
          minX: Math.min(x1, x2),
          minY: Math.min(y1, y2),
          maxX: Math.max(x1, x2),
          maxY: Math.max(y1, y2)
        });
      });
      segments.sort(function(a, b) {
        return a.maxX - b.maxX;
      });
      for (var sdfX = 0; sdfX < sdfWidth; sdfX++) {
        for (var sdfY = 0; sdfY < sdfHeight; sdfY++) {
          var signedDist = findNearestSignedDistance(
            viewBox[0] + viewBoxWidth * (sdfX + 0.5) / sdfWidth,
            viewBox[1] + viewBoxHeight * (sdfY + 0.5) / sdfHeight
          );
          var alpha = Math.pow(1 - Math.abs(signedDist) / maxDistance, sdfExponent) / 2;
          if (signedDist < 0) {
            alpha = 1 - alpha;
          }
          alpha = Math.max(0, Math.min(255, Math.round(alpha * 255)));
          textureData[sdfY * sdfWidth + sdfX] = alpha;
        }
      }
      return textureData;
      function findNearestSignedDistance(x2, y) {
        var closestDistSq = Infinity;
        var closestDist = Infinity;
        for (var i = segments.length; i--; ) {
          var seg = segments[i];
          if (seg.maxX + closestDist <= x2) {
            break;
          }
          if (x2 + closestDist > seg.minX && y - closestDist < seg.maxY && y + closestDist > seg.minY) {
            var distSq = absSquareDistanceToLineSegment(x2, y, seg.x1, seg.y1, seg.x2, seg.y2);
            if (distSq < closestDistSq) {
              closestDistSq = distSq;
              closestDist = Math.sqrt(closestDistSq);
            }
          }
        }
        if (isPointInPoly(x2, y)) {
          closestDist = -closestDist;
        }
        return closestDist;
      }
      function isPointInPoly(x2, y) {
        var winding = 0;
        for (var i = segments.length; i--; ) {
          var seg = segments[i];
          if (seg.maxX <= x2) {
            break;
          }
          var intersects = seg.y1 > y !== seg.y2 > y && x2 < (seg.x2 - seg.x1) * (y - seg.y1) / (seg.y2 - seg.y1) + seg.x1;
          if (intersects) {
            winding += seg.y1 < seg.y2 ? 1 : -1;
          }
        }
        return winding !== 0;
      }
    }
    function generateIntoCanvas$2(sdfWidth, sdfHeight, path, viewBox, maxDistance, sdfExponent, canvas, x2, y, channel) {
      if (sdfExponent === void 0)
        sdfExponent = 1;
      if (x2 === void 0)
        x2 = 0;
      if (y === void 0)
        y = 0;
      if (channel === void 0)
        channel = 0;
      generateIntoFramebuffer$1(sdfWidth, sdfHeight, path, viewBox, maxDistance, sdfExponent, canvas, null, x2, y, channel);
    }
    function generateIntoFramebuffer$1(sdfWidth, sdfHeight, path, viewBox, maxDistance, sdfExponent, glOrCanvas, framebuffer, x2, y, channel) {
      if (sdfExponent === void 0)
        sdfExponent = 1;
      if (x2 === void 0)
        x2 = 0;
      if (y === void 0)
        y = 0;
      if (channel === void 0)
        channel = 0;
      var data = generate$2(sdfWidth, sdfHeight, path, viewBox, maxDistance, sdfExponent);
      var rgbaData = new Uint8Array(data.length * 4);
      for (var i = 0; i < data.length; i++) {
        rgbaData[i * 4 + channel] = data[i];
      }
      renderImageData(glOrCanvas, rgbaData, x2, y, sdfWidth, sdfHeight, 1 << 3 - channel, framebuffer);
    }
    function absSquareDistanceToLineSegment(x2, y, lineX0, lineY0, lineX1, lineY1) {
      var ldx = lineX1 - lineX0;
      var ldy = lineY1 - lineY0;
      var lengthSq = ldx * ldx + ldy * ldy;
      var t2 = lengthSq ? Math.max(0, Math.min(1, ((x2 - lineX0) * ldx + (y - lineY0) * ldy) / lengthSq)) : 0;
      var dx = x2 - (lineX0 + t2 * ldx);
      var dy = y - (lineY0 + t2 * ldy);
      return dx * dx + dy * dy;
    }
    var javascript = Object.freeze({
      __proto__: null,
      generate: generate$2,
      generateIntoCanvas: generateIntoCanvas$2,
      generateIntoFramebuffer: generateIntoFramebuffer$1
    });
    var mainVertex = "precision highp float;uniform vec4 uGlyphBounds;attribute vec2 aUV;attribute vec4 aLineSegment;varying vec4 vLineSegment;varying vec2 vGlyphXY;void main(){vLineSegment=aLineSegment;vGlyphXY=mix(uGlyphBounds.xy,uGlyphBounds.zw,aUV);gl_Position=vec4(mix(vec2(-1.0),vec2(1.0),aUV),0.0,1.0);}";
    var mainFragment = "precision highp float;uniform vec4 uGlyphBounds;uniform float uMaxDistance;uniform float uExponent;varying vec4 vLineSegment;varying vec2 vGlyphXY;float absDistToSegment(vec2 point,vec2 lineA,vec2 lineB){vec2 lineDir=lineB-lineA;float lenSq=dot(lineDir,lineDir);float t=lenSq==0.0 ? 0.0 : clamp(dot(point-lineA,lineDir)/lenSq,0.0,1.0);vec2 linePt=lineA+t*lineDir;return distance(point,linePt);}void main(){vec4 seg=vLineSegment;vec2 p=vGlyphXY;float dist=absDistToSegment(p,seg.xy,seg.zw);float val=pow(1.0-clamp(dist/uMaxDistance,0.0,1.0),uExponent)*0.5;bool crossing=(seg.y>p.y!=seg.w>p.y)&&(p.x<(seg.z-seg.x)*(p.y-seg.y)/(seg.w-seg.y)+seg.x);bool crossingUp=crossing&&vLineSegment.y<vLineSegment.w;gl_FragColor=vec4(crossingUp ? 1.0/255.0 : 0.0,crossing&&!crossingUp ? 1.0/255.0 : 0.0,0.0,val);}";
    var postFragment = "precision highp float;uniform sampler2D tex;varying vec2 vUV;void main(){vec4 color=texture2D(tex,vUV);bool inside=color.r!=color.g;float val=inside ? 1.0-color.a : color.a;gl_FragColor=vec4(val);}";
    var viewportUVs = new Float32Array([0, 0, 2, 0, 0, 2]);
    var implicitContext = null;
    var isTestingSupport = false;
    var NULL_OBJECT = {};
    var supportByCanvas = /* @__PURE__ */ new WeakMap();
    function validateSupport(glOrCanvas) {
      if (!isTestingSupport && !isSupported(glOrCanvas)) {
        throw new Error("WebGL generation not supported");
      }
    }
    function generate$1(sdfWidth, sdfHeight, path, viewBox, maxDistance, sdfExponent, glOrCanvas) {
      if (sdfExponent === void 0)
        sdfExponent = 1;
      if (glOrCanvas === void 0)
        glOrCanvas = null;
      if (!glOrCanvas) {
        glOrCanvas = implicitContext;
        if (!glOrCanvas) {
          var canvas = typeof OffscreenCanvas === "function" ? new OffscreenCanvas(1, 1) : typeof document !== "undefined" ? document.createElement("canvas") : null;
          if (!canvas) {
            throw new Error("OffscreenCanvas or DOM canvas not supported");
          }
          glOrCanvas = implicitContext = canvas.getContext("webgl", { depth: false });
        }
      }
      validateSupport(glOrCanvas);
      var rgbaData = new Uint8Array(sdfWidth * sdfHeight * 4);
      withWebGLContext(glOrCanvas, function(ref) {
        var gl = ref.gl;
        var withTexture = ref.withTexture;
        var withTextureFramebuffer = ref.withTextureFramebuffer;
        withTexture("readable", function(texture, textureUnit) {
          gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, sdfWidth, sdfHeight, 0, gl.RGBA, gl.UNSIGNED_BYTE, null);
          withTextureFramebuffer(texture, textureUnit, function(framebuffer) {
            generateIntoFramebuffer(
              sdfWidth,
              sdfHeight,
              path,
              viewBox,
              maxDistance,
              sdfExponent,
              gl,
              framebuffer,
              0,
              0,
              0
              // red channel
            );
            gl.readPixels(0, 0, sdfWidth, sdfHeight, gl.RGBA, gl.UNSIGNED_BYTE, rgbaData);
          });
        });
      });
      var data = new Uint8Array(sdfWidth * sdfHeight);
      for (var i = 0, j = 0; i < rgbaData.length; i += 4) {
        data[j++] = rgbaData[i];
      }
      return data;
    }
    function generateIntoCanvas$1(sdfWidth, sdfHeight, path, viewBox, maxDistance, sdfExponent, canvas, x2, y, channel) {
      if (sdfExponent === void 0)
        sdfExponent = 1;
      if (x2 === void 0)
        x2 = 0;
      if (y === void 0)
        y = 0;
      if (channel === void 0)
        channel = 0;
      generateIntoFramebuffer(sdfWidth, sdfHeight, path, viewBox, maxDistance, sdfExponent, canvas, null, x2, y, channel);
    }
    function generateIntoFramebuffer(sdfWidth, sdfHeight, path, viewBox, maxDistance, sdfExponent, glOrCanvas, framebuffer, x2, y, channel) {
      if (sdfExponent === void 0)
        sdfExponent = 1;
      if (x2 === void 0)
        x2 = 0;
      if (y === void 0)
        y = 0;
      if (channel === void 0)
        channel = 0;
      validateSupport(glOrCanvas);
      var lineSegmentCoords = [];
      pathToLineSegments(path, function(x1, y1, x22, y2) {
        lineSegmentCoords.push(x1, y1, x22, y2);
      });
      lineSegmentCoords = new Float32Array(lineSegmentCoords);
      withWebGLContext(glOrCanvas, function(ref) {
        var gl = ref.gl;
        var isWebGL2 = ref.isWebGL2;
        var getExtension = ref.getExtension;
        var withProgram = ref.withProgram;
        var withTexture = ref.withTexture;
        var withTextureFramebuffer = ref.withTextureFramebuffer;
        var handleContextLoss = ref.handleContextLoss;
        withTexture("rawDistances", function(intermediateTexture, intermediateTextureUnit) {
          if (sdfWidth !== intermediateTexture._lastWidth || sdfHeight !== intermediateTexture._lastHeight) {
            gl.texImage2D(
              gl.TEXTURE_2D,
              0,
              gl.RGBA,
              intermediateTexture._lastWidth = sdfWidth,
              intermediateTexture._lastHeight = sdfHeight,
              0,
              gl.RGBA,
              gl.UNSIGNED_BYTE,
              null
            );
          }
          withProgram("main", mainVertex, mainFragment, function(ref2) {
            var setAttribute = ref2.setAttribute;
            var setUniform = ref2.setUniform;
            var instancingExtension = !isWebGL2 && getExtension("ANGLE_instanced_arrays");
            var blendMinMaxExtension = !isWebGL2 && getExtension("EXT_blend_minmax");
            setAttribute("aUV", 2, gl.STATIC_DRAW, 0, viewportUVs);
            setAttribute("aLineSegment", 4, gl.DYNAMIC_DRAW, 1, lineSegmentCoords);
            setUniform.apply(void 0, ["4f", "uGlyphBounds"].concat(viewBox));
            setUniform("1f", "uMaxDistance", maxDistance);
            setUniform("1f", "uExponent", sdfExponent);
            withTextureFramebuffer(intermediateTexture, intermediateTextureUnit, function(framebuffer2) {
              gl.enable(gl.BLEND);
              gl.colorMask(true, true, true, true);
              gl.viewport(0, 0, sdfWidth, sdfHeight);
              gl.scissor(0, 0, sdfWidth, sdfHeight);
              gl.blendFunc(gl.ONE, gl.ONE);
              gl.blendEquationSeparate(gl.FUNC_ADD, isWebGL2 ? gl.MAX : blendMinMaxExtension.MAX_EXT);
              gl.clear(gl.COLOR_BUFFER_BIT);
              if (isWebGL2) {
                gl.drawArraysInstanced(gl.TRIANGLES, 0, 3, lineSegmentCoords.length / 4);
              } else {
                instancingExtension.drawArraysInstancedANGLE(gl.TRIANGLES, 0, 3, lineSegmentCoords.length / 4);
              }
            });
          });
          withProgram("post", viewportQuadVertex, postFragment, function(program) {
            program.setAttribute("aUV", 2, gl.STATIC_DRAW, 0, viewportUVs);
            program.setUniform("1i", "tex", intermediateTextureUnit);
            gl.bindFramebuffer(gl.FRAMEBUFFER, framebuffer);
            gl.disable(gl.BLEND);
            gl.colorMask(channel === 0, channel === 1, channel === 2, channel === 3);
            gl.viewport(x2, y, sdfWidth, sdfHeight);
            gl.scissor(x2, y, sdfWidth, sdfHeight);
            gl.drawArrays(gl.TRIANGLES, 0, 3);
          });
        });
        if (gl.isContextLost()) {
          handleContextLoss();
          throw new Error("webgl context lost");
        }
      });
    }
    function isSupported(glOrCanvas) {
      var key = !glOrCanvas || glOrCanvas === implicitContext ? NULL_OBJECT : glOrCanvas.canvas || glOrCanvas;
      var supported = supportByCanvas.get(key);
      if (supported === void 0) {
        isTestingSupport = true;
        var failReason = null;
        try {
          var expectedResult = [
            97,
            106,
            97,
            61,
            99,
            137,
            118,
            80,
            80,
            118,
            137,
            99,
            61,
            97,
            106,
            97
          ];
          var testResult = generate$1(
            4,
            4,
            "M8,8L16,8L24,24L16,24Z",
            [0, 0, 32, 32],
            24,
            1,
            glOrCanvas
          );
          supported = testResult && expectedResult.length === testResult.length && testResult.every(function(val, i) {
            return val === expectedResult[i];
          });
          if (!supported) {
            failReason = "bad trial run results";
            console.info(expectedResult, testResult);
          }
        } catch (err) {
          supported = false;
          failReason = err.message;
        }
        if (failReason) {
          console.warn("WebGL SDF generation not supported:", failReason);
        }
        isTestingSupport = false;
        supportByCanvas.set(key, supported);
      }
      return supported;
    }
    var webgl = Object.freeze({
      __proto__: null,
      generate: generate$1,
      generateIntoCanvas: generateIntoCanvas$1,
      generateIntoFramebuffer,
      isSupported
    });
    function generate(sdfWidth, sdfHeight, path, viewBox, maxDistance, sdfExponent) {
      if (maxDistance === void 0)
        maxDistance = Math.max(viewBox[2] - viewBox[0], viewBox[3] - viewBox[1]) / 2;
      if (sdfExponent === void 0)
        sdfExponent = 1;
      try {
        return generate$1.apply(webgl, arguments);
      } catch (e) {
        console.info("WebGL SDF generation failed, falling back to JS", e);
        return generate$2.apply(javascript, arguments);
      }
    }
    function generateIntoCanvas(sdfWidth, sdfHeight, path, viewBox, maxDistance, sdfExponent, canvas, x2, y, channel) {
      if (maxDistance === void 0)
        maxDistance = Math.max(viewBox[2] - viewBox[0], viewBox[3] - viewBox[1]) / 2;
      if (sdfExponent === void 0)
        sdfExponent = 1;
      if (x2 === void 0)
        x2 = 0;
      if (y === void 0)
        y = 0;
      if (channel === void 0)
        channel = 0;
      try {
        return generateIntoCanvas$1.apply(webgl, arguments);
      } catch (e) {
        console.info("WebGL SDF generation failed, falling back to JS", e);
        return generateIntoCanvas$2.apply(javascript, arguments);
      }
    }
    exports2.forEachPathCommand = forEachPathCommand;
    exports2.generate = generate;
    exports2.generateIntoCanvas = generateIntoCanvas;
    exports2.javascript = javascript;
    exports2.pathToLineSegments = pathToLineSegments;
    exports2.webgl = webgl;
    exports2.webglUtils = webglUtils;
    Object.defineProperty(exports2, "__esModule", { value: true });
    return exports2;
  }({});
  return exports;
}

// node_modules/bidi-js/dist/bidi.mjs
function bidiFactory() {
  var bidi = function(exports) {
    var DATA = {
      "R": "13k,1a,2,3,3,2+1j,ch+16,a+1,5+2,2+n,5,a,4,6+16,4+3,h+1b,4mo,179q,2+9,2+11,2i9+7y,2+68,4,3+4,5+13,4+3,2+4k,3+29,8+cf,1t+7z,w+17,3+3m,1t+3z,16o1+5r,8+30,8+mc,29+1r,29+4v,75+73",
      "EN": "1c+9,3d+1,6,187+9,513,4+5,7+9,sf+j,175h+9,qw+q,161f+1d,4xt+a,25i+9",
      "ES": "17,2,6dp+1,f+1,av,16vr,mx+1,4o,2",
      "ET": "z+2,3h+3,b+1,ym,3e+1,2o,p4+1,8,6u,7c,g6,1wc,1n9+4,30+1b,2n,6d,qhx+1,h0m,a+1,49+2,63+1,4+1,6bb+3,12jj",
      "AN": "16o+5,2j+9,2+1,35,ed,1ff2+9,87+u",
      "CS": "18,2+1,b,2u,12k,55v,l,17v0,2,3,53,2+1,b",
      "B": "a,3,f+2,2v,690",
      "S": "9,2,k",
      "WS": "c,k,4f4,1vk+a,u,1j,335",
      "ON": "x+1,4+4,h+5,r+5,r+3,z,5+3,2+1,2+1,5,2+2,3+4,o,w,ci+1,8+d,3+d,6+8,2+g,39+1,9,6+1,2,33,b8,3+1,3c+1,7+1,5r,b,7h+3,sa+5,2,3i+6,jg+3,ur+9,2v,ij+1,9g+9,7+a,8m,4+1,49+x,14u,2+2,c+2,e+2,e+2,e+1,i+n,e+e,2+p,u+2,e+2,36+1,2+3,2+1,b,2+2,6+5,2,2,2,h+1,5+4,6+3,3+f,16+2,5+3l,3+81,1y+p,2+40,q+a,m+13,2r+ch,2+9e,75+hf,3+v,2+2w,6e+5,f+6,75+2a,1a+p,2+2g,d+5x,r+b,6+3,4+o,g,6+1,6+2,2k+1,4,2j,5h+z,1m+1,1e+f,t+2,1f+e,d+3,4o+3,2s+1,w,535+1r,h3l+1i,93+2,2s,b+1,3l+x,2v,4g+3,21+3,kz+1,g5v+1,5a,j+9,n+v,2,3,2+8,2+1,3+2,2,3,46+1,4+4,h+5,r+5,r+a,3h+2,4+6,b+4,78,1r+24,4+c,4,1hb,ey+6,103+j,16j+c,1ux+7,5+g,fsh,jdq+1t,4,57+2e,p1,1m,1m,1m,1m,4kt+1,7j+17,5+2r,d+e,3+e,2+e,2+10,m+4,w,1n+5,1q,4z+5,4b+rb,9+c,4+c,4+37,d+2g,8+b,l+b,5+1j,9+9,7+13,9+t,3+1,27+3c,2+29,2+3q,d+d,3+4,4+2,6+6,a+o,8+6,a+2,e+6,16+42,2+1i",
      "BN": "0+8,6+d,2s+5,2+p,e,4m9,1kt+2,2b+5,5+5,17q9+v,7k,6p+8,6+1,119d+3,440+7,96s+1,1ekf+1,1ekf+1,1ekf+1,1ekf+1,1ekf+1,1ekf+1,1ekf+1,1ekf+1,1ekf+1,1ekf+1,1ekf+1,1ekf+75,6p+2rz,1ben+1,1ekf+1,1ekf+1",
      "NSM": "lc+33,7o+6,7c+18,2,2+1,2+1,2,21+a,1d+k,h,2u+6,3+5,3+1,2+3,10,v+q,2k+a,1n+8,a,p+3,2+8,2+2,2+4,18+2,3c+e,2+v,1k,2,5+7,5,4+6,b+1,u,1n,5+3,9,l+1,r,3+1,1m,5+1,5+1,3+2,4,v+1,4,c+1,1m,5+4,2+1,5,l+1,n+5,2,1n,3,2+3,9,8+1,c+1,v,1q,d,1f,4,1m+2,6+2,2+3,8+1,c+1,u,1n,g+1,l+1,t+1,1m+1,5+3,9,l+1,u,21,8+2,2,2j,3+6,d+7,2r,3+8,c+5,23+1,s,2,2,1k+d,2+4,2+1,6+a,2+z,a,2v+3,2+5,2+1,3+1,q+1,5+2,h+3,e,3+1,7,g,jk+2,qb+2,u+2,u+1,v+1,1t+1,2+6,9,3+a,a,1a+2,3c+1,z,3b+2,5+1,a,7+2,64+1,3,1n,2+6,2,2,3+7,7+9,3,1d+g,1s+3,1d,2+4,2,6,15+8,d+1,x+3,3+1,2+2,1l,2+1,4,2+2,1n+7,3+1,49+2,2+c,2+6,5,7,4+1,5j+1l,2+4,k1+w,2db+2,3y,2p+v,ff+3,30+1,n9x+3,2+9,x+1,29+1,7l,4,5,q+1,6,48+1,r+h,e,13+7,q+a,1b+2,1d,3+3,3+1,14,1w+5,3+1,3+1,d,9,1c,1g,2+2,3+1,6+1,2,17+1,9,6n,3,5,fn5,ki+f,h+f,r2,6b,46+4,1af+2,2+1,6+3,15+2,5,4m+1,fy+3,as+1,4a+a,4x,1j+e,1l+2,1e+3,3+1,1y+2,11+4,2+7,1r,d+1,1h+8,b+3,3,2o+2,3,2+1,7,4h,4+7,m+1,1m+1,4,12+6,4+4,5g+7,3+2,2,o,2d+5,2,5+1,2+1,6n+3,7+1,2+1,s+1,2e+7,3,2+1,2z,2,3+5,2,2u+2,3+3,2+4,78+8,2+1,75+1,2,5,41+3,3+1,5,x+5,3+1,15+5,3+3,9,a+5,3+2,1b+c,2+1,bb+6,2+5,2d+l,3+6,2+1,2+1,3f+5,4,2+1,2+6,2,21+1,4,2,9o+1,f0c+4,1o+6,t5,1s+3,2a,f5l+1,43t+2,i+7,3+6,v+3,45+2,1j0+1i,5+1d,9,f,n+4,2+e,11t+6,2+g,3+6,2+1,2+4,7a+6,c6+3,15t+6,32+6,gzhy+6n",
      "AL": "16w,3,2,e+1b,z+2,2+2s,g+1,8+1,b+m,2+t,s+2i,c+e,4h+f,1d+1e,1bwe+dp,3+3z,x+c,2+1,35+3y,2rm+z,5+7,b+5,dt+l,c+u,17nl+27,1t+27,4x+6n,3+d",
      "LRO": "6ct",
      "RLO": "6cu",
      "LRE": "6cq",
      "RLE": "6cr",
      "PDF": "6cs",
      "LRI": "6ee",
      "RLI": "6ef",
      "FSI": "6eg",
      "PDI": "6eh"
    };
    var TYPES = {};
    var TYPES_TO_NAMES = {};
    TYPES.L = 1;
    TYPES_TO_NAMES[1] = "L";
    Object.keys(DATA).forEach(function(type, i) {
      TYPES[type] = 1 << i + 1;
      TYPES_TO_NAMES[TYPES[type]] = type;
    });
    Object.freeze(TYPES);
    var ISOLATE_INIT_TYPES = TYPES.LRI | TYPES.RLI | TYPES.FSI;
    var STRONG_TYPES = TYPES.L | TYPES.R | TYPES.AL;
    var NEUTRAL_ISOLATE_TYPES = TYPES.B | TYPES.S | TYPES.WS | TYPES.ON | TYPES.FSI | TYPES.LRI | TYPES.RLI | TYPES.PDI;
    var BN_LIKE_TYPES = TYPES.BN | TYPES.RLE | TYPES.LRE | TYPES.RLO | TYPES.LRO | TYPES.PDF;
    var TRAILING_TYPES = TYPES.S | TYPES.WS | TYPES.B | ISOLATE_INIT_TYPES | TYPES.PDI | BN_LIKE_TYPES;
    var map = null;
    function parseData() {
      if (!map) {
        map = /* @__PURE__ */ new Map();
        var loop = function(type2) {
          if (DATA.hasOwnProperty(type2)) {
            var lastCode = 0;
            DATA[type2].split(",").forEach(function(range) {
              var ref = range.split("+");
              var skip = ref[0];
              var step = ref[1];
              skip = parseInt(skip, 36);
              step = step ? parseInt(step, 36) : 0;
              map.set(lastCode += skip, TYPES[type2]);
              for (var i = 0; i < step; i++) {
                map.set(++lastCode, TYPES[type2]);
              }
            });
          }
        };
        for (var type in DATA)
          loop(type);
      }
    }
    function getBidiCharType(char) {
      parseData();
      return map.get(char.codePointAt(0)) || TYPES.L;
    }
    function getBidiCharTypeName(char) {
      return TYPES_TO_NAMES[getBidiCharType(char)];
    }
    var data$1 = {
      "pairs": "14>1,1e>2,u>2,2wt>1,1>1,1ge>1,1wp>1,1j>1,f>1,hm>1,1>1,u>1,u6>1,1>1,+5,28>1,w>1,1>1,+3,b8>1,1>1,+3,1>3,-1>-1,3>1,1>1,+2,1s>1,1>1,x>1,th>1,1>1,+2,db>1,1>1,+3,3>1,1>1,+2,14qm>1,1>1,+1,4q>1,1e>2,u>2,2>1,+1",
      "canonical": "6f1>-6dx,6dy>-6dx,6ec>-6ed,6ee>-6ed,6ww>2jj,-2ji>2jj,14r4>-1e7l,1e7m>-1e7l,1e7m>-1e5c,1e5d>-1e5b,1e5c>-14qx,14qy>-14qx,14vn>-1ecg,1ech>-1ecg,1edu>-1ecg,1eci>-1ecg,1eda>-1ecg,1eci>-1ecg,1eci>-168q,168r>-168q,168s>-14ye,14yf>-14ye"
    };
    function parseCharacterMap(encodedString, includeReverse) {
      var radix = 36;
      var lastCode = 0;
      var map2 = /* @__PURE__ */ new Map();
      var reverseMap = includeReverse && /* @__PURE__ */ new Map();
      var prevPair;
      encodedString.split(",").forEach(function visit(entry) {
        if (entry.indexOf("+") !== -1) {
          for (var i = +entry; i--; ) {
            visit(prevPair);
          }
        } else {
          prevPair = entry;
          var ref = entry.split(">");
          var a = ref[0];
          var b = ref[1];
          a = String.fromCodePoint(lastCode += parseInt(a, radix));
          b = String.fromCodePoint(lastCode += parseInt(b, radix));
          map2.set(a, b);
          includeReverse && reverseMap.set(b, a);
        }
      });
      return { map: map2, reverseMap };
    }
    var openToClose, closeToOpen, canonical;
    function parse$1() {
      if (!openToClose) {
        var ref = parseCharacterMap(data$1.pairs, true);
        var map2 = ref.map;
        var reverseMap = ref.reverseMap;
        openToClose = map2;
        closeToOpen = reverseMap;
        canonical = parseCharacterMap(data$1.canonical, false).map;
      }
    }
    function openingToClosingBracket(char) {
      parse$1();
      return openToClose.get(char) || null;
    }
    function closingToOpeningBracket(char) {
      parse$1();
      return closeToOpen.get(char) || null;
    }
    function getCanonicalBracket(char) {
      parse$1();
      return canonical.get(char) || null;
    }
    var TYPE_L = TYPES.L;
    var TYPE_R = TYPES.R;
    var TYPE_EN = TYPES.EN;
    var TYPE_ES = TYPES.ES;
    var TYPE_ET = TYPES.ET;
    var TYPE_AN = TYPES.AN;
    var TYPE_CS = TYPES.CS;
    var TYPE_B = TYPES.B;
    var TYPE_S = TYPES.S;
    var TYPE_ON = TYPES.ON;
    var TYPE_BN = TYPES.BN;
    var TYPE_NSM = TYPES.NSM;
    var TYPE_AL = TYPES.AL;
    var TYPE_LRO = TYPES.LRO;
    var TYPE_RLO = TYPES.RLO;
    var TYPE_LRE = TYPES.LRE;
    var TYPE_RLE = TYPES.RLE;
    var TYPE_PDF = TYPES.PDF;
    var TYPE_LRI = TYPES.LRI;
    var TYPE_RLI = TYPES.RLI;
    var TYPE_FSI = TYPES.FSI;
    var TYPE_PDI = TYPES.PDI;
    function getEmbeddingLevels(string, baseDirection) {
      var MAX_DEPTH = 125;
      var charTypes = new Uint32Array(string.length);
      for (var i = 0; i < string.length; i++) {
        charTypes[i] = getBidiCharType(string[i]);
      }
      var charTypeCounts = /* @__PURE__ */ new Map();
      function changeCharType(i2, type2) {
        var oldType = charTypes[i2];
        charTypes[i2] = type2;
        charTypeCounts.set(oldType, charTypeCounts.get(oldType) - 1);
        if (oldType & NEUTRAL_ISOLATE_TYPES) {
          charTypeCounts.set(NEUTRAL_ISOLATE_TYPES, charTypeCounts.get(NEUTRAL_ISOLATE_TYPES) - 1);
        }
        charTypeCounts.set(type2, (charTypeCounts.get(type2) || 0) + 1);
        if (type2 & NEUTRAL_ISOLATE_TYPES) {
          charTypeCounts.set(NEUTRAL_ISOLATE_TYPES, (charTypeCounts.get(NEUTRAL_ISOLATE_TYPES) || 0) + 1);
        }
      }
      var embedLevels = new Uint8Array(string.length);
      var isolationPairs = /* @__PURE__ */ new Map();
      var paragraphs = [];
      var paragraph = null;
      for (var i$1 = 0; i$1 < string.length; i$1++) {
        if (!paragraph) {
          paragraphs.push(paragraph = {
            start: i$1,
            end: string.length - 1,
            // 3.3.1 P2-P3: Determine the paragraph level
            level: baseDirection === "rtl" ? 1 : baseDirection === "ltr" ? 0 : determineAutoEmbedLevel(i$1, false)
          });
        }
        if (charTypes[i$1] & TYPE_B) {
          paragraph.end = i$1;
          paragraph = null;
        }
      }
      var FORMATTING_TYPES = TYPE_RLE | TYPE_LRE | TYPE_RLO | TYPE_LRO | ISOLATE_INIT_TYPES | TYPE_PDI | TYPE_PDF | TYPE_B;
      var nextEven = function(n2) {
        return n2 + (n2 & 1 ? 1 : 2);
      };
      var nextOdd = function(n2) {
        return n2 + (n2 & 1 ? 2 : 1);
      };
      for (var paraIdx = 0; paraIdx < paragraphs.length; paraIdx++) {
        paragraph = paragraphs[paraIdx];
        var statusStack = [{
          _level: paragraph.level,
          _override: 0,
          //0=neutral, 1=L, 2=R
          _isolate: 0
          //bool
        }];
        var stackTop = void 0;
        var overflowIsolateCount = 0;
        var overflowEmbeddingCount = 0;
        var validIsolateCount = 0;
        charTypeCounts.clear();
        for (var i$2 = paragraph.start; i$2 <= paragraph.end; i$2++) {
          var charType = charTypes[i$2];
          stackTop = statusStack[statusStack.length - 1];
          charTypeCounts.set(charType, (charTypeCounts.get(charType) || 0) + 1);
          if (charType & NEUTRAL_ISOLATE_TYPES) {
            charTypeCounts.set(NEUTRAL_ISOLATE_TYPES, (charTypeCounts.get(NEUTRAL_ISOLATE_TYPES) || 0) + 1);
          }
          if (charType & FORMATTING_TYPES) {
            if (charType & (TYPE_RLE | TYPE_LRE)) {
              embedLevels[i$2] = stackTop._level;
              var level = (charType === TYPE_RLE ? nextOdd : nextEven)(stackTop._level);
              if (level <= MAX_DEPTH && !overflowIsolateCount && !overflowEmbeddingCount) {
                statusStack.push({
                  _level: level,
                  _override: 0,
                  _isolate: 0
                });
              } else if (!overflowIsolateCount) {
                overflowEmbeddingCount++;
              }
            } else if (charType & (TYPE_RLO | TYPE_LRO)) {
              embedLevels[i$2] = stackTop._level;
              var level$1 = (charType === TYPE_RLO ? nextOdd : nextEven)(stackTop._level);
              if (level$1 <= MAX_DEPTH && !overflowIsolateCount && !overflowEmbeddingCount) {
                statusStack.push({
                  _level: level$1,
                  _override: charType & TYPE_RLO ? TYPE_R : TYPE_L,
                  _isolate: 0
                });
              } else if (!overflowIsolateCount) {
                overflowEmbeddingCount++;
              }
            } else if (charType & ISOLATE_INIT_TYPES) {
              if (charType & TYPE_FSI) {
                charType = determineAutoEmbedLevel(i$2 + 1, true) === 1 ? TYPE_RLI : TYPE_LRI;
              }
              embedLevels[i$2] = stackTop._level;
              if (stackTop._override) {
                changeCharType(i$2, stackTop._override);
              }
              var level$2 = (charType === TYPE_RLI ? nextOdd : nextEven)(stackTop._level);
              if (level$2 <= MAX_DEPTH && overflowIsolateCount === 0 && overflowEmbeddingCount === 0) {
                validIsolateCount++;
                statusStack.push({
                  _level: level$2,
                  _override: 0,
                  _isolate: 1,
                  _isolInitIndex: i$2
                });
              } else {
                overflowIsolateCount++;
              }
            } else if (charType & TYPE_PDI) {
              if (overflowIsolateCount > 0) {
                overflowIsolateCount--;
              } else if (validIsolateCount > 0) {
                overflowEmbeddingCount = 0;
                while (!statusStack[statusStack.length - 1]._isolate) {
                  statusStack.pop();
                }
                var isolInitIndex = statusStack[statusStack.length - 1]._isolInitIndex;
                if (isolInitIndex != null) {
                  isolationPairs.set(isolInitIndex, i$2);
                  isolationPairs.set(i$2, isolInitIndex);
                }
                statusStack.pop();
                validIsolateCount--;
              }
              stackTop = statusStack[statusStack.length - 1];
              embedLevels[i$2] = stackTop._level;
              if (stackTop._override) {
                changeCharType(i$2, stackTop._override);
              }
            } else if (charType & TYPE_PDF) {
              if (overflowIsolateCount === 0) {
                if (overflowEmbeddingCount > 0) {
                  overflowEmbeddingCount--;
                } else if (!stackTop._isolate && statusStack.length > 1) {
                  statusStack.pop();
                  stackTop = statusStack[statusStack.length - 1];
                }
              }
              embedLevels[i$2] = stackTop._level;
            } else if (charType & TYPE_B) {
              embedLevels[i$2] = paragraph.level;
            }
          } else {
            embedLevels[i$2] = stackTop._level;
            if (stackTop._override && charType !== TYPE_BN) {
              changeCharType(i$2, stackTop._override);
            }
          }
        }
        var levelRuns = [];
        var currentRun = null;
        for (var i$3 = paragraph.start; i$3 <= paragraph.end; i$3++) {
          var charType$1 = charTypes[i$3];
          if (!(charType$1 & BN_LIKE_TYPES)) {
            var lvl = embedLevels[i$3];
            var isIsolInit = charType$1 & ISOLATE_INIT_TYPES;
            var isPDI = charType$1 === TYPE_PDI;
            if (currentRun && lvl === currentRun._level) {
              currentRun._end = i$3;
              currentRun._endsWithIsolInit = isIsolInit;
            } else {
              levelRuns.push(currentRun = {
                _start: i$3,
                _end: i$3,
                _level: lvl,
                _startsWithPDI: isPDI,
                _endsWithIsolInit: isIsolInit
              });
            }
          }
        }
        var isolatingRunSeqs = [];
        for (var runIdx = 0; runIdx < levelRuns.length; runIdx++) {
          var run = levelRuns[runIdx];
          if (!run._startsWithPDI || run._startsWithPDI && !isolationPairs.has(run._start)) {
            var seqRuns = [currentRun = run];
            for (var pdiIndex = void 0; currentRun && currentRun._endsWithIsolInit && (pdiIndex = isolationPairs.get(currentRun._end)) != null; ) {
              for (var i$4 = runIdx + 1; i$4 < levelRuns.length; i$4++) {
                if (levelRuns[i$4]._start === pdiIndex) {
                  seqRuns.push(currentRun = levelRuns[i$4]);
                  break;
                }
              }
            }
            var seqIndices = [];
            for (var i$5 = 0; i$5 < seqRuns.length; i$5++) {
              var run$1 = seqRuns[i$5];
              for (var j = run$1._start; j <= run$1._end; j++) {
                seqIndices.push(j);
              }
            }
            var firstLevel = embedLevels[seqIndices[0]];
            var prevLevel = paragraph.level;
            for (var i$6 = seqIndices[0] - 1; i$6 >= 0; i$6--) {
              if (!(charTypes[i$6] & BN_LIKE_TYPES)) {
                prevLevel = embedLevels[i$6];
                break;
              }
            }
            var lastIndex = seqIndices[seqIndices.length - 1];
            var lastLevel = embedLevels[lastIndex];
            var nextLevel = paragraph.level;
            if (!(charTypes[lastIndex] & ISOLATE_INIT_TYPES)) {
              for (var i$7 = lastIndex + 1; i$7 <= paragraph.end; i$7++) {
                if (!(charTypes[i$7] & BN_LIKE_TYPES)) {
                  nextLevel = embedLevels[i$7];
                  break;
                }
              }
            }
            isolatingRunSeqs.push({
              _seqIndices: seqIndices,
              _sosType: Math.max(prevLevel, firstLevel) % 2 ? TYPE_R : TYPE_L,
              _eosType: Math.max(nextLevel, lastLevel) % 2 ? TYPE_R : TYPE_L
            });
          }
        }
        for (var seqIdx = 0; seqIdx < isolatingRunSeqs.length; seqIdx++) {
          var ref = isolatingRunSeqs[seqIdx];
          var seqIndices$1 = ref._seqIndices;
          var sosType = ref._sosType;
          var eosType = ref._eosType;
          if (charTypeCounts.get(TYPE_NSM)) {
            for (var si = 0; si < seqIndices$1.length; si++) {
              var i$8 = seqIndices$1[si];
              if (charTypes[i$8] & TYPE_NSM) {
                var prevType = sosType;
                for (var sj = si - 1; sj >= 0; sj--) {
                  if (!(charTypes[seqIndices$1[sj]] & BN_LIKE_TYPES)) {
                    prevType = charTypes[seqIndices$1[sj]];
                    break;
                  }
                }
                changeCharType(i$8, prevType & (ISOLATE_INIT_TYPES | TYPE_PDI) ? TYPE_ON : prevType);
              }
            }
          }
          if (charTypeCounts.get(TYPE_EN)) {
            for (var si$1 = 0; si$1 < seqIndices$1.length; si$1++) {
              var i$9 = seqIndices$1[si$1];
              if (charTypes[i$9] & TYPE_EN) {
                for (var sj$1 = si$1 - 1; sj$1 >= -1; sj$1--) {
                  var prevCharType = sj$1 === -1 ? sosType : charTypes[seqIndices$1[sj$1]];
                  if (prevCharType & STRONG_TYPES) {
                    if (prevCharType === TYPE_AL) {
                      changeCharType(i$9, TYPE_AN);
                    }
                    break;
                  }
                }
              }
            }
          }
          if (charTypeCounts.get(TYPE_AL)) {
            for (var si$2 = 0; si$2 < seqIndices$1.length; si$2++) {
              var i$10 = seqIndices$1[si$2];
              if (charTypes[i$10] & TYPE_AL) {
                changeCharType(i$10, TYPE_R);
              }
            }
          }
          if (charTypeCounts.get(TYPE_ES) || charTypeCounts.get(TYPE_CS)) {
            for (var si$3 = 1; si$3 < seqIndices$1.length - 1; si$3++) {
              var i$11 = seqIndices$1[si$3];
              if (charTypes[i$11] & (TYPE_ES | TYPE_CS)) {
                var prevType$1 = 0, nextType = 0;
                for (var sj$2 = si$3 - 1; sj$2 >= 0; sj$2--) {
                  prevType$1 = charTypes[seqIndices$1[sj$2]];
                  if (!(prevType$1 & BN_LIKE_TYPES)) {
                    break;
                  }
                }
                for (var sj$3 = si$3 + 1; sj$3 < seqIndices$1.length; sj$3++) {
                  nextType = charTypes[seqIndices$1[sj$3]];
                  if (!(nextType & BN_LIKE_TYPES)) {
                    break;
                  }
                }
                if (prevType$1 === nextType && (charTypes[i$11] === TYPE_ES ? prevType$1 === TYPE_EN : prevType$1 & (TYPE_EN | TYPE_AN))) {
                  changeCharType(i$11, prevType$1);
                }
              }
            }
          }
          if (charTypeCounts.get(TYPE_EN)) {
            for (var si$4 = 0; si$4 < seqIndices$1.length; si$4++) {
              var i$12 = seqIndices$1[si$4];
              if (charTypes[i$12] & TYPE_EN) {
                for (var sj$4 = si$4 - 1; sj$4 >= 0 && charTypes[seqIndices$1[sj$4]] & (TYPE_ET | BN_LIKE_TYPES); sj$4--) {
                  changeCharType(seqIndices$1[sj$4], TYPE_EN);
                }
                for (var sj$5 = si$4 + 1; sj$5 < seqIndices$1.length && charTypes[seqIndices$1[sj$5]] & (TYPE_ET | BN_LIKE_TYPES); sj$5++) {
                  changeCharType(seqIndices$1[sj$5], TYPE_EN);
                }
              }
            }
          }
          if (charTypeCounts.get(TYPE_ET) || charTypeCounts.get(TYPE_ES) || charTypeCounts.get(TYPE_CS)) {
            for (var si$5 = 0; si$5 < seqIndices$1.length; si$5++) {
              var i$13 = seqIndices$1[si$5];
              if (charTypes[i$13] & (TYPE_ET | TYPE_ES | TYPE_CS)) {
                changeCharType(i$13, TYPE_ON);
                for (var sj$6 = si$5 - 1; sj$6 >= 0 && charTypes[seqIndices$1[sj$6]] & BN_LIKE_TYPES; sj$6--) {
                  changeCharType(seqIndices$1[sj$6], TYPE_ON);
                }
                for (var sj$7 = si$5 + 1; sj$7 < seqIndices$1.length && charTypes[seqIndices$1[sj$7]] & BN_LIKE_TYPES; sj$7++) {
                  changeCharType(seqIndices$1[sj$7], TYPE_ON);
                }
              }
            }
          }
          if (charTypeCounts.get(TYPE_EN)) {
            for (var si$6 = 0, prevStrongType = sosType; si$6 < seqIndices$1.length; si$6++) {
              var i$14 = seqIndices$1[si$6];
              var type = charTypes[i$14];
              if (type & TYPE_EN) {
                if (prevStrongType === TYPE_L) {
                  changeCharType(i$14, TYPE_L);
                }
              } else if (type & STRONG_TYPES) {
                prevStrongType = type;
              }
            }
          }
          if (charTypeCounts.get(NEUTRAL_ISOLATE_TYPES)) {
            var R_TYPES_FOR_N_STEPS = TYPE_R | TYPE_EN | TYPE_AN;
            var STRONG_TYPES_FOR_N_STEPS = R_TYPES_FOR_N_STEPS | TYPE_L;
            var bracketPairs = [];
            {
              var openerStack = [];
              for (var si$7 = 0; si$7 < seqIndices$1.length; si$7++) {
                if (charTypes[seqIndices$1[si$7]] & NEUTRAL_ISOLATE_TYPES) {
                  var char = string[seqIndices$1[si$7]];
                  var oppositeBracket = void 0;
                  if (openingToClosingBracket(char) !== null) {
                    if (openerStack.length < 63) {
                      openerStack.push({ char, seqIndex: si$7 });
                    } else {
                      break;
                    }
                  } else if ((oppositeBracket = closingToOpeningBracket(char)) !== null) {
                    for (var stackIdx = openerStack.length - 1; stackIdx >= 0; stackIdx--) {
                      var stackChar = openerStack[stackIdx].char;
                      if (stackChar === oppositeBracket || stackChar === closingToOpeningBracket(getCanonicalBracket(char)) || openingToClosingBracket(getCanonicalBracket(stackChar)) === char) {
                        bracketPairs.push([openerStack[stackIdx].seqIndex, si$7]);
                        openerStack.length = stackIdx;
                        break;
                      }
                    }
                  }
                }
              }
              bracketPairs.sort(function(a, b) {
                return a[0] - b[0];
              });
            }
            for (var pairIdx = 0; pairIdx < bracketPairs.length; pairIdx++) {
              var ref$1 = bracketPairs[pairIdx];
              var openSeqIdx = ref$1[0];
              var closeSeqIdx = ref$1[1];
              var foundStrongType = false;
              var useStrongType = 0;
              for (var si$8 = openSeqIdx + 1; si$8 < closeSeqIdx; si$8++) {
                var i$15 = seqIndices$1[si$8];
                if (charTypes[i$15] & STRONG_TYPES_FOR_N_STEPS) {
                  foundStrongType = true;
                  var lr = charTypes[i$15] & R_TYPES_FOR_N_STEPS ? TYPE_R : TYPE_L;
                  if (lr === getEmbedDirection(i$15)) {
                    useStrongType = lr;
                    break;
                  }
                }
              }
              if (foundStrongType && !useStrongType) {
                useStrongType = sosType;
                for (var si$9 = openSeqIdx - 1; si$9 >= 0; si$9--) {
                  var i$16 = seqIndices$1[si$9];
                  if (charTypes[i$16] & STRONG_TYPES_FOR_N_STEPS) {
                    var lr$1 = charTypes[i$16] & R_TYPES_FOR_N_STEPS ? TYPE_R : TYPE_L;
                    if (lr$1 !== getEmbedDirection(i$16)) {
                      useStrongType = lr$1;
                    } else {
                      useStrongType = getEmbedDirection(i$16);
                    }
                    break;
                  }
                }
              }
              if (useStrongType) {
                charTypes[seqIndices$1[openSeqIdx]] = charTypes[seqIndices$1[closeSeqIdx]] = useStrongType;
                if (useStrongType !== getEmbedDirection(seqIndices$1[openSeqIdx])) {
                  for (var si$10 = openSeqIdx + 1; si$10 < seqIndices$1.length; si$10++) {
                    if (!(charTypes[seqIndices$1[si$10]] & BN_LIKE_TYPES)) {
                      if (getBidiCharType(string[seqIndices$1[si$10]]) & TYPE_NSM) {
                        charTypes[seqIndices$1[si$10]] = useStrongType;
                      }
                      break;
                    }
                  }
                }
                if (useStrongType !== getEmbedDirection(seqIndices$1[closeSeqIdx])) {
                  for (var si$11 = closeSeqIdx + 1; si$11 < seqIndices$1.length; si$11++) {
                    if (!(charTypes[seqIndices$1[si$11]] & BN_LIKE_TYPES)) {
                      if (getBidiCharType(string[seqIndices$1[si$11]]) & TYPE_NSM) {
                        charTypes[seqIndices$1[si$11]] = useStrongType;
                      }
                      break;
                    }
                  }
                }
              }
            }
            for (var si$12 = 0; si$12 < seqIndices$1.length; si$12++) {
              if (charTypes[seqIndices$1[si$12]] & NEUTRAL_ISOLATE_TYPES) {
                var niRunStart = si$12, niRunEnd = si$12;
                var prevType$2 = sosType;
                for (var si2 = si$12 - 1; si2 >= 0; si2--) {
                  if (charTypes[seqIndices$1[si2]] & BN_LIKE_TYPES) {
                    niRunStart = si2;
                  } else {
                    prevType$2 = charTypes[seqIndices$1[si2]] & R_TYPES_FOR_N_STEPS ? TYPE_R : TYPE_L;
                    break;
                  }
                }
                var nextType$1 = eosType;
                for (var si2$1 = si$12 + 1; si2$1 < seqIndices$1.length; si2$1++) {
                  if (charTypes[seqIndices$1[si2$1]] & (NEUTRAL_ISOLATE_TYPES | BN_LIKE_TYPES)) {
                    niRunEnd = si2$1;
                  } else {
                    nextType$1 = charTypes[seqIndices$1[si2$1]] & R_TYPES_FOR_N_STEPS ? TYPE_R : TYPE_L;
                    break;
                  }
                }
                for (var sj$8 = niRunStart; sj$8 <= niRunEnd; sj$8++) {
                  charTypes[seqIndices$1[sj$8]] = prevType$2 === nextType$1 ? prevType$2 : getEmbedDirection(seqIndices$1[sj$8]);
                }
                si$12 = niRunEnd;
              }
            }
          }
        }
        for (var i$17 = paragraph.start; i$17 <= paragraph.end; i$17++) {
          var level$3 = embedLevels[i$17];
          var type$1 = charTypes[i$17];
          if (level$3 & 1) {
            if (type$1 & (TYPE_L | TYPE_EN | TYPE_AN)) {
              embedLevels[i$17]++;
            }
          } else {
            if (type$1 & TYPE_R) {
              embedLevels[i$17]++;
            } else if (type$1 & (TYPE_AN | TYPE_EN)) {
              embedLevels[i$17] += 2;
            }
          }
          if (type$1 & BN_LIKE_TYPES) {
            embedLevels[i$17] = i$17 === 0 ? paragraph.level : embedLevels[i$17 - 1];
          }
          if (i$17 === paragraph.end || getBidiCharType(string[i$17]) & (TYPE_S | TYPE_B)) {
            for (var j$1 = i$17; j$1 >= 0 && getBidiCharType(string[j$1]) & TRAILING_TYPES; j$1--) {
              embedLevels[j$1] = paragraph.level;
            }
          }
        }
      }
      return {
        levels: embedLevels,
        paragraphs
      };
      function determineAutoEmbedLevel(start, isFSI) {
        for (var i2 = start; i2 < string.length; i2++) {
          var charType2 = charTypes[i2];
          if (charType2 & (TYPE_R | TYPE_AL)) {
            return 1;
          }
          if (charType2 & (TYPE_B | TYPE_L) || isFSI && charType2 === TYPE_PDI) {
            return 0;
          }
          if (charType2 & ISOLATE_INIT_TYPES) {
            var pdi = indexOfMatchingPDI(i2);
            i2 = pdi === -1 ? string.length : pdi;
          }
        }
        return 0;
      }
      function indexOfMatchingPDI(isolateStart) {
        var isolationLevel = 1;
        for (var i2 = isolateStart + 1; i2 < string.length; i2++) {
          var charType2 = charTypes[i2];
          if (charType2 & TYPE_B) {
            break;
          }
          if (charType2 & TYPE_PDI) {
            if (--isolationLevel === 0) {
              return i2;
            }
          } else if (charType2 & ISOLATE_INIT_TYPES) {
            isolationLevel++;
          }
        }
        return -1;
      }
      function getEmbedDirection(i2) {
        return embedLevels[i2] & 1 ? TYPE_R : TYPE_L;
      }
    }
    var data = "14>1,j>2,t>2,u>2,1a>g,2v3>1,1>1,1ge>1,1wd>1,b>1,1j>1,f>1,ai>3,-2>3,+1,8>1k0,-1jq>1y7,-1y6>1hf,-1he>1h6,-1h5>1ha,-1h8>1qi,-1pu>1,6>3u,-3s>7,6>1,1>1,f>1,1>1,+2,3>1,1>1,+13,4>1,1>1,6>1eo,-1ee>1,3>1mg,-1me>1mk,-1mj>1mi,-1mg>1mi,-1md>1,1>1,+2,1>10k,-103>1,1>1,4>1,5>1,1>1,+10,3>1,1>8,-7>8,+1,-6>7,+1,a>1,1>1,u>1,u6>1,1>1,+5,26>1,1>1,2>1,2>2,8>1,7>1,4>1,1>1,+5,b8>1,1>1,+3,1>3,-2>1,2>1,1>1,+2,c>1,3>1,1>1,+2,h>1,3>1,a>1,1>1,2>1,3>1,1>1,d>1,f>1,3>1,1a>1,1>1,6>1,7>1,13>1,k>1,1>1,+19,4>1,1>1,+2,2>1,1>1,+18,m>1,a>1,1>1,lk>1,1>1,4>1,2>1,f>1,3>1,1>1,+3,db>1,1>1,+3,3>1,1>1,+2,14qm>1,1>1,+1,6>1,4j>1,j>2,t>2,u>2,2>1,+1";
    var mirrorMap;
    function parse() {
      if (!mirrorMap) {
        var ref = parseCharacterMap(data, true);
        var map2 = ref.map;
        var reverseMap = ref.reverseMap;
        reverseMap.forEach(function(value, key) {
          map2.set(key, value);
        });
        mirrorMap = map2;
      }
    }
    function getMirroredCharacter(char) {
      parse();
      return mirrorMap.get(char) || null;
    }
    function getMirroredCharactersMap(string, embeddingLevels, start, end) {
      var strLen = string.length;
      start = Math.max(0, start == null ? 0 : +start);
      end = Math.min(strLen - 1, end == null ? strLen - 1 : +end);
      var map2 = /* @__PURE__ */ new Map();
      for (var i = start; i <= end; i++) {
        if (embeddingLevels[i] & 1) {
          var mirror = getMirroredCharacter(string[i]);
          if (mirror !== null) {
            map2.set(i, mirror);
          }
        }
      }
      return map2;
    }
    function getReorderSegments(string, embeddingLevelsResult, start, end) {
      var strLen = string.length;
      start = Math.max(0, start == null ? 0 : +start);
      end = Math.min(strLen - 1, end == null ? strLen - 1 : +end);
      var segments = [];
      embeddingLevelsResult.paragraphs.forEach(function(paragraph) {
        var lineStart = Math.max(start, paragraph.start);
        var lineEnd = Math.min(end, paragraph.end);
        if (lineStart < lineEnd) {
          var lineLevels = embeddingLevelsResult.levels.slice(lineStart, lineEnd + 1);
          for (var i = lineEnd; i >= lineStart && getBidiCharType(string[i]) & TRAILING_TYPES; i--) {
            lineLevels[i] = paragraph.level;
          }
          var maxLevel = paragraph.level;
          var minOddLevel = Infinity;
          for (var i$1 = 0; i$1 < lineLevels.length; i$1++) {
            var level = lineLevels[i$1];
            if (level > maxLevel) {
              maxLevel = level;
            }
            if (level < minOddLevel) {
              minOddLevel = level | 1;
            }
          }
          for (var lvl = maxLevel; lvl >= minOddLevel; lvl--) {
            for (var i$2 = 0; i$2 < lineLevels.length; i$2++) {
              if (lineLevels[i$2] >= lvl) {
                var segStart = i$2;
                while (i$2 + 1 < lineLevels.length && lineLevels[i$2 + 1] >= lvl) {
                  i$2++;
                }
                if (i$2 > segStart) {
                  segments.push([segStart + start, i$2 + start]);
                }
              }
            }
          }
        }
      });
      return segments;
    }
    function getReorderedString(string, embedLevelsResult, start, end) {
      var indices = getReorderedIndices(string, embedLevelsResult, start, end);
      var chars = [].concat(string);
      indices.forEach(function(charIndex, i) {
        chars[i] = (embedLevelsResult.levels[charIndex] & 1 ? getMirroredCharacter(string[charIndex]) : null) || string[charIndex];
      });
      return chars.join("");
    }
    function getReorderedIndices(string, embedLevelsResult, start, end) {
      var segments = getReorderSegments(string, embedLevelsResult, start, end);
      var indices = [];
      for (var i = 0; i < string.length; i++) {
        indices[i] = i;
      }
      segments.forEach(function(ref) {
        var start2 = ref[0];
        var end2 = ref[1];
        var slice = indices.slice(start2, end2 + 1);
        for (var i2 = slice.length; i2--; ) {
          indices[end2 - i2] = slice[i2];
        }
      });
      return indices;
    }
    exports.closingToOpeningBracket = closingToOpeningBracket;
    exports.getBidiCharType = getBidiCharType;
    exports.getBidiCharTypeName = getBidiCharTypeName;
    exports.getCanonicalBracket = getCanonicalBracket;
    exports.getEmbeddingLevels = getEmbeddingLevels;
    exports.getMirroredCharacter = getMirroredCharacter;
    exports.getMirroredCharactersMap = getMirroredCharactersMap;
    exports.getReorderSegments = getReorderSegments;
    exports.getReorderedIndices = getReorderedIndices;
    exports.getReorderedString = getReorderedString;
    exports.openingToClosingBracket = openingToClosingBracket;
    Object.defineProperty(exports, "__esModule", { value: true });
    return exports;
  }({});
  return bidi;
}
var bidi_default = bidiFactory;

// node_modules/troika-three-utils/dist/troika-three-utils.esm.js
var voidMainRegExp = /\bvoid\s+main\s*\(\s*\)\s*{/g;
function expandShaderIncludes(source) {
  const pattern = /^[ \t]*#include +<([\w\d./]+)>/gm;
  function replace(match, include) {
    let chunk = ShaderChunk[include];
    return chunk ? expandShaderIncludes(chunk) : match;
  }
  return source.replace(pattern, replace);
}
var _lut = [];
for (let i = 0; i < 256; i++) {
  _lut[i] = (i < 16 ? "0" : "") + i.toString(16);
}
function generateUUID() {
  const d0 = Math.random() * 4294967295 | 0;
  const d1 = Math.random() * 4294967295 | 0;
  const d2 = Math.random() * 4294967295 | 0;
  const d3 = Math.random() * 4294967295 | 0;
  const uuid = _lut[d0 & 255] + _lut[d0 >> 8 & 255] + _lut[d0 >> 16 & 255] + _lut[d0 >> 24 & 255] + "-" + _lut[d1 & 255] + _lut[d1 >> 8 & 255] + "-" + _lut[d1 >> 16 & 15 | 64] + _lut[d1 >> 24 & 255] + "-" + _lut[d2 & 63 | 128] + _lut[d2 >> 8 & 255] + "-" + _lut[d2 >> 16 & 255] + _lut[d2 >> 24 & 255] + _lut[d3 & 255] + _lut[d3 >> 8 & 255] + _lut[d3 >> 16 & 255] + _lut[d3 >> 24 & 255];
  return uuid.toUpperCase();
}
var assign = Object.assign || function() {
  let target = arguments[0];
  for (let i = 1, len = arguments.length; i < len; i++) {
    let source = arguments[i];
    if (source) {
      for (let prop in source) {
        if (source.hasOwnProperty(prop)) {
          target[prop] = source[prop];
        }
      }
    }
  }
  return target;
};
var epoch = Date.now();
var CONSTRUCTOR_CACHE = /* @__PURE__ */ new WeakMap();
var SHADER_UPGRADE_CACHE = /* @__PURE__ */ new Map();
var materialInstanceId = 1e10;
function createDerivedMaterial(baseMaterial, options) {
  const optionsKey = getKeyForOptions(options);
  let ctorsByDerivation = CONSTRUCTOR_CACHE.get(baseMaterial);
  if (!ctorsByDerivation) {
    CONSTRUCTOR_CACHE.set(baseMaterial, ctorsByDerivation = /* @__PURE__ */ Object.create(null));
  }
  if (ctorsByDerivation[optionsKey]) {
    return new ctorsByDerivation[optionsKey]();
  }
  const privateBeforeCompileProp = `_onBeforeCompile${optionsKey}`;
  const onBeforeCompile = function(shaderInfo) {
    baseMaterial.onBeforeCompile.call(this, shaderInfo);
    const cacheKey = this.customProgramCacheKey() + "|" + shaderInfo.vertexShader + "|" + shaderInfo.fragmentShader;
    let upgradedShaders = SHADER_UPGRADE_CACHE[cacheKey];
    if (!upgradedShaders) {
      const upgraded = upgradeShaders(shaderInfo, options, optionsKey);
      upgradedShaders = SHADER_UPGRADE_CACHE[cacheKey] = upgraded;
    }
    shaderInfo.vertexShader = upgradedShaders.vertexShader;
    shaderInfo.fragmentShader = upgradedShaders.fragmentShader;
    assign(shaderInfo.uniforms, this.uniforms);
    if (options.timeUniform) {
      shaderInfo.uniforms[options.timeUniform] = {
        get value() {
          return Date.now() - epoch;
        }
      };
    }
    if (this[privateBeforeCompileProp]) {
      this[privateBeforeCompileProp](shaderInfo);
    }
  };
  const DerivedMaterial = function DerivedMaterial2() {
    return derive(options.chained ? baseMaterial : baseMaterial.clone());
  };
  const derive = function(base) {
    const derived2 = Object.create(base, descriptor);
    Object.defineProperty(derived2, "baseMaterial", { value: baseMaterial });
    Object.defineProperty(derived2, "id", { value: materialInstanceId++ });
    derived2.uuid = generateUUID();
    derived2.uniforms = assign({}, base.uniforms, options.uniforms);
    derived2.defines = assign({}, base.defines, options.defines);
    derived2.defines[`TROIKA_DERIVED_MATERIAL_${optionsKey}`] = "";
    derived2.extensions = assign({}, base.extensions, options.extensions);
    derived2._listeners = void 0;
    return derived2;
  };
  const descriptor = {
    constructor: { value: DerivedMaterial },
    isDerivedMaterial: { value: true },
    customProgramCacheKey: {
      writable: true,
      configurable: true,
      value: function() {
        return baseMaterial.customProgramCacheKey() + "|" + optionsKey;
      }
    },
    onBeforeCompile: {
      get() {
        return onBeforeCompile;
      },
      set(fn) {
        this[privateBeforeCompileProp] = fn;
      }
    },
    copy: {
      writable: true,
      configurable: true,
      value: function(source) {
        baseMaterial.copy.call(this, source);
        if (!baseMaterial.isShaderMaterial && !baseMaterial.isDerivedMaterial) {
          assign(this.extensions, source.extensions);
          assign(this.defines, source.defines);
          assign(this.uniforms, UniformsUtils.clone(source.uniforms));
        }
        return this;
      }
    },
    clone: {
      writable: true,
      configurable: true,
      value: function() {
        const newBase = new baseMaterial.constructor();
        return derive(newBase).copy(this);
      }
    },
    /**
     * Utility to get a MeshDepthMaterial that will honor this derived material's vertex
     * transformations and discarded fragments.
     */
    getDepthMaterial: {
      writable: true,
      configurable: true,
      value: function() {
        let depthMaterial = this._depthMaterial;
        if (!depthMaterial) {
          depthMaterial = this._depthMaterial = createDerivedMaterial(
            baseMaterial.isDerivedMaterial ? baseMaterial.getDepthMaterial() : new MeshDepthMaterial({ depthPacking: RGBADepthPacking }),
            options
          );
          depthMaterial.defines.IS_DEPTH_MATERIAL = "";
          depthMaterial.uniforms = this.uniforms;
        }
        return depthMaterial;
      }
    },
    /**
     * Utility to get a MeshDistanceMaterial that will honor this derived material's vertex
     * transformations and discarded fragments.
     */
    getDistanceMaterial: {
      writable: true,
      configurable: true,
      value: function() {
        let distanceMaterial = this._distanceMaterial;
        if (!distanceMaterial) {
          distanceMaterial = this._distanceMaterial = createDerivedMaterial(
            baseMaterial.isDerivedMaterial ? baseMaterial.getDistanceMaterial() : new MeshDistanceMaterial(),
            options
          );
          distanceMaterial.defines.IS_DISTANCE_MATERIAL = "";
          distanceMaterial.uniforms = this.uniforms;
        }
        return distanceMaterial;
      }
    },
    dispose: {
      writable: true,
      configurable: true,
      value() {
        const { _depthMaterial, _distanceMaterial } = this;
        if (_depthMaterial)
          _depthMaterial.dispose();
        if (_distanceMaterial)
          _distanceMaterial.dispose();
        baseMaterial.dispose.call(this);
      }
    }
  };
  ctorsByDerivation[optionsKey] = DerivedMaterial;
  return new DerivedMaterial();
}
function upgradeShaders({ vertexShader, fragmentShader }, options, key) {
  let {
    vertexDefs,
    vertexMainIntro,
    vertexMainOutro,
    vertexTransform,
    fragmentDefs,
    fragmentMainIntro,
    fragmentMainOutro,
    fragmentColorTransform,
    customRewriter,
    timeUniform
  } = options;
  vertexDefs = vertexDefs || "";
  vertexMainIntro = vertexMainIntro || "";
  vertexMainOutro = vertexMainOutro || "";
  fragmentDefs = fragmentDefs || "";
  fragmentMainIntro = fragmentMainIntro || "";
  fragmentMainOutro = fragmentMainOutro || "";
  if (vertexTransform || customRewriter) {
    vertexShader = expandShaderIncludes(vertexShader);
  }
  if (fragmentColorTransform || customRewriter) {
    fragmentShader = fragmentShader.replace(
      /^[ \t]*#include <((?:tonemapping|encodings|fog|premultiplied_alpha|dithering)_fragment)>/gm,
      "\n//!BEGIN_POST_CHUNK $1\n$&\n//!END_POST_CHUNK\n"
    );
    fragmentShader = expandShaderIncludes(fragmentShader);
  }
  if (customRewriter) {
    let res = customRewriter({ vertexShader, fragmentShader });
    vertexShader = res.vertexShader;
    fragmentShader = res.fragmentShader;
  }
  if (fragmentColorTransform) {
    let postChunks = [];
    fragmentShader = fragmentShader.replace(
      /^\/\/!BEGIN_POST_CHUNK[^]+?^\/\/!END_POST_CHUNK/gm,
      // [^]+? = non-greedy match of any chars including newlines
      (match) => {
        postChunks.push(match);
        return "";
      }
    );
    fragmentMainOutro = `${fragmentColorTransform}
${postChunks.join("\n")}
${fragmentMainOutro}`;
  }
  if (timeUniform) {
    const code = `
uniform float ${timeUniform};
`;
    vertexDefs = code + vertexDefs;
    fragmentDefs = code + fragmentDefs;
  }
  if (vertexTransform) {
    vertexShader = `vec3 troika_position_${key};
vec3 troika_normal_${key};
vec2 troika_uv_${key};
${vertexShader}
`;
    vertexDefs = `${vertexDefs}
void troikaVertexTransform${key}(inout vec3 position, inout vec3 normal, inout vec2 uv) {
  ${vertexTransform}
}
`;
    vertexMainIntro = `
troika_position_${key} = vec3(position);
troika_normal_${key} = vec3(normal);
troika_uv_${key} = vec2(uv);
troikaVertexTransform${key}(troika_position_${key}, troika_normal_${key}, troika_uv_${key});
${vertexMainIntro}
`;
    vertexShader = vertexShader.replace(/\b(position|normal|uv)\b/g, (match, match1, index, fullStr) => {
      return /\battribute\s+vec[23]\s+$/.test(fullStr.substr(0, index)) ? match1 : `troika_${match1}_${key}`;
    });
  }
  vertexShader = injectIntoShaderCode(vertexShader, key, vertexDefs, vertexMainIntro, vertexMainOutro);
  fragmentShader = injectIntoShaderCode(fragmentShader, key, fragmentDefs, fragmentMainIntro, fragmentMainOutro);
  return {
    vertexShader,
    fragmentShader
  };
}
function injectIntoShaderCode(shaderCode, id, defs, intro, outro) {
  if (intro || outro || defs) {
    shaderCode = shaderCode.replace(
      voidMainRegExp,
      `
${defs}
void troikaOrigMain${id}() {`
    );
    shaderCode += `
void main() {
  ${intro}
  troikaOrigMain${id}();
  ${outro}
}`;
  }
  return shaderCode;
}
function optionsJsonReplacer(key, value) {
  return key === "uniforms" ? void 0 : typeof value === "function" ? value.toString() : value;
}
var _idCtr = 0;
var optionsHashesToIds = /* @__PURE__ */ new Map();
function getKeyForOptions(options) {
  const optionsHash = JSON.stringify(options, optionsJsonReplacer);
  let id = optionsHashesToIds.get(optionsHash);
  if (id == null) {
    optionsHashesToIds.set(optionsHash, id = ++_idCtr);
  }
  return id;
}
var defaultBaseMaterial = new MeshStandardMaterial({ color: 16777215, side: DoubleSide });

// node_modules/troika-three-text/dist/troika-three-text.esm.js
function createTypesetter(fontParser, bidi, config) {
  const {
    defaultFontURL
  } = config;
  const fonts = /* @__PURE__ */ Object.create(null);
  const INF = Infinity;
  const DEFAULT_IGNORABLE_CHARS = /[\u00AD\u034F\u061C\u115F-\u1160\u17B4-\u17B5\u180B-\u180E\u200B-\u200F\u202A-\u202E\u2060-\u206F\u3164\uFE00-\uFE0F\uFEFF\uFFA0\uFFF0-\uFFF8]/;
  const BREAK_AFTER_CHARS = /[\s\-\u007C\u00AD\u2010\u2012-\u2014\u2027\u2056\u2E17\u2E40]/;
  function doLoadFont(url, callback) {
    function tryLoad() {
      const onError = (err) => {
        console.error(`Failure loading font ${url}${url === defaultFontURL ? "" : "; trying fallback"}`, err);
        if (url !== defaultFontURL) {
          url = defaultFontURL;
          tryLoad();
        }
      };
      try {
        const request = new XMLHttpRequest();
        request.open("get", url, true);
        request.responseType = "arraybuffer";
        request.onload = function() {
          if (request.status >= 400) {
            onError(new Error(request.statusText));
          } else if (request.status > 0) {
            try {
              const fontObj = fontParser(request.response);
              callback(fontObj);
            } catch (e) {
              onError(e);
            }
          }
        };
        request.onerror = onError;
        request.send();
      } catch (err) {
        onError(err);
      }
    }
    tryLoad();
  }
  function loadFont(fontUrl, callback) {
    if (!fontUrl)
      fontUrl = defaultFontURL;
    let font = fonts[fontUrl];
    if (font) {
      if (font.pending) {
        font.pending.push(callback);
      } else {
        callback(font);
      }
    } else {
      fonts[fontUrl] = { pending: [callback] };
      doLoadFont(fontUrl, (fontObj) => {
        let callbacks = fonts[fontUrl].pending;
        fonts[fontUrl] = fontObj;
        callbacks.forEach((cb) => cb(fontObj));
      });
    }
  }
  function typeset({
    text = "",
    font = defaultFontURL,
    sdfGlyphSize = 64,
    fontSize = 1,
    letterSpacing = 0,
    lineHeight = "normal",
    maxWidth = INF,
    direction,
    textAlign = "left",
    textIndent = 0,
    whiteSpace = "normal",
    overflowWrap = "normal",
    anchorX = 0,
    anchorY = 0,
    includeCaretPositions = false,
    chunkedBoundsSize = 8192,
    colorRanges = null
  }, callback, metricsOnly = false) {
    const mainStart = now2();
    const timings = { fontLoad: 0, typesetting: 0 };
    if (text.indexOf("\r") > -1) {
      console.info("Typesetter: got text with \\r chars; normalizing to \\n");
      text = text.replace(/\r\n/g, "\n").replace(/\r/g, "\n");
    }
    fontSize = +fontSize;
    letterSpacing = +letterSpacing;
    maxWidth = +maxWidth;
    lineHeight = lineHeight || "normal";
    textIndent = +textIndent;
    loadFont(font, (fontObj) => {
      const hasMaxWidth = isFinite(maxWidth);
      let glyphIds = null;
      let glyphPositions = null;
      let glyphData = null;
      let glyphColors = null;
      let caretPositions = null;
      let visibleBounds = null;
      let chunkedBounds = null;
      let maxLineWidth = 0;
      let renderableGlyphCount = 0;
      let canWrap = whiteSpace !== "nowrap";
      const { ascender, descender, unitsPerEm } = fontObj;
      timings.fontLoad = now2() - mainStart;
      const typesetStart = now2();
      const fontSizeMult = fontSize / unitsPerEm;
      if (lineHeight === "normal") {
        lineHeight = (ascender - descender) / unitsPerEm;
      }
      lineHeight = lineHeight * fontSize;
      const halfLeading = (lineHeight - (ascender - descender) * fontSizeMult) / 2;
      const topBaseline = -(ascender * fontSizeMult + halfLeading);
      const caretHeight = Math.min(lineHeight, (ascender - descender) * fontSizeMult);
      const caretBottomOffset = (ascender + descender) / 2 * fontSizeMult - caretHeight / 2;
      let lineXOffset = textIndent;
      let currentLine = new TextLine();
      const lines = [currentLine];
      fontObj.forEachGlyph(text, fontSize, letterSpacing, (glyphObj, glyphX, charIndex) => {
        const char = text.charAt(charIndex);
        const glyphWidth = glyphObj.advanceWidth * fontSizeMult;
        const curLineCount = currentLine.count;
        let nextLine;
        if (!("isEmpty" in glyphObj)) {
          glyphObj.isWhitespace = !!char && /\s/.test(char);
          glyphObj.canBreakAfter = !!char && BREAK_AFTER_CHARS.test(char);
          glyphObj.isEmpty = glyphObj.xMin === glyphObj.xMax || glyphObj.yMin === glyphObj.yMax || DEFAULT_IGNORABLE_CHARS.test(char);
        }
        if (!glyphObj.isWhitespace && !glyphObj.isEmpty) {
          renderableGlyphCount++;
        }
        if (canWrap && hasMaxWidth && !glyphObj.isWhitespace && glyphX + glyphWidth + lineXOffset > maxWidth && curLineCount) {
          if (currentLine.glyphAt(curLineCount - 1).glyphObj.canBreakAfter) {
            nextLine = new TextLine();
            lineXOffset = -glyphX;
          } else {
            for (let i = curLineCount; i--; ) {
              if (i === 0 && overflowWrap === "break-word") {
                nextLine = new TextLine();
                lineXOffset = -glyphX;
                break;
              } else if (currentLine.glyphAt(i).glyphObj.canBreakAfter) {
                nextLine = currentLine.splitAt(i + 1);
                const adjustX = nextLine.glyphAt(0).x;
                lineXOffset -= adjustX;
                for (let j = nextLine.count; j--; ) {
                  nextLine.glyphAt(j).x -= adjustX;
                }
                break;
              }
            }
          }
          if (nextLine) {
            currentLine.isSoftWrapped = true;
            currentLine = nextLine;
            lines.push(currentLine);
            maxLineWidth = maxWidth;
          }
        }
        let fly = currentLine.glyphAt(currentLine.count);
        fly.glyphObj = glyphObj;
        fly.x = glyphX + lineXOffset;
        fly.width = glyphWidth;
        fly.charIndex = charIndex;
        if (char === "\n") {
          currentLine = new TextLine();
          lines.push(currentLine);
          lineXOffset = -(glyphX + glyphWidth + letterSpacing * fontSize) + textIndent;
        }
      });
      lines.forEach((line) => {
        for (let i = line.count; i--; ) {
          let { glyphObj, x: x2, width } = line.glyphAt(i);
          if (!glyphObj.isWhitespace) {
            line.width = x2 + width;
            if (line.width > maxLineWidth) {
              maxLineWidth = line.width;
            }
            return;
          }
        }
      });
      let anchorXOffset = 0;
      let anchorYOffset = 0;
      if (anchorX) {
        if (typeof anchorX === "number") {
          anchorXOffset = -anchorX;
        } else if (typeof anchorX === "string") {
          anchorXOffset = -maxLineWidth * (anchorX === "left" ? 0 : anchorX === "center" ? 0.5 : anchorX === "right" ? 1 : parsePercent(anchorX));
        }
      }
      if (anchorY) {
        if (typeof anchorY === "number") {
          anchorYOffset = -anchorY;
        } else if (typeof anchorY === "string") {
          let height = lines.length * lineHeight;
          anchorYOffset = anchorY === "top" ? 0 : anchorY === "top-baseline" ? -topBaseline : anchorY === "middle" ? height / 2 : anchorY === "bottom" ? height : anchorY === "bottom-baseline" ? height - halfLeading + descender * fontSizeMult : parsePercent(anchorY) * height;
        }
      }
      if (!metricsOnly) {
        const bidiLevelsResult = bidi.getEmbeddingLevels(text, direction);
        glyphIds = new Uint16Array(renderableGlyphCount);
        glyphPositions = new Float32Array(renderableGlyphCount * 2);
        glyphData = {};
        visibleBounds = [INF, INF, -INF, -INF];
        chunkedBounds = [];
        let lineYOffset = topBaseline;
        if (includeCaretPositions) {
          caretPositions = new Float32Array(text.length * 3);
        }
        if (colorRanges) {
          glyphColors = new Uint8Array(renderableGlyphCount * 3);
        }
        let renderableGlyphIndex = 0;
        let prevCharIndex = -1;
        let colorCharIndex = -1;
        let chunk;
        let currentColor;
        lines.forEach((line, lineIndex) => {
          let { count: lineGlyphCount, width: lineWidth } = line;
          if (lineGlyphCount > 0) {
            let trailingWhitespaceCount = 0;
            for (let i = lineGlyphCount; i-- && line.glyphAt(i).glyphObj.isWhitespace; ) {
              trailingWhitespaceCount++;
            }
            let lineXOffset2 = 0;
            let justifyAdjust = 0;
            if (textAlign === "center") {
              lineXOffset2 = (maxLineWidth - lineWidth) / 2;
            } else if (textAlign === "right") {
              lineXOffset2 = maxLineWidth - lineWidth;
            } else if (textAlign === "justify" && line.isSoftWrapped) {
              let whitespaceCount = 0;
              for (let i = lineGlyphCount - trailingWhitespaceCount; i--; ) {
                if (line.glyphAt(i).glyphObj.isWhitespace) {
                  whitespaceCount++;
                }
              }
              justifyAdjust = (maxLineWidth - lineWidth) / whitespaceCount;
            }
            if (justifyAdjust || lineXOffset2) {
              let justifyOffset = 0;
              for (let i = 0; i < lineGlyphCount; i++) {
                let glyphInfo = line.glyphAt(i);
                const glyphObj2 = glyphInfo.glyphObj;
                glyphInfo.x += lineXOffset2 + justifyOffset;
                if (justifyAdjust !== 0 && glyphObj2.isWhitespace && i < lineGlyphCount - trailingWhitespaceCount) {
                  justifyOffset += justifyAdjust;
                  glyphInfo.width += justifyAdjust;
                }
              }
            }
            const flips = bidi.getReorderSegments(
              text,
              bidiLevelsResult,
              line.glyphAt(0).charIndex,
              line.glyphAt(line.count - 1).charIndex
            );
            for (let fi = 0; fi < flips.length; fi++) {
              const [start, end] = flips[fi];
              let left = Infinity, right = -Infinity;
              for (let i = 0; i < lineGlyphCount; i++) {
                if (line.glyphAt(i).charIndex >= start) {
                  let startInLine = i, endInLine = i;
                  for (; endInLine < lineGlyphCount; endInLine++) {
                    let info = line.glyphAt(endInLine);
                    if (info.charIndex > end) {
                      break;
                    }
                    if (endInLine < lineGlyphCount - trailingWhitespaceCount) {
                      left = Math.min(left, info.x);
                      right = Math.max(right, info.x + info.width);
                    }
                  }
                  for (let j = startInLine; j < endInLine; j++) {
                    const glyphInfo = line.glyphAt(j);
                    glyphInfo.x = right - (glyphInfo.x + glyphInfo.width - left);
                  }
                  break;
                }
              }
            }
            let glyphObj;
            const setGlyphObj = (g2) => glyphObj = g2;
            for (let i = 0; i < lineGlyphCount; i++) {
              let glyphInfo = line.glyphAt(i);
              glyphObj = glyphInfo.glyphObj;
              const glyphId = glyphObj.index;
              const rtl = bidiLevelsResult.levels[glyphInfo.charIndex] & 1;
              if (rtl) {
                const mirrored = bidi.getMirroredCharacter(text[glyphInfo.charIndex]);
                if (mirrored) {
                  fontObj.forEachGlyph(mirrored, 0, 0, setGlyphObj);
                }
              }
              if (includeCaretPositions) {
                const { charIndex } = glyphInfo;
                const caretLeft = glyphInfo.x + anchorXOffset;
                const caretRight = glyphInfo.x + glyphInfo.width + anchorXOffset;
                caretPositions[charIndex * 3] = rtl ? caretRight : caretLeft;
                caretPositions[charIndex * 3 + 1] = rtl ? caretLeft : caretRight;
                caretPositions[charIndex * 3 + 2] = lineYOffset + caretBottomOffset + anchorYOffset;
                const ligCount = charIndex - prevCharIndex;
                if (ligCount > 1) {
                  fillLigatureCaretPositions(caretPositions, prevCharIndex, ligCount);
                }
                prevCharIndex = charIndex;
              }
              if (colorRanges) {
                const { charIndex } = glyphInfo;
                while (charIndex > colorCharIndex) {
                  colorCharIndex++;
                  if (colorRanges.hasOwnProperty(colorCharIndex)) {
                    currentColor = colorRanges[colorCharIndex];
                  }
                }
              }
              if (!glyphObj.isWhitespace && !glyphObj.isEmpty) {
                const idx = renderableGlyphIndex++;
                if (!glyphData[glyphId]) {
                  glyphData[glyphId] = {
                    path: glyphObj.path,
                    pathBounds: [glyphObj.xMin, glyphObj.yMin, glyphObj.xMax, glyphObj.yMax]
                  };
                }
                const glyphX = glyphInfo.x + anchorXOffset;
                const glyphY = lineYOffset + anchorYOffset;
                glyphPositions[idx * 2] = glyphX;
                glyphPositions[idx * 2 + 1] = glyphY;
                const visX0 = glyphX + glyphObj.xMin * fontSizeMult;
                const visY0 = glyphY + glyphObj.yMin * fontSizeMult;
                const visX1 = glyphX + glyphObj.xMax * fontSizeMult;
                const visY1 = glyphY + glyphObj.yMax * fontSizeMult;
                if (visX0 < visibleBounds[0])
                  visibleBounds[0] = visX0;
                if (visY0 < visibleBounds[1])
                  visibleBounds[1] = visY0;
                if (visX1 > visibleBounds[2])
                  visibleBounds[2] = visX1;
                if (visY1 > visibleBounds[3])
                  visibleBounds[3] = visY1;
                if (idx % chunkedBoundsSize === 0) {
                  chunk = { start: idx, end: idx, rect: [INF, INF, -INF, -INF] };
                  chunkedBounds.push(chunk);
                }
                chunk.end++;
                const chunkRect = chunk.rect;
                if (visX0 < chunkRect[0])
                  chunkRect[0] = visX0;
                if (visY0 < chunkRect[1])
                  chunkRect[1] = visY0;
                if (visX1 > chunkRect[2])
                  chunkRect[2] = visX1;
                if (visY1 > chunkRect[3])
                  chunkRect[3] = visY1;
                glyphIds[idx] = glyphId;
                if (colorRanges) {
                  const start = idx * 3;
                  glyphColors[start] = currentColor >> 16 & 255;
                  glyphColors[start + 1] = currentColor >> 8 & 255;
                  glyphColors[start + 2] = currentColor & 255;
                }
              }
            }
          }
          lineYOffset -= lineHeight;
        });
        if (caretPositions) {
          const ligCount = text.length - prevCharIndex;
          if (ligCount > 1) {
            fillLigatureCaretPositions(caretPositions, prevCharIndex, ligCount);
          }
        }
      }
      timings.typesetting = now2() - typesetStart;
      callback({
        glyphIds,
        //font indices for each glyph
        glyphPositions,
        //x,y of each glyph's origin in layout
        glyphData,
        //dict holding data about each glyph appearing in the text
        caretPositions,
        //startX,endX,bottomY caret positions for each char
        caretHeight,
        //height of cursor from bottom to top
        glyphColors,
        //color for each glyph, if color ranges supplied
        chunkedBounds,
        //total rects per (n=chunkedBoundsSize) consecutive glyphs
        fontSize,
        //calculated em height
        unitsPerEm,
        //font units per em
        ascender: ascender * fontSizeMult,
        //font ascender
        descender: descender * fontSizeMult,
        //font descender
        lineHeight,
        //computed line height
        topBaseline,
        //y coordinate of the top line's baseline
        blockBounds: [
          //bounds for the whole block of text, including vertical padding for lineHeight
          anchorXOffset,
          anchorYOffset - lines.length * lineHeight,
          anchorXOffset + maxLineWidth,
          anchorYOffset
        ],
        visibleBounds,
        //total bounds of visible text paths, may be larger or smaller than totalBounds
        timings
      });
    });
  }
  function measure(args, callback) {
    typeset(args, (result) => {
      const [x0, y0, x1, y1] = result.blockBounds;
      callback({
        width: x1 - x0,
        height: y1 - y0
      });
    }, { metricsOnly: true });
  }
  function parsePercent(str) {
    let match = str.match(/^([\d.]+)%$/);
    let pct = match ? parseFloat(match[1]) : NaN;
    return isNaN(pct) ? 0 : pct / 100;
  }
  function fillLigatureCaretPositions(caretPositions, ligStartIndex, ligCount) {
    const ligStartX = caretPositions[ligStartIndex * 3];
    const ligEndX = caretPositions[ligStartIndex * 3 + 1];
    const ligY = caretPositions[ligStartIndex * 3 + 2];
    const guessedAdvanceX = (ligEndX - ligStartX) / ligCount;
    for (let i = 0; i < ligCount; i++) {
      const startIndex = (ligStartIndex + i) * 3;
      caretPositions[startIndex] = ligStartX + guessedAdvanceX * i;
      caretPositions[startIndex + 1] = ligStartX + guessedAdvanceX * (i + 1);
      caretPositions[startIndex + 2] = ligY;
    }
  }
  function now2() {
    return (self.performance || Date).now();
  }
  function TextLine() {
    this.data = [];
  }
  const textLineProps = ["glyphObj", "x", "width", "charIndex"];
  TextLine.prototype = {
    width: 0,
    isSoftWrapped: false,
    get count() {
      return Math.ceil(this.data.length / textLineProps.length);
    },
    glyphAt(i) {
      let fly = TextLine.flyweight;
      fly.data = this.data;
      fly.index = i;
      return fly;
    },
    splitAt(i) {
      let newLine = new TextLine();
      newLine.data = this.data.splice(i * textLineProps.length);
      return newLine;
    }
  };
  TextLine.flyweight = textLineProps.reduce((obj, prop, i, all) => {
    Object.defineProperty(obj, prop, {
      get() {
        return this.data[this.index * textLineProps.length + i];
      },
      set(val) {
        this.data[this.index * textLineProps.length + i] = val;
      }
    });
    return obj;
  }, { data: null, index: 0 });
  return {
    typeset,
    measure,
    loadFont
  };
}
var now = () => (self.performance || Date).now();
var mainThreadGenerator = SDFGenerator();
var warned;
function generateSDF(width, height, path, viewBox, distance, exponent, canvas, x2, y, channel, useWebGL = true) {
  if (!useWebGL) {
    return generateSDF_JS_Worker(width, height, path, viewBox, distance, exponent, canvas, x2, y, channel);
  }
  return generateSDF_GL(width, height, path, viewBox, distance, exponent, canvas, x2, y, channel).then(
    null,
    (err) => {
      if (!warned) {
        console.warn(`WebGL SDF generation failed, falling back to JS`, err);
        warned = true;
      }
      return generateSDF_JS_Worker(width, height, path, viewBox, distance, exponent, canvas, x2, y, channel);
    }
  );
}
var generateSDF_GL = function() {
  const queue = [];
  const chunkTimeBudget = 5;
  let timer = 0;
  function nextChunk() {
    const start = now();
    while (queue.length && now() - start < chunkTimeBudget) {
      queue.shift()();
    }
    timer = queue.length ? setTimeout(nextChunk, 0) : 0;
  }
  return (...args) => {
    const thenable = DefaultThenable();
    queue.push(() => {
      const start = now();
      try {
        mainThreadGenerator.webgl.generateIntoCanvas(...args);
        thenable.resolve({ timing: now() - start });
      } catch (err) {
        thenable.reject(err);
      }
    });
    if (!timer) {
      timer = setTimeout(nextChunk, 0);
    }
    return thenable;
  };
}();
var generateSDF_JS_Worker = function() {
  const threadCount = 4;
  const idleTimeout = 2e3;
  const threads = {};
  let callNum = 0;
  return function(width, height, path, viewBox, distance, exponent, canvas, x2, y, channel) {
    const workerId = "TroikaTextSDFGenerator_JS_" + callNum++ % threadCount;
    let thread = threads[workerId];
    if (!thread) {
      thread = threads[workerId] = {
        workerModule: defineWorkerModule({
          name: workerId,
          workerId,
          dependencies: [
            SDFGenerator,
            now
          ],
          init(_createSDFGenerator, now2) {
            const generate = _createSDFGenerator().javascript.generate;
            return function(...args) {
              const start = now2();
              const textureData = generate(...args);
              return {
                textureData,
                timing: now2() - start
              };
            };
          },
          getTransferables(result) {
            return [result.textureData.buffer];
          }
        }),
        requests: 0,
        idleTimer: null
      };
    }
    thread.requests++;
    clearTimeout(thread.idleTimer);
    return thread.workerModule(width, height, path, viewBox, distance, exponent).then(({ textureData, timing }) => {
      const start = now();
      const imageData = new Uint8Array(textureData.length * 4);
      for (let i = 0; i < textureData.length; i++) {
        imageData[i * 4 + channel] = textureData[i];
      }
      mainThreadGenerator.webglUtils.renderImageData(canvas, imageData, x2, y, width, height, 1 << 3 - channel);
      timing += now() - start;
      if (--thread.requests === 0) {
        thread.idleTimer = setTimeout(() => {
          terminateWorker(workerId);
        }, idleTimeout);
      }
      return { timing };
    });
  };
}();
function warmUpSDFCanvas(canvas) {
  if (!canvas._warm) {
    mainThreadGenerator.webgl.isSupported(canvas);
    canvas._warm = true;
  }
}
var resizeWebGLCanvasWithoutClearing = mainThreadGenerator.webglUtils.resizeWebGLCanvasWithoutClearing;
function typrFactory() {
  return "undefined" == typeof window && (self.window = self), function(r) {
    var e = { parse: function(r2) {
      var t3 = e._bin, a2 = new Uint8Array(r2);
      if ("ttcf" == t3.readASCII(a2, 0, 4)) {
        var n2 = 4;
        t3.readUshort(a2, n2), n2 += 2, t3.readUshort(a2, n2), n2 += 2;
        var o = t3.readUint(a2, n2);
        n2 += 4;
        for (var s = [], i = 0; i < o; i++) {
          var h = t3.readUint(a2, n2);
          n2 += 4, s.push(e._readFont(a2, h));
        }
        return s;
      }
      return [e._readFont(a2, 0)];
    }, _readFont: function(r2, t3) {
      var a2 = e._bin, n2 = t3;
      a2.readFixed(r2, t3), t3 += 4;
      var o = a2.readUshort(r2, t3);
      t3 += 2, a2.readUshort(r2, t3), t3 += 2, a2.readUshort(r2, t3), t3 += 2, a2.readUshort(r2, t3), t3 += 2;
      for (var s = ["cmap", "head", "hhea", "maxp", "hmtx", "name", "OS/2", "post", "loca", "glyf", "kern", "CFF ", "GPOS", "GSUB", "SVG "], i = { _data: r2, _offset: n2 }, h = {}, f = 0; f < o; f++) {
        var d = a2.readASCII(r2, t3, 4);
        t3 += 4, a2.readUint(r2, t3), t3 += 4;
        var l = a2.readUint(r2, t3);
        t3 += 4;
        var u = a2.readUint(r2, t3);
        t3 += 4, h[d] = { offset: l, length: u };
      }
      for (f = 0; f < s.length; f++) {
        var v = s[f];
        h[v] && (i[v.trim()] = e[v.trim()].parse(r2, h[v].offset, h[v].length, i));
      }
      return i;
    }, _tabOffset: function(r2, t3, a2) {
      for (var n2 = e._bin, o = n2.readUshort(r2, a2 + 4), s = a2 + 12, i = 0; i < o; i++) {
        var h = n2.readASCII(r2, s, 4);
        s += 4, n2.readUint(r2, s), s += 4;
        var f = n2.readUint(r2, s);
        if (s += 4, n2.readUint(r2, s), s += 4, h == t3)
          return f;
      }
      return 0;
    } };
    e._bin = { readFixed: function(r2, e2) {
      return (r2[e2] << 8 | r2[e2 + 1]) + (r2[e2 + 2] << 8 | r2[e2 + 3]) / 65540;
    }, readF2dot14: function(r2, t3) {
      return e._bin.readShort(r2, t3) / 16384;
    }, readInt: function(r2, t3) {
      return e._bin._view(r2).getInt32(t3);
    }, readInt8: function(r2, t3) {
      return e._bin._view(r2).getInt8(t3);
    }, readShort: function(r2, t3) {
      return e._bin._view(r2).getInt16(t3);
    }, readUshort: function(r2, t3) {
      return e._bin._view(r2).getUint16(t3);
    }, readUshorts: function(r2, t3, a2) {
      for (var n2 = [], o = 0; o < a2; o++)
        n2.push(e._bin.readUshort(r2, t3 + 2 * o));
      return n2;
    }, readUint: function(r2, t3) {
      return e._bin._view(r2).getUint32(t3);
    }, readUint64: function(r2, t3) {
      return 4294967296 * e._bin.readUint(r2, t3) + e._bin.readUint(r2, t3 + 4);
    }, readASCII: function(r2, e2, t3) {
      for (var a2 = "", n2 = 0; n2 < t3; n2++)
        a2 += String.fromCharCode(r2[e2 + n2]);
      return a2;
    }, readUnicode: function(r2, e2, t3) {
      for (var a2 = "", n2 = 0; n2 < t3; n2++) {
        var o = r2[e2++] << 8 | r2[e2++];
        a2 += String.fromCharCode(o);
      }
      return a2;
    }, _tdec: "undefined" != typeof window && window.TextDecoder ? new window.TextDecoder() : null, readUTF8: function(r2, t3, a2) {
      var n2 = e._bin._tdec;
      return n2 && 0 == t3 && a2 == r2.length ? n2.decode(r2) : e._bin.readASCII(r2, t3, a2);
    }, readBytes: function(r2, e2, t3) {
      for (var a2 = [], n2 = 0; n2 < t3; n2++)
        a2.push(r2[e2 + n2]);
      return a2;
    }, readASCIIArray: function(r2, e2, t3) {
      for (var a2 = [], n2 = 0; n2 < t3; n2++)
        a2.push(String.fromCharCode(r2[e2 + n2]));
      return a2;
    }, _view: function(r2) {
      return r2._dataView || (r2._dataView = r2.buffer ? new DataView(r2.buffer, r2.byteOffset, r2.byteLength) : new DataView(new Uint8Array(r2).buffer));
    } }, e._lctf = {}, e._lctf.parse = function(r2, t3, a2, n2, o) {
      var s = e._bin, i = {}, h = t3;
      s.readFixed(r2, t3), t3 += 4;
      var f = s.readUshort(r2, t3);
      t3 += 2;
      var d = s.readUshort(r2, t3);
      t3 += 2;
      var l = s.readUshort(r2, t3);
      return t3 += 2, i.scriptList = e._lctf.readScriptList(r2, h + f), i.featureList = e._lctf.readFeatureList(r2, h + d), i.lookupList = e._lctf.readLookupList(r2, h + l, o), i;
    }, e._lctf.readLookupList = function(r2, t3, a2) {
      var n2 = e._bin, o = t3, s = [], i = n2.readUshort(r2, t3);
      t3 += 2;
      for (var h = 0; h < i; h++) {
        var f = n2.readUshort(r2, t3);
        t3 += 2;
        var d = e._lctf.readLookupTable(r2, o + f, a2);
        s.push(d);
      }
      return s;
    }, e._lctf.readLookupTable = function(r2, t3, a2) {
      var n2 = e._bin, o = t3, s = { tabs: [] };
      s.ltype = n2.readUshort(r2, t3), t3 += 2, s.flag = n2.readUshort(r2, t3), t3 += 2;
      var i = n2.readUshort(r2, t3);
      t3 += 2;
      for (var h = s.ltype, f = 0; f < i; f++) {
        var d = n2.readUshort(r2, t3);
        t3 += 2;
        var l = a2(r2, h, o + d, s);
        s.tabs.push(l);
      }
      return s;
    }, e._lctf.numOfOnes = function(r2) {
      for (var e2 = 0, t3 = 0; t3 < 32; t3++)
        0 != (r2 >>> t3 & 1) && e2++;
      return e2;
    }, e._lctf.readClassDef = function(r2, t3) {
      var a2 = e._bin, n2 = [], o = a2.readUshort(r2, t3);
      if (t3 += 2, 1 == o) {
        var s = a2.readUshort(r2, t3);
        t3 += 2;
        var i = a2.readUshort(r2, t3);
        t3 += 2;
        for (var h = 0; h < i; h++)
          n2.push(s + h), n2.push(s + h), n2.push(a2.readUshort(r2, t3)), t3 += 2;
      }
      if (2 == o) {
        var f = a2.readUshort(r2, t3);
        t3 += 2;
        for (h = 0; h < f; h++)
          n2.push(a2.readUshort(r2, t3)), t3 += 2, n2.push(a2.readUshort(r2, t3)), t3 += 2, n2.push(a2.readUshort(r2, t3)), t3 += 2;
      }
      return n2;
    }, e._lctf.getInterval = function(r2, e2) {
      for (var t3 = 0; t3 < r2.length; t3 += 3) {
        var a2 = r2[t3], n2 = r2[t3 + 1];
        if (r2[t3 + 2], a2 <= e2 && e2 <= n2)
          return t3;
      }
      return -1;
    }, e._lctf.readCoverage = function(r2, t3) {
      var a2 = e._bin, n2 = {};
      n2.fmt = a2.readUshort(r2, t3), t3 += 2;
      var o = a2.readUshort(r2, t3);
      return t3 += 2, 1 == n2.fmt && (n2.tab = a2.readUshorts(r2, t3, o)), 2 == n2.fmt && (n2.tab = a2.readUshorts(r2, t3, 3 * o)), n2;
    }, e._lctf.coverageIndex = function(r2, t3) {
      var a2 = r2.tab;
      if (1 == r2.fmt)
        return a2.indexOf(t3);
      if (2 == r2.fmt) {
        var n2 = e._lctf.getInterval(a2, t3);
        if (-1 != n2)
          return a2[n2 + 2] + (t3 - a2[n2]);
      }
      return -1;
    }, e._lctf.readFeatureList = function(r2, t3) {
      var a2 = e._bin, n2 = t3, o = [], s = a2.readUshort(r2, t3);
      t3 += 2;
      for (var i = 0; i < s; i++) {
        var h = a2.readASCII(r2, t3, 4);
        t3 += 4;
        var f = a2.readUshort(r2, t3);
        t3 += 2;
        var d = e._lctf.readFeatureTable(r2, n2 + f);
        d.tag = h.trim(), o.push(d);
      }
      return o;
    }, e._lctf.readFeatureTable = function(r2, t3) {
      var a2 = e._bin, n2 = t3, o = {}, s = a2.readUshort(r2, t3);
      t3 += 2, s > 0 && (o.featureParams = n2 + s);
      var i = a2.readUshort(r2, t3);
      t3 += 2, o.tab = [];
      for (var h = 0; h < i; h++)
        o.tab.push(a2.readUshort(r2, t3 + 2 * h));
      return o;
    }, e._lctf.readScriptList = function(r2, t3) {
      var a2 = e._bin, n2 = t3, o = {}, s = a2.readUshort(r2, t3);
      t3 += 2;
      for (var i = 0; i < s; i++) {
        var h = a2.readASCII(r2, t3, 4);
        t3 += 4;
        var f = a2.readUshort(r2, t3);
        t3 += 2, o[h.trim()] = e._lctf.readScriptTable(r2, n2 + f);
      }
      return o;
    }, e._lctf.readScriptTable = function(r2, t3) {
      var a2 = e._bin, n2 = t3, o = {}, s = a2.readUshort(r2, t3);
      t3 += 2, o.default = e._lctf.readLangSysTable(r2, n2 + s);
      var i = a2.readUshort(r2, t3);
      t3 += 2;
      for (var h = 0; h < i; h++) {
        var f = a2.readASCII(r2, t3, 4);
        t3 += 4;
        var d = a2.readUshort(r2, t3);
        t3 += 2, o[f.trim()] = e._lctf.readLangSysTable(r2, n2 + d);
      }
      return o;
    }, e._lctf.readLangSysTable = function(r2, t3) {
      var a2 = e._bin, n2 = {};
      a2.readUshort(r2, t3), t3 += 2, n2.reqFeature = a2.readUshort(r2, t3), t3 += 2;
      var o = a2.readUshort(r2, t3);
      return t3 += 2, n2.features = a2.readUshorts(r2, t3, o), n2;
    }, e.CFF = {}, e.CFF.parse = function(r2, t3, a2) {
      var n2 = e._bin;
      (r2 = new Uint8Array(r2.buffer, t3, a2))[t3 = 0], r2[++t3], r2[++t3], r2[++t3], t3++;
      var o = [];
      t3 = e.CFF.readIndex(r2, t3, o);
      for (var s = [], i = 0; i < o.length - 1; i++)
        s.push(n2.readASCII(r2, t3 + o[i], o[i + 1] - o[i]));
      t3 += o[o.length - 1];
      var h = [];
      t3 = e.CFF.readIndex(r2, t3, h);
      var f = [];
      for (i = 0; i < h.length - 1; i++)
        f.push(e.CFF.readDict(r2, t3 + h[i], t3 + h[i + 1]));
      t3 += h[h.length - 1];
      var d = f[0], l = [];
      t3 = e.CFF.readIndex(r2, t3, l);
      var u = [];
      for (i = 0; i < l.length - 1; i++)
        u.push(n2.readASCII(r2, t3 + l[i], l[i + 1] - l[i]));
      if (t3 += l[l.length - 1], e.CFF.readSubrs(r2, t3, d), d.CharStrings) {
        t3 = d.CharStrings;
        l = [];
        t3 = e.CFF.readIndex(r2, t3, l);
        var v = [];
        for (i = 0; i < l.length - 1; i++)
          v.push(n2.readBytes(r2, t3 + l[i], l[i + 1] - l[i]));
        d.CharStrings = v;
      }
      if (d.ROS) {
        t3 = d.FDArray;
        var c = [];
        t3 = e.CFF.readIndex(r2, t3, c), d.FDArray = [];
        for (i = 0; i < c.length - 1; i++) {
          var p2 = e.CFF.readDict(r2, t3 + c[i], t3 + c[i + 1]);
          e.CFF._readFDict(r2, p2, u), d.FDArray.push(p2);
        }
        t3 += c[c.length - 1], t3 = d.FDSelect, d.FDSelect = [];
        var U = r2[t3];
        if (t3++, 3 != U)
          throw U;
        var g2 = n2.readUshort(r2, t3);
        t3 += 2;
        for (i = 0; i < g2 + 1; i++)
          d.FDSelect.push(n2.readUshort(r2, t3), r2[t3 + 2]), t3 += 3;
      }
      return d.Encoding && (d.Encoding = e.CFF.readEncoding(r2, d.Encoding, d.CharStrings.length)), d.charset && (d.charset = e.CFF.readCharset(r2, d.charset, d.CharStrings.length)), e.CFF._readFDict(r2, d, u), d;
    }, e.CFF._readFDict = function(r2, t3, a2) {
      var n2;
      for (var o in t3.Private && (n2 = t3.Private[1], t3.Private = e.CFF.readDict(r2, n2, n2 + t3.Private[0]), t3.Private.Subrs && e.CFF.readSubrs(r2, n2 + t3.Private.Subrs, t3.Private)), t3)
        -1 != ["FamilyName", "FontName", "FullName", "Notice", "version", "Copyright"].indexOf(o) && (t3[o] = a2[t3[o] - 426 + 35]);
    }, e.CFF.readSubrs = function(r2, t3, a2) {
      var n2 = e._bin, o = [];
      t3 = e.CFF.readIndex(r2, t3, o);
      var s, i = o.length;
      s = i < 1240 ? 107 : i < 33900 ? 1131 : 32768, a2.Bias = s, a2.Subrs = [];
      for (var h = 0; h < o.length - 1; h++)
        a2.Subrs.push(n2.readBytes(r2, t3 + o[h], o[h + 1] - o[h]));
    }, e.CFF.tableSE = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 0, 111, 112, 113, 114, 0, 115, 116, 117, 118, 119, 120, 121, 122, 0, 123, 0, 124, 125, 126, 127, 128, 129, 130, 131, 0, 132, 133, 0, 134, 135, 136, 137, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 138, 0, 139, 0, 0, 0, 0, 140, 141, 142, 143, 0, 0, 0, 0, 0, 144, 0, 0, 0, 145, 0, 0, 146, 147, 148, 149, 0, 0, 0, 0], e.CFF.glyphByUnicode = function(r2, e2) {
      for (var t3 = 0; t3 < r2.charset.length; t3++)
        if (r2.charset[t3] == e2)
          return t3;
      return -1;
    }, e.CFF.glyphBySE = function(r2, t3) {
      return t3 < 0 || t3 > 255 ? -1 : e.CFF.glyphByUnicode(r2, e.CFF.tableSE[t3]);
    }, e.CFF.readEncoding = function(r2, t3, a2) {
      e._bin;
      var n2 = [".notdef"], o = r2[t3];
      if (t3++, 0 != o)
        throw "error: unknown encoding format: " + o;
      var s = r2[t3];
      t3++;
      for (var i = 0; i < s; i++)
        n2.push(r2[t3 + i]);
      return n2;
    }, e.CFF.readCharset = function(r2, t3, a2) {
      var n2 = e._bin, o = [".notdef"], s = r2[t3];
      if (t3++, 0 == s)
        for (var i = 0; i < a2; i++) {
          var h = n2.readUshort(r2, t3);
          t3 += 2, o.push(h);
        }
      else {
        if (1 != s && 2 != s)
          throw "error: format: " + s;
        for (; o.length < a2; ) {
          h = n2.readUshort(r2, t3);
          t3 += 2;
          var f = 0;
          1 == s ? (f = r2[t3], t3++) : (f = n2.readUshort(r2, t3), t3 += 2);
          for (i = 0; i <= f; i++)
            o.push(h), h++;
        }
      }
      return o;
    }, e.CFF.readIndex = function(r2, t3, a2) {
      var n2 = e._bin, o = n2.readUshort(r2, t3) + 1, s = r2[t3 += 2];
      if (t3++, 1 == s)
        for (var i = 0; i < o; i++)
          a2.push(r2[t3 + i]);
      else if (2 == s)
        for (i = 0; i < o; i++)
          a2.push(n2.readUshort(r2, t3 + 2 * i));
      else if (3 == s)
        for (i = 0; i < o; i++)
          a2.push(16777215 & n2.readUint(r2, t3 + 3 * i - 1));
      else if (1 != o)
        throw "unsupported offset size: " + s + ", count: " + o;
      return (t3 += o * s) - 1;
    }, e.CFF.getCharString = function(r2, t3, a2) {
      var n2 = e._bin, o = r2[t3], s = r2[t3 + 1];
      r2[t3 + 2], r2[t3 + 3], r2[t3 + 4];
      var i = 1, h = null, f = null;
      o <= 20 && (h = o, i = 1), 12 == o && (h = 100 * o + s, i = 2), 21 <= o && o <= 27 && (h = o, i = 1), 28 == o && (f = n2.readShort(r2, t3 + 1), i = 3), 29 <= o && o <= 31 && (h = o, i = 1), 32 <= o && o <= 246 && (f = o - 139, i = 1), 247 <= o && o <= 250 && (f = 256 * (o - 247) + s + 108, i = 2), 251 <= o && o <= 254 && (f = 256 * -(o - 251) - s - 108, i = 2), 255 == o && (f = n2.readInt(r2, t3 + 1) / 65535, i = 5), a2.val = null != f ? f : "o" + h, a2.size = i;
    }, e.CFF.readCharString = function(r2, t3, a2) {
      for (var n2 = t3 + a2, o = e._bin, s = []; t3 < n2; ) {
        var i = r2[t3], h = r2[t3 + 1];
        r2[t3 + 2], r2[t3 + 3], r2[t3 + 4];
        var f = 1, d = null, l = null;
        i <= 20 && (d = i, f = 1), 12 == i && (d = 100 * i + h, f = 2), 19 != i && 20 != i || (d = i, f = 2), 21 <= i && i <= 27 && (d = i, f = 1), 28 == i && (l = o.readShort(r2, t3 + 1), f = 3), 29 <= i && i <= 31 && (d = i, f = 1), 32 <= i && i <= 246 && (l = i - 139, f = 1), 247 <= i && i <= 250 && (l = 256 * (i - 247) + h + 108, f = 2), 251 <= i && i <= 254 && (l = 256 * -(i - 251) - h - 108, f = 2), 255 == i && (l = o.readInt(r2, t3 + 1) / 65535, f = 5), s.push(null != l ? l : "o" + d), t3 += f;
      }
      return s;
    }, e.CFF.readDict = function(r2, t3, a2) {
      for (var n2 = e._bin, o = {}, s = []; t3 < a2; ) {
        var i = r2[t3], h = r2[t3 + 1];
        r2[t3 + 2], r2[t3 + 3], r2[t3 + 4];
        var f = 1, d = null, l = null;
        if (28 == i && (l = n2.readShort(r2, t3 + 1), f = 3), 29 == i && (l = n2.readInt(r2, t3 + 1), f = 5), 32 <= i && i <= 246 && (l = i - 139, f = 1), 247 <= i && i <= 250 && (l = 256 * (i - 247) + h + 108, f = 2), 251 <= i && i <= 254 && (l = 256 * -(i - 251) - h - 108, f = 2), 255 == i)
          throw l = n2.readInt(r2, t3 + 1) / 65535, f = 5, "unknown number";
        if (30 == i) {
          var u = [];
          for (f = 1; ; ) {
            var v = r2[t3 + f];
            f++;
            var c = v >> 4, p2 = 15 & v;
            if (15 != c && u.push(c), 15 != p2 && u.push(p2), 15 == p2)
              break;
          }
          for (var U = "", g2 = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, ".", "e", "e-", "reserved", "-", "endOfNumber"], S = 0; S < u.length; S++)
            U += g2[u[S]];
          l = parseFloat(U);
        }
        if (i <= 21) {
          if (d = ["version", "Notice", "FullName", "FamilyName", "Weight", "FontBBox", "BlueValues", "OtherBlues", "FamilyBlues", "FamilyOtherBlues", "StdHW", "StdVW", "escape", "UniqueID", "XUID", "charset", "Encoding", "CharStrings", "Private", "Subrs", "defaultWidthX", "nominalWidthX"][i], f = 1, 12 == i)
            d = ["Copyright", "isFixedPitch", "ItalicAngle", "UnderlinePosition", "UnderlineThickness", "PaintType", "CharstringType", "FontMatrix", "StrokeWidth", "BlueScale", "BlueShift", "BlueFuzz", "StemSnapH", "StemSnapV", "ForceBold", 0, 0, "LanguageGroup", "ExpansionFactor", "initialRandomSeed", "SyntheticBase", "PostScript", "BaseFontName", "BaseFontBlend", 0, 0, 0, 0, 0, 0, "ROS", "CIDFontVersion", "CIDFontRevision", "CIDFontType", "CIDCount", "UIDBase", "FDArray", "FDSelect", "FontName"][h], f = 2;
        }
        null != d ? (o[d] = 1 == s.length ? s[0] : s, s = []) : s.push(l), t3 += f;
      }
      return o;
    }, e.cmap = {}, e.cmap.parse = function(r2, t3, a2) {
      r2 = new Uint8Array(r2.buffer, t3, a2), t3 = 0;
      var n2 = e._bin, o = {};
      n2.readUshort(r2, t3), t3 += 2;
      var s = n2.readUshort(r2, t3);
      t3 += 2;
      var i = [];
      o.tables = [];
      for (var h = 0; h < s; h++) {
        var f = n2.readUshort(r2, t3);
        t3 += 2;
        var d = n2.readUshort(r2, t3);
        t3 += 2;
        var l = n2.readUint(r2, t3);
        t3 += 4;
        var u = "p" + f + "e" + d, v = i.indexOf(l);
        if (-1 == v) {
          var c;
          v = o.tables.length, i.push(l);
          var p2 = n2.readUshort(r2, l);
          0 == p2 ? c = e.cmap.parse0(r2, l) : 4 == p2 ? c = e.cmap.parse4(r2, l) : 6 == p2 ? c = e.cmap.parse6(r2, l) : 12 == p2 ? c = e.cmap.parse12(r2, l) : console.debug("unknown format: " + p2, f, d, l), o.tables.push(c);
        }
        if (null != o[u])
          throw "multiple tables for one platform+encoding";
        o[u] = v;
      }
      return o;
    }, e.cmap.parse0 = function(r2, t3) {
      var a2 = e._bin, n2 = {};
      n2.format = a2.readUshort(r2, t3), t3 += 2;
      var o = a2.readUshort(r2, t3);
      t3 += 2, a2.readUshort(r2, t3), t3 += 2, n2.map = [];
      for (var s = 0; s < o - 6; s++)
        n2.map.push(r2[t3 + s]);
      return n2;
    }, e.cmap.parse4 = function(r2, t3) {
      var a2 = e._bin, n2 = t3, o = {};
      o.format = a2.readUshort(r2, t3), t3 += 2;
      var s = a2.readUshort(r2, t3);
      t3 += 2, a2.readUshort(r2, t3), t3 += 2;
      var i = a2.readUshort(r2, t3);
      t3 += 2;
      var h = i / 2;
      o.searchRange = a2.readUshort(r2, t3), t3 += 2, o.entrySelector = a2.readUshort(r2, t3), t3 += 2, o.rangeShift = a2.readUshort(r2, t3), t3 += 2, o.endCount = a2.readUshorts(r2, t3, h), t3 += 2 * h, t3 += 2, o.startCount = a2.readUshorts(r2, t3, h), t3 += 2 * h, o.idDelta = [];
      for (var f = 0; f < h; f++)
        o.idDelta.push(a2.readShort(r2, t3)), t3 += 2;
      for (o.idRangeOffset = a2.readUshorts(r2, t3, h), t3 += 2 * h, o.glyphIdArray = []; t3 < n2 + s; )
        o.glyphIdArray.push(a2.readUshort(r2, t3)), t3 += 2;
      return o;
    }, e.cmap.parse6 = function(r2, t3) {
      var a2 = e._bin, n2 = {};
      n2.format = a2.readUshort(r2, t3), t3 += 2, a2.readUshort(r2, t3), t3 += 2, a2.readUshort(r2, t3), t3 += 2, n2.firstCode = a2.readUshort(r2, t3), t3 += 2;
      var o = a2.readUshort(r2, t3);
      t3 += 2, n2.glyphIdArray = [];
      for (var s = 0; s < o; s++)
        n2.glyphIdArray.push(a2.readUshort(r2, t3)), t3 += 2;
      return n2;
    }, e.cmap.parse12 = function(r2, t3) {
      var a2 = e._bin, n2 = {};
      n2.format = a2.readUshort(r2, t3), t3 += 2, t3 += 2, a2.readUint(r2, t3), t3 += 4, a2.readUint(r2, t3), t3 += 4;
      var o = a2.readUint(r2, t3);
      t3 += 4, n2.groups = [];
      for (var s = 0; s < o; s++) {
        var i = t3 + 12 * s, h = a2.readUint(r2, i + 0), f = a2.readUint(r2, i + 4), d = a2.readUint(r2, i + 8);
        n2.groups.push([h, f, d]);
      }
      return n2;
    }, e.glyf = {}, e.glyf.parse = function(r2, e2, t3, a2) {
      for (var n2 = [], o = 0; o < a2.maxp.numGlyphs; o++)
        n2.push(null);
      return n2;
    }, e.glyf._parseGlyf = function(r2, t3) {
      var a2 = e._bin, n2 = r2._data, o = e._tabOffset(n2, "glyf", r2._offset) + r2.loca[t3];
      if (r2.loca[t3] == r2.loca[t3 + 1])
        return null;
      var s = {};
      if (s.noc = a2.readShort(n2, o), o += 2, s.xMin = a2.readShort(n2, o), o += 2, s.yMin = a2.readShort(n2, o), o += 2, s.xMax = a2.readShort(n2, o), o += 2, s.yMax = a2.readShort(n2, o), o += 2, s.xMin >= s.xMax || s.yMin >= s.yMax)
        return null;
      if (s.noc > 0) {
        s.endPts = [];
        for (var i = 0; i < s.noc; i++)
          s.endPts.push(a2.readUshort(n2, o)), o += 2;
        var h = a2.readUshort(n2, o);
        if (o += 2, n2.length - o < h)
          return null;
        s.instructions = a2.readBytes(n2, o, h), o += h;
        var f = s.endPts[s.noc - 1] + 1;
        s.flags = [];
        for (i = 0; i < f; i++) {
          var d = n2[o];
          if (o++, s.flags.push(d), 0 != (8 & d)) {
            var l = n2[o];
            o++;
            for (var u = 0; u < l; u++)
              s.flags.push(d), i++;
          }
        }
        s.xs = [];
        for (i = 0; i < f; i++) {
          var v = 0 != (2 & s.flags[i]), c = 0 != (16 & s.flags[i]);
          v ? (s.xs.push(c ? n2[o] : -n2[o]), o++) : c ? s.xs.push(0) : (s.xs.push(a2.readShort(n2, o)), o += 2);
        }
        s.ys = [];
        for (i = 0; i < f; i++) {
          v = 0 != (4 & s.flags[i]), c = 0 != (32 & s.flags[i]);
          v ? (s.ys.push(c ? n2[o] : -n2[o]), o++) : c ? s.ys.push(0) : (s.ys.push(a2.readShort(n2, o)), o += 2);
        }
        var p2 = 0, U = 0;
        for (i = 0; i < f; i++)
          p2 += s.xs[i], U += s.ys[i], s.xs[i] = p2, s.ys[i] = U;
      } else {
        var g2;
        s.parts = [];
        do {
          g2 = a2.readUshort(n2, o), o += 2;
          var S = { m: { a: 1, b: 0, c: 0, d: 1, tx: 0, ty: 0 }, p1: -1, p2: -1 };
          if (s.parts.push(S), S.glyphIndex = a2.readUshort(n2, o), o += 2, 1 & g2) {
            var m = a2.readShort(n2, o);
            o += 2;
            var b = a2.readShort(n2, o);
            o += 2;
          } else {
            m = a2.readInt8(n2, o);
            o++;
            b = a2.readInt8(n2, o);
            o++;
          }
          2 & g2 ? (S.m.tx = m, S.m.ty = b) : (S.p1 = m, S.p2 = b), 8 & g2 ? (S.m.a = S.m.d = a2.readF2dot14(n2, o), o += 2) : 64 & g2 ? (S.m.a = a2.readF2dot14(n2, o), o += 2, S.m.d = a2.readF2dot14(n2, o), o += 2) : 128 & g2 && (S.m.a = a2.readF2dot14(n2, o), o += 2, S.m.b = a2.readF2dot14(n2, o), o += 2, S.m.c = a2.readF2dot14(n2, o), o += 2, S.m.d = a2.readF2dot14(n2, o), o += 2);
        } while (32 & g2);
        if (256 & g2) {
          var y = a2.readUshort(n2, o);
          o += 2, s.instr = [];
          for (i = 0; i < y; i++)
            s.instr.push(n2[o]), o++;
        }
      }
      return s;
    }, e.GPOS = {}, e.GPOS.parse = function(r2, t3, a2, n2) {
      return e._lctf.parse(r2, t3, a2, n2, e.GPOS.subt);
    }, e.GPOS.subt = function(r2, t3, a2, n2) {
      var o = e._bin, s = a2, i = {};
      if (i.fmt = o.readUshort(r2, a2), a2 += 2, 1 == t3 || 2 == t3 || 3 == t3 || 7 == t3 || 8 == t3 && i.fmt <= 2) {
        var h = o.readUshort(r2, a2);
        a2 += 2, i.coverage = e._lctf.readCoverage(r2, h + s);
      }
      if (1 == t3 && 1 == i.fmt) {
        var f = o.readUshort(r2, a2);
        a2 += 2;
        var d = e._lctf.numOfOnes(f);
        0 != f && (i.pos = e.GPOS.readValueRecord(r2, a2, f));
      } else if (2 == t3 && i.fmt >= 1 && i.fmt <= 2) {
        f = o.readUshort(r2, a2);
        a2 += 2;
        var l = o.readUshort(r2, a2);
        a2 += 2;
        d = e._lctf.numOfOnes(f);
        var u = e._lctf.numOfOnes(l);
        if (1 == i.fmt) {
          i.pairsets = [];
          var v = o.readUshort(r2, a2);
          a2 += 2;
          for (var c = 0; c < v; c++) {
            var p2 = s + o.readUshort(r2, a2);
            a2 += 2;
            var U = o.readUshort(r2, p2);
            p2 += 2;
            for (var g2 = [], S = 0; S < U; S++) {
              var m = o.readUshort(r2, p2);
              p2 += 2, 0 != f && (x2 = e.GPOS.readValueRecord(r2, p2, f), p2 += 2 * d), 0 != l && (P = e.GPOS.readValueRecord(r2, p2, l), p2 += 2 * u), g2.push({ gid2: m, val1: x2, val2: P });
            }
            i.pairsets.push(g2);
          }
        }
        if (2 == i.fmt) {
          var b = o.readUshort(r2, a2);
          a2 += 2;
          var y = o.readUshort(r2, a2);
          a2 += 2;
          var F = o.readUshort(r2, a2);
          a2 += 2;
          var _ = o.readUshort(r2, a2);
          a2 += 2, i.classDef1 = e._lctf.readClassDef(r2, s + b), i.classDef2 = e._lctf.readClassDef(r2, s + y), i.matrix = [];
          for (c = 0; c < F; c++) {
            var C2 = [];
            for (S = 0; S < _; S++) {
              var x2 = null, P = null;
              0 != f && (x2 = e.GPOS.readValueRecord(r2, a2, f), a2 += 2 * d), 0 != l && (P = e.GPOS.readValueRecord(r2, a2, l), a2 += 2 * u), C2.push({ val1: x2, val2: P });
            }
            i.matrix.push(C2);
          }
        }
      } else {
        if (9 == t3 && 1 == i.fmt) {
          var I2 = o.readUshort(r2, a2);
          a2 += 2;
          var w = o.readUint(r2, a2);
          if (a2 += 4, 9 == n2.ltype)
            n2.ltype = I2;
          else if (n2.ltype != I2)
            throw "invalid extension substitution";
          return e.GPOS.subt(r2, n2.ltype, s + w);
        }
        console.debug("unsupported GPOS table LookupType", t3, "format", i.fmt);
      }
      return i;
    }, e.GPOS.readValueRecord = function(r2, t3, a2) {
      var n2 = e._bin, o = [];
      return o.push(1 & a2 ? n2.readShort(r2, t3) : 0), t3 += 1 & a2 ? 2 : 0, o.push(2 & a2 ? n2.readShort(r2, t3) : 0), t3 += 2 & a2 ? 2 : 0, o.push(4 & a2 ? n2.readShort(r2, t3) : 0), t3 += 4 & a2 ? 2 : 0, o.push(8 & a2 ? n2.readShort(r2, t3) : 0), t3 += 8 & a2 ? 2 : 0, o;
    }, e.GSUB = {}, e.GSUB.parse = function(r2, t3, a2, n2) {
      return e._lctf.parse(r2, t3, a2, n2, e.GSUB.subt);
    }, e.GSUB.subt = function(r2, t3, a2, n2) {
      var o = e._bin, s = a2, i = {};
      if (i.fmt = o.readUshort(r2, a2), a2 += 2, 1 != t3 && 4 != t3 && 5 != t3 && 6 != t3)
        return null;
      if (1 == t3 || 4 == t3 || 5 == t3 && i.fmt <= 2 || 6 == t3 && i.fmt <= 2) {
        var h = o.readUshort(r2, a2);
        a2 += 2, i.coverage = e._lctf.readCoverage(r2, s + h);
      }
      if (1 == t3 && i.fmt >= 1 && i.fmt <= 2) {
        if (1 == i.fmt)
          i.delta = o.readShort(r2, a2), a2 += 2;
        else if (2 == i.fmt) {
          var f = o.readUshort(r2, a2);
          a2 += 2, i.newg = o.readUshorts(r2, a2, f), a2 += 2 * i.newg.length;
        }
      } else if (4 == t3) {
        i.vals = [];
        f = o.readUshort(r2, a2);
        a2 += 2;
        for (var d = 0; d < f; d++) {
          var l = o.readUshort(r2, a2);
          a2 += 2, i.vals.push(e.GSUB.readLigatureSet(r2, s + l));
        }
      } else if (5 == t3 && 2 == i.fmt) {
        if (2 == i.fmt) {
          var u = o.readUshort(r2, a2);
          a2 += 2, i.cDef = e._lctf.readClassDef(r2, s + u), i.scset = [];
          var v = o.readUshort(r2, a2);
          a2 += 2;
          for (d = 0; d < v; d++) {
            var c = o.readUshort(r2, a2);
            a2 += 2, i.scset.push(0 == c ? null : e.GSUB.readSubClassSet(r2, s + c));
          }
        }
      } else if (6 == t3 && 3 == i.fmt) {
        if (3 == i.fmt) {
          for (d = 0; d < 3; d++) {
            f = o.readUshort(r2, a2);
            a2 += 2;
            for (var p2 = [], U = 0; U < f; U++)
              p2.push(e._lctf.readCoverage(r2, s + o.readUshort(r2, a2 + 2 * U)));
            a2 += 2 * f, 0 == d && (i.backCvg = p2), 1 == d && (i.inptCvg = p2), 2 == d && (i.ahedCvg = p2);
          }
          f = o.readUshort(r2, a2);
          a2 += 2, i.lookupRec = e.GSUB.readSubstLookupRecords(r2, a2, f);
        }
      } else {
        if (7 == t3 && 1 == i.fmt) {
          var g2 = o.readUshort(r2, a2);
          a2 += 2;
          var S = o.readUint(r2, a2);
          if (a2 += 4, 9 == n2.ltype)
            n2.ltype = g2;
          else if (n2.ltype != g2)
            throw "invalid extension substitution";
          return e.GSUB.subt(r2, n2.ltype, s + S);
        }
        console.debug("unsupported GSUB table LookupType", t3, "format", i.fmt);
      }
      return i;
    }, e.GSUB.readSubClassSet = function(r2, t3) {
      var a2 = e._bin.readUshort, n2 = t3, o = [], s = a2(r2, t3);
      t3 += 2;
      for (var i = 0; i < s; i++) {
        var h = a2(r2, t3);
        t3 += 2, o.push(e.GSUB.readSubClassRule(r2, n2 + h));
      }
      return o;
    }, e.GSUB.readSubClassRule = function(r2, t3) {
      var a2 = e._bin.readUshort, n2 = {}, o = a2(r2, t3), s = a2(r2, t3 += 2);
      t3 += 2, n2.input = [];
      for (var i = 0; i < o - 1; i++)
        n2.input.push(a2(r2, t3)), t3 += 2;
      return n2.substLookupRecords = e.GSUB.readSubstLookupRecords(r2, t3, s), n2;
    }, e.GSUB.readSubstLookupRecords = function(r2, t3, a2) {
      for (var n2 = e._bin.readUshort, o = [], s = 0; s < a2; s++)
        o.push(n2(r2, t3), n2(r2, t3 + 2)), t3 += 4;
      return o;
    }, e.GSUB.readChainSubClassSet = function(r2, t3) {
      var a2 = e._bin, n2 = t3, o = [], s = a2.readUshort(r2, t3);
      t3 += 2;
      for (var i = 0; i < s; i++) {
        var h = a2.readUshort(r2, t3);
        t3 += 2, o.push(e.GSUB.readChainSubClassRule(r2, n2 + h));
      }
      return o;
    }, e.GSUB.readChainSubClassRule = function(r2, t3) {
      for (var a2 = e._bin, n2 = {}, o = ["backtrack", "input", "lookahead"], s = 0; s < o.length; s++) {
        var i = a2.readUshort(r2, t3);
        t3 += 2, 1 == s && i--, n2[o[s]] = a2.readUshorts(r2, t3, i), t3 += 2 * n2[o[s]].length;
      }
      i = a2.readUshort(r2, t3);
      return t3 += 2, n2.subst = a2.readUshorts(r2, t3, 2 * i), t3 += 2 * n2.subst.length, n2;
    }, e.GSUB.readLigatureSet = function(r2, t3) {
      var a2 = e._bin, n2 = t3, o = [], s = a2.readUshort(r2, t3);
      t3 += 2;
      for (var i = 0; i < s; i++) {
        var h = a2.readUshort(r2, t3);
        t3 += 2, o.push(e.GSUB.readLigature(r2, n2 + h));
      }
      return o;
    }, e.GSUB.readLigature = function(r2, t3) {
      var a2 = e._bin, n2 = { chain: [] };
      n2.nglyph = a2.readUshort(r2, t3), t3 += 2;
      var o = a2.readUshort(r2, t3);
      t3 += 2;
      for (var s = 0; s < o - 1; s++)
        n2.chain.push(a2.readUshort(r2, t3)), t3 += 2;
      return n2;
    }, e.head = {}, e.head.parse = function(r2, t3, a2) {
      var n2 = e._bin, o = {};
      return n2.readFixed(r2, t3), t3 += 4, o.fontRevision = n2.readFixed(r2, t3), t3 += 4, n2.readUint(r2, t3), t3 += 4, n2.readUint(r2, t3), t3 += 4, o.flags = n2.readUshort(r2, t3), t3 += 2, o.unitsPerEm = n2.readUshort(r2, t3), t3 += 2, o.created = n2.readUint64(r2, t3), t3 += 8, o.modified = n2.readUint64(r2, t3), t3 += 8, o.xMin = n2.readShort(r2, t3), t3 += 2, o.yMin = n2.readShort(r2, t3), t3 += 2, o.xMax = n2.readShort(r2, t3), t3 += 2, o.yMax = n2.readShort(r2, t3), t3 += 2, o.macStyle = n2.readUshort(r2, t3), t3 += 2, o.lowestRecPPEM = n2.readUshort(r2, t3), t3 += 2, o.fontDirectionHint = n2.readShort(r2, t3), t3 += 2, o.indexToLocFormat = n2.readShort(r2, t3), t3 += 2, o.glyphDataFormat = n2.readShort(r2, t3), t3 += 2, o;
    }, e.hhea = {}, e.hhea.parse = function(r2, t3, a2) {
      var n2 = e._bin, o = {};
      return n2.readFixed(r2, t3), t3 += 4, o.ascender = n2.readShort(r2, t3), t3 += 2, o.descender = n2.readShort(r2, t3), t3 += 2, o.lineGap = n2.readShort(r2, t3), t3 += 2, o.advanceWidthMax = n2.readUshort(r2, t3), t3 += 2, o.minLeftSideBearing = n2.readShort(r2, t3), t3 += 2, o.minRightSideBearing = n2.readShort(r2, t3), t3 += 2, o.xMaxExtent = n2.readShort(r2, t3), t3 += 2, o.caretSlopeRise = n2.readShort(r2, t3), t3 += 2, o.caretSlopeRun = n2.readShort(r2, t3), t3 += 2, o.caretOffset = n2.readShort(r2, t3), t3 += 2, t3 += 8, o.metricDataFormat = n2.readShort(r2, t3), t3 += 2, o.numberOfHMetrics = n2.readUshort(r2, t3), t3 += 2, o;
    }, e.hmtx = {}, e.hmtx.parse = function(r2, t3, a2, n2) {
      for (var o = e._bin, s = { aWidth: [], lsBearing: [] }, i = 0, h = 0, f = 0; f < n2.maxp.numGlyphs; f++)
        f < n2.hhea.numberOfHMetrics && (i = o.readUshort(r2, t3), t3 += 2, h = o.readShort(r2, t3), t3 += 2), s.aWidth.push(i), s.lsBearing.push(h);
      return s;
    }, e.kern = {}, e.kern.parse = function(r2, t3, a2, n2) {
      var o = e._bin, s = o.readUshort(r2, t3);
      if (t3 += 2, 1 == s)
        return e.kern.parseV1(r2, t3 - 2, a2, n2);
      var i = o.readUshort(r2, t3);
      t3 += 2;
      for (var h = { glyph1: [], rval: [] }, f = 0; f < i; f++) {
        t3 += 2;
        a2 = o.readUshort(r2, t3);
        t3 += 2;
        var d = o.readUshort(r2, t3);
        t3 += 2;
        var l = d >>> 8;
        if (0 != (l &= 15))
          throw "unknown kern table format: " + l;
        t3 = e.kern.readFormat0(r2, t3, h);
      }
      return h;
    }, e.kern.parseV1 = function(r2, t3, a2, n2) {
      var o = e._bin;
      o.readFixed(r2, t3), t3 += 4;
      var s = o.readUint(r2, t3);
      t3 += 4;
      for (var i = { glyph1: [], rval: [] }, h = 0; h < s; h++) {
        o.readUint(r2, t3), t3 += 4;
        var f = o.readUshort(r2, t3);
        t3 += 2, o.readUshort(r2, t3), t3 += 2;
        var d = f >>> 8;
        if (0 != (d &= 15))
          throw "unknown kern table format: " + d;
        t3 = e.kern.readFormat0(r2, t3, i);
      }
      return i;
    }, e.kern.readFormat0 = function(r2, t3, a2) {
      var n2 = e._bin, o = -1, s = n2.readUshort(r2, t3);
      t3 += 2, n2.readUshort(r2, t3), t3 += 2, n2.readUshort(r2, t3), t3 += 2, n2.readUshort(r2, t3), t3 += 2;
      for (var i = 0; i < s; i++) {
        var h = n2.readUshort(r2, t3);
        t3 += 2;
        var f = n2.readUshort(r2, t3);
        t3 += 2;
        var d = n2.readShort(r2, t3);
        t3 += 2, h != o && (a2.glyph1.push(h), a2.rval.push({ glyph2: [], vals: [] }));
        var l = a2.rval[a2.rval.length - 1];
        l.glyph2.push(f), l.vals.push(d), o = h;
      }
      return t3;
    }, e.loca = {}, e.loca.parse = function(r2, t3, a2, n2) {
      var o = e._bin, s = [], i = n2.head.indexToLocFormat, h = n2.maxp.numGlyphs + 1;
      if (0 == i)
        for (var f = 0; f < h; f++)
          s.push(o.readUshort(r2, t3 + (f << 1)) << 1);
      if (1 == i)
        for (f = 0; f < h; f++)
          s.push(o.readUint(r2, t3 + (f << 2)));
      return s;
    }, e.maxp = {}, e.maxp.parse = function(r2, t3, a2) {
      var n2 = e._bin, o = {}, s = n2.readUint(r2, t3);
      return t3 += 4, o.numGlyphs = n2.readUshort(r2, t3), t3 += 2, 65536 == s && (o.maxPoints = n2.readUshort(r2, t3), t3 += 2, o.maxContours = n2.readUshort(r2, t3), t3 += 2, o.maxCompositePoints = n2.readUshort(r2, t3), t3 += 2, o.maxCompositeContours = n2.readUshort(r2, t3), t3 += 2, o.maxZones = n2.readUshort(r2, t3), t3 += 2, o.maxTwilightPoints = n2.readUshort(r2, t3), t3 += 2, o.maxStorage = n2.readUshort(r2, t3), t3 += 2, o.maxFunctionDefs = n2.readUshort(r2, t3), t3 += 2, o.maxInstructionDefs = n2.readUshort(r2, t3), t3 += 2, o.maxStackElements = n2.readUshort(r2, t3), t3 += 2, o.maxSizeOfInstructions = n2.readUshort(r2, t3), t3 += 2, o.maxComponentElements = n2.readUshort(r2, t3), t3 += 2, o.maxComponentDepth = n2.readUshort(r2, t3), t3 += 2), o;
    }, e.name = {}, e.name.parse = function(r2, t3, a2) {
      var n2 = e._bin, o = {};
      n2.readUshort(r2, t3), t3 += 2;
      var s = n2.readUshort(r2, t3);
      t3 += 2, n2.readUshort(r2, t3);
      for (var i, h = ["copyright", "fontFamily", "fontSubfamily", "ID", "fullName", "version", "postScriptName", "trademark", "manufacturer", "designer", "description", "urlVendor", "urlDesigner", "licence", "licenceURL", "---", "typoFamilyName", "typoSubfamilyName", "compatibleFull", "sampleText", "postScriptCID", "wwsFamilyName", "wwsSubfamilyName", "lightPalette", "darkPalette"], f = t3 += 2, d = 0; d < s; d++) {
        var l = n2.readUshort(r2, t3);
        t3 += 2;
        var u = n2.readUshort(r2, t3);
        t3 += 2;
        var v = n2.readUshort(r2, t3);
        t3 += 2;
        var c = n2.readUshort(r2, t3);
        t3 += 2;
        var p2 = n2.readUshort(r2, t3);
        t3 += 2;
        var U = n2.readUshort(r2, t3);
        t3 += 2;
        var g2, S = h[c], m = f + 12 * s + U;
        if (0 == l)
          g2 = n2.readUnicode(r2, m, p2 / 2);
        else if (3 == l && 0 == u)
          g2 = n2.readUnicode(r2, m, p2 / 2);
        else if (0 == u)
          g2 = n2.readASCII(r2, m, p2);
        else if (1 == u)
          g2 = n2.readUnicode(r2, m, p2 / 2);
        else if (3 == u)
          g2 = n2.readUnicode(r2, m, p2 / 2);
        else {
          if (1 != l)
            throw "unknown encoding " + u + ", platformID: " + l;
          g2 = n2.readASCII(r2, m, p2), console.debug("reading unknown MAC encoding " + u + " as ASCII");
        }
        var b = "p" + l + "," + v.toString(16);
        null == o[b] && (o[b] = {}), o[b][void 0 !== S ? S : c] = g2, o[b]._lang = v;
      }
      for (var y in o)
        if (null != o[y].postScriptName && 1033 == o[y]._lang)
          return o[y];
      for (var y in o)
        if (null != o[y].postScriptName && 0 == o[y]._lang)
          return o[y];
      for (var y in o)
        if (null != o[y].postScriptName && 3084 == o[y]._lang)
          return o[y];
      for (var y in o)
        if (null != o[y].postScriptName)
          return o[y];
      for (var y in o) {
        i = y;
        break;
      }
      return console.debug("returning name table with languageID " + o[i]._lang), o[i];
    }, e["OS/2"] = {}, e["OS/2"].parse = function(r2, t3, a2) {
      var n2 = e._bin.readUshort(r2, t3);
      t3 += 2;
      var o = {};
      if (0 == n2)
        e["OS/2"].version0(r2, t3, o);
      else if (1 == n2)
        e["OS/2"].version1(r2, t3, o);
      else if (2 == n2 || 3 == n2 || 4 == n2)
        e["OS/2"].version2(r2, t3, o);
      else {
        if (5 != n2)
          throw "unknown OS/2 table version: " + n2;
        e["OS/2"].version5(r2, t3, o);
      }
      return o;
    }, e["OS/2"].version0 = function(r2, t3, a2) {
      var n2 = e._bin;
      return a2.xAvgCharWidth = n2.readShort(r2, t3), t3 += 2, a2.usWeightClass = n2.readUshort(r2, t3), t3 += 2, a2.usWidthClass = n2.readUshort(r2, t3), t3 += 2, a2.fsType = n2.readUshort(r2, t3), t3 += 2, a2.ySubscriptXSize = n2.readShort(r2, t3), t3 += 2, a2.ySubscriptYSize = n2.readShort(r2, t3), t3 += 2, a2.ySubscriptXOffset = n2.readShort(r2, t3), t3 += 2, a2.ySubscriptYOffset = n2.readShort(r2, t3), t3 += 2, a2.ySuperscriptXSize = n2.readShort(r2, t3), t3 += 2, a2.ySuperscriptYSize = n2.readShort(r2, t3), t3 += 2, a2.ySuperscriptXOffset = n2.readShort(r2, t3), t3 += 2, a2.ySuperscriptYOffset = n2.readShort(r2, t3), t3 += 2, a2.yStrikeoutSize = n2.readShort(r2, t3), t3 += 2, a2.yStrikeoutPosition = n2.readShort(r2, t3), t3 += 2, a2.sFamilyClass = n2.readShort(r2, t3), t3 += 2, a2.panose = n2.readBytes(r2, t3, 10), t3 += 10, a2.ulUnicodeRange1 = n2.readUint(r2, t3), t3 += 4, a2.ulUnicodeRange2 = n2.readUint(r2, t3), t3 += 4, a2.ulUnicodeRange3 = n2.readUint(r2, t3), t3 += 4, a2.ulUnicodeRange4 = n2.readUint(r2, t3), t3 += 4, a2.achVendID = [n2.readInt8(r2, t3), n2.readInt8(r2, t3 + 1), n2.readInt8(r2, t3 + 2), n2.readInt8(r2, t3 + 3)], t3 += 4, a2.fsSelection = n2.readUshort(r2, t3), t3 += 2, a2.usFirstCharIndex = n2.readUshort(r2, t3), t3 += 2, a2.usLastCharIndex = n2.readUshort(r2, t3), t3 += 2, a2.sTypoAscender = n2.readShort(r2, t3), t3 += 2, a2.sTypoDescender = n2.readShort(r2, t3), t3 += 2, a2.sTypoLineGap = n2.readShort(r2, t3), t3 += 2, a2.usWinAscent = n2.readUshort(r2, t3), t3 += 2, a2.usWinDescent = n2.readUshort(r2, t3), t3 += 2;
    }, e["OS/2"].version1 = function(r2, t3, a2) {
      var n2 = e._bin;
      return t3 = e["OS/2"].version0(r2, t3, a2), a2.ulCodePageRange1 = n2.readUint(r2, t3), t3 += 4, a2.ulCodePageRange2 = n2.readUint(r2, t3), t3 += 4;
    }, e["OS/2"].version2 = function(r2, t3, a2) {
      var n2 = e._bin;
      return t3 = e["OS/2"].version1(r2, t3, a2), a2.sxHeight = n2.readShort(r2, t3), t3 += 2, a2.sCapHeight = n2.readShort(r2, t3), t3 += 2, a2.usDefault = n2.readUshort(r2, t3), t3 += 2, a2.usBreak = n2.readUshort(r2, t3), t3 += 2, a2.usMaxContext = n2.readUshort(r2, t3), t3 += 2;
    }, e["OS/2"].version5 = function(r2, t3, a2) {
      var n2 = e._bin;
      return t3 = e["OS/2"].version2(r2, t3, a2), a2.usLowerOpticalPointSize = n2.readUshort(r2, t3), t3 += 2, a2.usUpperOpticalPointSize = n2.readUshort(r2, t3), t3 += 2;
    }, e.post = {}, e.post.parse = function(r2, t3, a2) {
      var n2 = e._bin, o = {};
      return o.version = n2.readFixed(r2, t3), t3 += 4, o.italicAngle = n2.readFixed(r2, t3), t3 += 4, o.underlinePosition = n2.readShort(r2, t3), t3 += 2, o.underlineThickness = n2.readShort(r2, t3), t3 += 2, o;
    }, null == e && (e = {}), null == e.U && (e.U = {}), e.U.codeToGlyph = function(r2, e2) {
      var t3 = r2.cmap, a2 = -1;
      if (null != t3.p0e4 ? a2 = t3.p0e4 : null != t3.p3e1 ? a2 = t3.p3e1 : null != t3.p1e0 ? a2 = t3.p1e0 : null != t3.p0e3 && (a2 = t3.p0e3), -1 == a2)
        throw "no familiar platform and encoding!";
      var n2 = t3.tables[a2];
      if (0 == n2.format)
        return e2 >= n2.map.length ? 0 : n2.map[e2];
      if (4 == n2.format) {
        for (var o = -1, s = 0; s < n2.endCount.length; s++)
          if (e2 <= n2.endCount[s]) {
            o = s;
            break;
          }
        if (-1 == o)
          return 0;
        if (n2.startCount[o] > e2)
          return 0;
        return 65535 & (0 != n2.idRangeOffset[o] ? n2.glyphIdArray[e2 - n2.startCount[o] + (n2.idRangeOffset[o] >> 1) - (n2.idRangeOffset.length - o)] : e2 + n2.idDelta[o]);
      }
      if (12 == n2.format) {
        if (e2 > n2.groups[n2.groups.length - 1][1])
          return 0;
        for (s = 0; s < n2.groups.length; s++) {
          var i = n2.groups[s];
          if (i[0] <= e2 && e2 <= i[1])
            return i[2] + (e2 - i[0]);
        }
        return 0;
      }
      throw "unknown cmap table format " + n2.format;
    }, e.U.glyphToPath = function(r2, t3) {
      var a2 = { cmds: [], crds: [] };
      if (r2.SVG && r2.SVG.entries[t3]) {
        var n2 = r2.SVG.entries[t3];
        return null == n2 ? a2 : ("string" == typeof n2 && (n2 = e.SVG.toPath(n2), r2.SVG.entries[t3] = n2), n2);
      }
      if (r2.CFF) {
        var o = { x: 0, y: 0, stack: [], nStems: 0, haveWidth: false, width: r2.CFF.Private ? r2.CFF.Private.defaultWidthX : 0, open: false }, s = r2.CFF, i = r2.CFF.Private;
        if (s.ROS) {
          for (var h = 0; s.FDSelect[h + 2] <= t3; )
            h += 2;
          i = s.FDArray[s.FDSelect[h + 1]].Private;
        }
        e.U._drawCFF(r2.CFF.CharStrings[t3], o, s, i, a2);
      } else
        r2.glyf && e.U._drawGlyf(t3, r2, a2);
      return a2;
    }, e.U._drawGlyf = function(r2, t3, a2) {
      var n2 = t3.glyf[r2];
      null == n2 && (n2 = t3.glyf[r2] = e.glyf._parseGlyf(t3, r2)), null != n2 && (n2.noc > -1 ? e.U._simpleGlyph(n2, a2) : e.U._compoGlyph(n2, t3, a2));
    }, e.U._simpleGlyph = function(r2, t3) {
      for (var a2 = 0; a2 < r2.noc; a2++) {
        for (var n2 = 0 == a2 ? 0 : r2.endPts[a2 - 1] + 1, o = r2.endPts[a2], s = n2; s <= o; s++) {
          var i = s == n2 ? o : s - 1, h = s == o ? n2 : s + 1, f = 1 & r2.flags[s], d = 1 & r2.flags[i], l = 1 & r2.flags[h], u = r2.xs[s], v = r2.ys[s];
          if (s == n2)
            if (f) {
              if (!d) {
                e.U.P.moveTo(t3, u, v);
                continue;
              }
              e.U.P.moveTo(t3, r2.xs[i], r2.ys[i]);
            } else
              d ? e.U.P.moveTo(t3, r2.xs[i], r2.ys[i]) : e.U.P.moveTo(t3, (r2.xs[i] + u) / 2, (r2.ys[i] + v) / 2);
          f ? d && e.U.P.lineTo(t3, u, v) : l ? e.U.P.qcurveTo(t3, u, v, r2.xs[h], r2.ys[h]) : e.U.P.qcurveTo(t3, u, v, (u + r2.xs[h]) / 2, (v + r2.ys[h]) / 2);
        }
        e.U.P.closePath(t3);
      }
    }, e.U._compoGlyph = function(r2, t3, a2) {
      for (var n2 = 0; n2 < r2.parts.length; n2++) {
        var o = { cmds: [], crds: [] }, s = r2.parts[n2];
        e.U._drawGlyf(s.glyphIndex, t3, o);
        for (var i = s.m, h = 0; h < o.crds.length; h += 2) {
          var f = o.crds[h], d = o.crds[h + 1];
          a2.crds.push(f * i.a + d * i.b + i.tx), a2.crds.push(f * i.c + d * i.d + i.ty);
        }
        for (h = 0; h < o.cmds.length; h++)
          a2.cmds.push(o.cmds[h]);
      }
    }, e.U._getGlyphClass = function(r2, t3) {
      var a2 = e._lctf.getInterval(t3, r2);
      return -1 == a2 ? 0 : t3[a2 + 2];
    }, e.U.getPairAdjustment = function(r2, t3, a2) {
      var n2 = 0, o = false;
      if (r2.GPOS)
        for (var s = r2.GPOS, i = s.lookupList, h = s.featureList, f = [], d = 0; d < h.length; d++) {
          var l = h[d];
          if ("kern" == l.tag) {
            o = true;
            for (var u = 0; u < l.tab.length; u++)
              if (!f[l.tab[u]]) {
                f[l.tab[u]] = true;
                for (var v = i[l.tab[u]], c = 0; c < v.tabs.length; c++)
                  if (null != v.tabs[c]) {
                    var p2, U = v.tabs[c];
                    if (!U.coverage || -1 != (p2 = e._lctf.coverageIndex(U.coverage, t3))) {
                      if (1 == v.ltype)
                        ;
                      else if (2 == v.ltype) {
                        var g2;
                        if (1 == U.fmt) {
                          var S = U.pairsets[p2];
                          for (d = 0; d < S.length; d++)
                            S[d].gid2 == a2 && (g2 = S[d]);
                        } else if (2 == U.fmt) {
                          var m = e.U._getGlyphClass(t3, U.classDef1), b = e.U._getGlyphClass(a2, U.classDef2);
                          g2 = U.matrix[m][b];
                        }
                        g2 && g2.val1 && g2.val1[2] && (n2 += g2.val1[2]), g2 && g2.val2 && g2.val2[0] && (n2 += g2.val2[0]);
                      }
                    }
                  }
              }
          }
        }
      if (r2.kern && !o) {
        var y = r2.kern.glyph1.indexOf(t3);
        if (-1 != y) {
          var F = r2.kern.rval[y].glyph2.indexOf(a2);
          -1 != F && (n2 += r2.kern.rval[y].vals[F]);
        }
      }
      return n2;
    }, e.U._applySubs = function(r2, t3, a2, n2) {
      for (var o = r2.length - t3 - 1, s = 0; s < a2.tabs.length; s++)
        if (null != a2.tabs[s]) {
          var i, h = a2.tabs[s];
          if (!h.coverage || -1 != (i = e._lctf.coverageIndex(h.coverage, r2[t3]))) {
            if (1 == a2.ltype)
              r2[t3], 1 == h.fmt ? r2[t3] = r2[t3] + h.delta : r2[t3] = h.newg[i];
            else if (4 == a2.ltype)
              for (var f = h.vals[i], d = 0; d < f.length; d++) {
                var l = f[d], u = l.chain.length;
                if (!(u > o)) {
                  for (var v = true, c = 0, p2 = 0; p2 < u; p2++) {
                    for (; -1 == r2[t3 + c + (1 + p2)]; )
                      c++;
                    l.chain[p2] != r2[t3 + c + (1 + p2)] && (v = false);
                  }
                  if (v) {
                    r2[t3] = l.nglyph;
                    for (p2 = 0; p2 < u + c; p2++)
                      r2[t3 + p2 + 1] = -1;
                    break;
                  }
                }
              }
            else if (5 == a2.ltype && 2 == h.fmt)
              for (var U = e._lctf.getInterval(h.cDef, r2[t3]), g2 = h.cDef[U + 2], S = h.scset[g2], m = 0; m < S.length; m++) {
                var b = S[m], y = b.input;
                if (!(y.length > o)) {
                  for (v = true, p2 = 0; p2 < y.length; p2++) {
                    var F = e._lctf.getInterval(h.cDef, r2[t3 + 1 + p2]);
                    if (-1 == U && h.cDef[F + 2] != y[p2]) {
                      v = false;
                      break;
                    }
                  }
                  if (v) {
                    var _ = b.substLookupRecords;
                    for (d = 0; d < _.length; d += 2)
                      _[d], _[d + 1];
                  }
                }
              }
            else if (6 == a2.ltype && 3 == h.fmt) {
              if (!e.U._glsCovered(r2, h.backCvg, t3 - h.backCvg.length))
                continue;
              if (!e.U._glsCovered(r2, h.inptCvg, t3))
                continue;
              if (!e.U._glsCovered(r2, h.ahedCvg, t3 + h.inptCvg.length))
                continue;
              var C2 = h.lookupRec;
              for (m = 0; m < C2.length; m += 2) {
                U = C2[m];
                var x2 = n2[C2[m + 1]];
                e.U._applySubs(r2, t3 + U, x2, n2);
              }
            }
          }
        }
    }, e.U._glsCovered = function(r2, t3, a2) {
      for (var n2 = 0; n2 < t3.length; n2++) {
        if (-1 == e._lctf.coverageIndex(t3[n2], r2[a2 + n2]))
          return false;
      }
      return true;
    }, e.U.glyphsToPath = function(r2, t3, a2) {
      for (var n2 = { cmds: [], crds: [] }, o = 0, s = 0; s < t3.length; s++) {
        var i = t3[s];
        if (-1 != i) {
          for (var h = s < t3.length - 1 && -1 != t3[s + 1] ? t3[s + 1] : 0, f = e.U.glyphToPath(r2, i), d = 0; d < f.crds.length; d += 2)
            n2.crds.push(f.crds[d] + o), n2.crds.push(f.crds[d + 1]);
          a2 && n2.cmds.push(a2);
          for (d = 0; d < f.cmds.length; d++)
            n2.cmds.push(f.cmds[d]);
          a2 && n2.cmds.push("X"), o += r2.hmtx.aWidth[i], s < t3.length - 1 && (o += e.U.getPairAdjustment(r2, i, h));
        }
      }
      return n2;
    }, e.U.P = {}, e.U.P.moveTo = function(r2, e2, t3) {
      r2.cmds.push("M"), r2.crds.push(e2, t3);
    }, e.U.P.lineTo = function(r2, e2, t3) {
      r2.cmds.push("L"), r2.crds.push(e2, t3);
    }, e.U.P.curveTo = function(r2, e2, t3, a2, n2, o, s) {
      r2.cmds.push("C"), r2.crds.push(e2, t3, a2, n2, o, s);
    }, e.U.P.qcurveTo = function(r2, e2, t3, a2, n2) {
      r2.cmds.push("Q"), r2.crds.push(e2, t3, a2, n2);
    }, e.U.P.closePath = function(r2) {
      r2.cmds.push("Z");
    }, e.U._drawCFF = function(r2, t3, a2, n2, o) {
      for (var s = t3.stack, i = t3.nStems, h = t3.haveWidth, f = t3.width, d = t3.open, l = 0, u = t3.x, v = t3.y, c = 0, p2 = 0, U = 0, g2 = 0, S = 0, m = 0, b = 0, y = 0, F = 0, _ = 0, C2 = { val: 0, size: 0 }; l < r2.length; ) {
        e.CFF.getCharString(r2, l, C2);
        var x2 = C2.val;
        if (l += C2.size, "o1" == x2 || "o18" == x2)
          s.length % 2 != 0 && !h && (f = s.shift() + n2.nominalWidthX), i += s.length >> 1, s.length = 0, h = true;
        else if ("o3" == x2 || "o23" == x2) {
          s.length % 2 != 0 && !h && (f = s.shift() + n2.nominalWidthX), i += s.length >> 1, s.length = 0, h = true;
        } else if ("o4" == x2)
          s.length > 1 && !h && (f = s.shift() + n2.nominalWidthX, h = true), d && e.U.P.closePath(o), v += s.pop(), e.U.P.moveTo(o, u, v), d = true;
        else if ("o5" == x2)
          for (; s.length > 0; )
            u += s.shift(), v += s.shift(), e.U.P.lineTo(o, u, v);
        else if ("o6" == x2 || "o7" == x2)
          for (var P = s.length, I2 = "o6" == x2, w = 0; w < P; w++) {
            var O = s.shift();
            I2 ? u += O : v += O, I2 = !I2, e.U.P.lineTo(o, u, v);
          }
        else if ("o8" == x2 || "o24" == x2) {
          P = s.length;
          for (var T = 0; T + 6 <= P; )
            c = u + s.shift(), p2 = v + s.shift(), U = c + s.shift(), g2 = p2 + s.shift(), u = U + s.shift(), v = g2 + s.shift(), e.U.P.curveTo(o, c, p2, U, g2, u, v), T += 6;
          "o24" == x2 && (u += s.shift(), v += s.shift(), e.U.P.lineTo(o, u, v));
        } else {
          if ("o11" == x2)
            break;
          if ("o1234" == x2 || "o1235" == x2 || "o1236" == x2 || "o1237" == x2)
            "o1234" == x2 && (p2 = v, U = (c = u + s.shift()) + s.shift(), _ = g2 = p2 + s.shift(), m = g2, y = v, u = (b = (S = (F = U + s.shift()) + s.shift()) + s.shift()) + s.shift(), e.U.P.curveTo(o, c, p2, U, g2, F, _), e.U.P.curveTo(o, S, m, b, y, u, v)), "o1235" == x2 && (c = u + s.shift(), p2 = v + s.shift(), U = c + s.shift(), g2 = p2 + s.shift(), F = U + s.shift(), _ = g2 + s.shift(), S = F + s.shift(), m = _ + s.shift(), b = S + s.shift(), y = m + s.shift(), u = b + s.shift(), v = y + s.shift(), s.shift(), e.U.P.curveTo(o, c, p2, U, g2, F, _), e.U.P.curveTo(o, S, m, b, y, u, v)), "o1236" == x2 && (c = u + s.shift(), p2 = v + s.shift(), U = c + s.shift(), _ = g2 = p2 + s.shift(), m = g2, b = (S = (F = U + s.shift()) + s.shift()) + s.shift(), y = m + s.shift(), u = b + s.shift(), e.U.P.curveTo(o, c, p2, U, g2, F, _), e.U.P.curveTo(o, S, m, b, y, u, v)), "o1237" == x2 && (c = u + s.shift(), p2 = v + s.shift(), U = c + s.shift(), g2 = p2 + s.shift(), F = U + s.shift(), _ = g2 + s.shift(), S = F + s.shift(), m = _ + s.shift(), b = S + s.shift(), y = m + s.shift(), Math.abs(b - u) > Math.abs(y - v) ? u = b + s.shift() : v = y + s.shift(), e.U.P.curveTo(o, c, p2, U, g2, F, _), e.U.P.curveTo(o, S, m, b, y, u, v));
          else if ("o14" == x2) {
            if (s.length > 0 && !h && (f = s.shift() + a2.nominalWidthX, h = true), 4 == s.length) {
              var k = s.shift(), G = s.shift(), D = s.shift(), B2 = s.shift(), L = e.CFF.glyphBySE(a2, D), R = e.CFF.glyphBySE(a2, B2);
              e.U._drawCFF(a2.CharStrings[L], t3, a2, n2, o), t3.x = k, t3.y = G, e.U._drawCFF(a2.CharStrings[R], t3, a2, n2, o);
            }
            d && (e.U.P.closePath(o), d = false);
          } else if ("o19" == x2 || "o20" == x2) {
            s.length % 2 != 0 && !h && (f = s.shift() + n2.nominalWidthX), i += s.length >> 1, s.length = 0, h = true, l += i + 7 >> 3;
          } else if ("o21" == x2)
            s.length > 2 && !h && (f = s.shift() + n2.nominalWidthX, h = true), v += s.pop(), u += s.pop(), d && e.U.P.closePath(o), e.U.P.moveTo(o, u, v), d = true;
          else if ("o22" == x2)
            s.length > 1 && !h && (f = s.shift() + n2.nominalWidthX, h = true), u += s.pop(), d && e.U.P.closePath(o), e.U.P.moveTo(o, u, v), d = true;
          else if ("o25" == x2) {
            for (; s.length > 6; )
              u += s.shift(), v += s.shift(), e.U.P.lineTo(o, u, v);
            c = u + s.shift(), p2 = v + s.shift(), U = c + s.shift(), g2 = p2 + s.shift(), u = U + s.shift(), v = g2 + s.shift(), e.U.P.curveTo(o, c, p2, U, g2, u, v);
          } else if ("o26" == x2)
            for (s.length % 2 && (u += s.shift()); s.length > 0; )
              c = u, p2 = v + s.shift(), u = U = c + s.shift(), v = (g2 = p2 + s.shift()) + s.shift(), e.U.P.curveTo(o, c, p2, U, g2, u, v);
          else if ("o27" == x2)
            for (s.length % 2 && (v += s.shift()); s.length > 0; )
              p2 = v, U = (c = u + s.shift()) + s.shift(), g2 = p2 + s.shift(), u = U + s.shift(), v = g2, e.U.P.curveTo(o, c, p2, U, g2, u, v);
          else if ("o10" == x2 || "o29" == x2) {
            var A2 = "o10" == x2 ? n2 : a2;
            if (0 == s.length)
              console.debug("error: empty stack");
            else {
              var W = s.pop(), M = A2.Subrs[W + A2.Bias];
              t3.x = u, t3.y = v, t3.nStems = i, t3.haveWidth = h, t3.width = f, t3.open = d, e.U._drawCFF(M, t3, a2, n2, o), u = t3.x, v = t3.y, i = t3.nStems, h = t3.haveWidth, f = t3.width, d = t3.open;
            }
          } else if ("o30" == x2 || "o31" == x2) {
            var V = s.length, N = (T = 0, "o31" == x2);
            for (T += V - (P = -3 & V); T < P; )
              N ? (p2 = v, U = (c = u + s.shift()) + s.shift(), v = (g2 = p2 + s.shift()) + s.shift(), P - T == 5 ? (u = U + s.shift(), T++) : u = U, N = false) : (c = u, p2 = v + s.shift(), U = c + s.shift(), g2 = p2 + s.shift(), u = U + s.shift(), P - T == 5 ? (v = g2 + s.shift(), T++) : v = g2, N = true), e.U.P.curveTo(o, c, p2, U, g2, u, v), T += 4;
          } else {
            if ("o" == (x2 + "").charAt(0))
              throw console.debug("Unknown operation: " + x2, r2), x2;
            s.push(x2);
          }
        }
      }
      t3.x = u, t3.y = v, t3.nStems = i, t3.haveWidth = h, t3.width = f, t3.open = d;
    };
    var t2 = e, a = { Typr: t2 };
    return r.Typr = t2, r.default = a, Object.defineProperty(r, "__esModule", { value: true }), r;
  }({}).Typr;
}
function woff2otfFactory() {
  return function(r) {
    var e = Uint8Array, n2 = Uint16Array, t2 = Uint32Array, a = new e([0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0, 0, 0, 0]), i = new e([0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13, 0, 0]), o = new e([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]), f = function(r2, e2) {
      for (var a2 = new n2(31), i2 = 0; i2 < 31; ++i2)
        a2[i2] = e2 += 1 << r2[i2 - 1];
      var o2 = new t2(a2[30]);
      for (i2 = 1; i2 < 30; ++i2)
        for (var f2 = a2[i2]; f2 < a2[i2 + 1]; ++f2)
          o2[f2] = f2 - a2[i2] << 5 | i2;
      return [a2, o2];
    }, u = f(a, 2), v = u[0], s = u[1];
    v[28] = 258, s[258] = 28;
    for (var l = f(i, 0)[0], c = new n2(32768), g2 = 0; g2 < 32768; ++g2) {
      var h = (43690 & g2) >>> 1 | (21845 & g2) << 1;
      h = (61680 & (h = (52428 & h) >>> 2 | (13107 & h) << 2)) >>> 4 | (3855 & h) << 4, c[g2] = ((65280 & h) >>> 8 | (255 & h) << 8) >>> 1;
    }
    var w = function(r2, e2, t3) {
      for (var a2 = r2.length, i2 = 0, o2 = new n2(e2); i2 < a2; ++i2)
        ++o2[r2[i2] - 1];
      var f2, u2 = new n2(e2);
      for (i2 = 0; i2 < e2; ++i2)
        u2[i2] = u2[i2 - 1] + o2[i2 - 1] << 1;
      if (t3) {
        f2 = new n2(1 << e2);
        var v2 = 15 - e2;
        for (i2 = 0; i2 < a2; ++i2)
          if (r2[i2])
            for (var s2 = i2 << 4 | r2[i2], l2 = e2 - r2[i2], g3 = u2[r2[i2] - 1]++ << l2, h2 = g3 | (1 << l2) - 1; g3 <= h2; ++g3)
              f2[c[g3] >>> v2] = s2;
      } else
        for (f2 = new n2(a2), i2 = 0; i2 < a2; ++i2)
          r2[i2] && (f2[i2] = c[u2[r2[i2] - 1]++] >>> 15 - r2[i2]);
      return f2;
    }, d = new e(288);
    for (g2 = 0; g2 < 144; ++g2)
      d[g2] = 8;
    for (g2 = 144; g2 < 256; ++g2)
      d[g2] = 9;
    for (g2 = 256; g2 < 280; ++g2)
      d[g2] = 7;
    for (g2 = 280; g2 < 288; ++g2)
      d[g2] = 8;
    var m = new e(32);
    for (g2 = 0; g2 < 32; ++g2)
      m[g2] = 5;
    var b = w(d, 9, 1), p2 = w(m, 5, 1), y = function(r2) {
      for (var e2 = r2[0], n3 = 1; n3 < r2.length; ++n3)
        r2[n3] > e2 && (e2 = r2[n3]);
      return e2;
    }, L = function(r2, e2, n3) {
      var t3 = e2 / 8 | 0;
      return (r2[t3] | r2[t3 + 1] << 8) >> (7 & e2) & n3;
    }, U = function(r2, e2) {
      var n3 = e2 / 8 | 0;
      return (r2[n3] | r2[n3 + 1] << 8 | r2[n3 + 2] << 16) >> (7 & e2);
    }, k = ["unexpected EOF", "invalid block type", "invalid length/literal", "invalid distance", "stream finished", "no stream handler", , "no callback", "invalid UTF-8 data", "extra field too long", "date not in range 1980-2099", "filename too long", "stream finishing", "invalid zip data"], T = function(r2, e2, n3) {
      var t3 = new Error(e2 || k[r2]);
      if (t3.code = r2, Error.captureStackTrace && Error.captureStackTrace(t3, T), !n3)
        throw t3;
      return t3;
    }, O = function(r2, f2, u2) {
      var s2 = r2.length;
      if (!s2 || u2 && !u2.l && s2 < 5)
        return f2 || new e(0);
      var c2 = !f2 || u2, g3 = !u2 || u2.i;
      u2 || (u2 = {}), f2 || (f2 = new e(3 * s2));
      var h2, d2 = function(r3) {
        var n3 = f2.length;
        if (r3 > n3) {
          var t3 = new e(Math.max(2 * n3, r3));
          t3.set(f2), f2 = t3;
        }
      }, m2 = u2.f || 0, k2 = u2.p || 0, O2 = u2.b || 0, A3 = u2.l, x3 = u2.d, E = u2.m, D = u2.n, M = 8 * s2;
      do {
        if (!A3) {
          u2.f = m2 = L(r2, k2, 1);
          var S = L(r2, k2 + 1, 3);
          if (k2 += 3, !S) {
            var V = r2[(I2 = ((h2 = k2) / 8 | 0) + (7 & h2 && 1) + 4) - 4] | r2[I2 - 3] << 8, _ = I2 + V;
            if (_ > s2) {
              g3 && T(0);
              break;
            }
            c2 && d2(O2 + V), f2.set(r2.subarray(I2, _), O2), u2.b = O2 += V, u2.p = k2 = 8 * _;
            continue;
          }
          if (1 == S)
            A3 = b, x3 = p2, E = 9, D = 5;
          else if (2 == S) {
            var j = L(r2, k2, 31) + 257, z = L(r2, k2 + 10, 15) + 4, C2 = j + L(r2, k2 + 5, 31) + 1;
            k2 += 14;
            for (var F = new e(C2), P = new e(19), q = 0; q < z; ++q)
              P[o[q]] = L(r2, k2 + 3 * q, 7);
            k2 += 3 * z;
            var B2 = y(P), G = (1 << B2) - 1, H = w(P, B2, 1);
            for (q = 0; q < C2; ) {
              var I2, J = H[L(r2, k2, G)];
              if (k2 += 15 & J, (I2 = J >>> 4) < 16)
                F[q++] = I2;
              else {
                var K = 0, N = 0;
                for (16 == I2 ? (N = 3 + L(r2, k2, 3), k2 += 2, K = F[q - 1]) : 17 == I2 ? (N = 3 + L(r2, k2, 7), k2 += 3) : 18 == I2 && (N = 11 + L(r2, k2, 127), k2 += 7); N--; )
                  F[q++] = K;
              }
            }
            var Q2 = F.subarray(0, j), R = F.subarray(j);
            E = y(Q2), D = y(R), A3 = w(Q2, E, 1), x3 = w(R, D, 1);
          } else
            T(1);
          if (k2 > M) {
            g3 && T(0);
            break;
          }
        }
        c2 && d2(O2 + 131072);
        for (var W = (1 << E) - 1, X = (1 << D) - 1, Y = k2; ; Y = k2) {
          var Z = (K = A3[U(r2, k2) & W]) >>> 4;
          if ((k2 += 15 & K) > M) {
            g3 && T(0);
            break;
          }
          if (K || T(2), Z < 256)
            f2[O2++] = Z;
          else {
            if (256 == Z) {
              Y = k2, A3 = null;
              break;
            }
            var $ = Z - 254;
            if (Z > 264) {
              var rr = a[q = Z - 257];
              $ = L(r2, k2, (1 << rr) - 1) + v[q], k2 += rr;
            }
            var er = x3[U(r2, k2) & X], nr = er >>> 4;
            er || T(3), k2 += 15 & er;
            R = l[nr];
            if (nr > 3) {
              rr = i[nr];
              R += U(r2, k2) & (1 << rr) - 1, k2 += rr;
            }
            if (k2 > M) {
              g3 && T(0);
              break;
            }
            c2 && d2(O2 + 131072);
            for (var tr = O2 + $; O2 < tr; O2 += 4)
              f2[O2] = f2[O2 - R], f2[O2 + 1] = f2[O2 + 1 - R], f2[O2 + 2] = f2[O2 + 2 - R], f2[O2 + 3] = f2[O2 + 3 - R];
            O2 = tr;
          }
        }
        u2.l = A3, u2.p = Y, u2.b = O2, A3 && (m2 = 1, u2.m = E, u2.d = x3, u2.n = D);
      } while (!m2);
      return O2 == f2.length ? f2 : function(r3, a2, i2) {
        (null == a2 || a2 < 0) && (a2 = 0), (null == i2 || i2 > r3.length) && (i2 = r3.length);
        var o2 = new (r3 instanceof n2 ? n2 : r3 instanceof t2 ? t2 : e)(i2 - a2);
        return o2.set(r3.subarray(a2, i2)), o2;
      }(f2, 0, O2);
    }, A2 = new e(0);
    var x2 = "undefined" != typeof TextDecoder && new TextDecoder();
    try {
      x2.decode(A2, { stream: true }), 1;
    } catch (r2) {
    }
    return r.convert_streams = function(r2) {
      var e2 = new DataView(r2), n3 = 0;
      function t3() {
        var r3 = e2.getUint16(n3);
        return n3 += 2, r3;
      }
      function a2() {
        var r3 = e2.getUint32(n3);
        return n3 += 4, r3;
      }
      function i2(r3) {
        m2.setUint16(b2, r3), b2 += 2;
      }
      function o2(r3) {
        m2.setUint32(b2, r3), b2 += 4;
      }
      for (var f2 = { signature: a2(), flavor: a2(), length: a2(), numTables: t3(), reserved: t3(), totalSfntSize: a2(), majorVersion: t3(), minorVersion: t3(), metaOffset: a2(), metaLength: a2(), metaOrigLength: a2(), privOffset: a2(), privLength: a2() }, u2 = 0; Math.pow(2, u2) <= f2.numTables; )
        u2++;
      u2--;
      for (var v2 = 16 * Math.pow(2, u2), s2 = 16 * f2.numTables - v2, l2 = 12, c2 = [], g3 = 0; g3 < f2.numTables; g3++)
        c2.push({ tag: a2(), offset: a2(), compLength: a2(), origLength: a2(), origChecksum: a2() }), l2 += 16;
      var h2, w2 = new Uint8Array(12 + 16 * c2.length + c2.reduce(function(r3, e3) {
        return r3 + e3.origLength + 4;
      }, 0)), d2 = w2.buffer, m2 = new DataView(d2), b2 = 0;
      return o2(f2.flavor), i2(f2.numTables), i2(v2), i2(u2), i2(s2), c2.forEach(function(r3) {
        o2(r3.tag), o2(r3.origChecksum), o2(l2), o2(r3.origLength), r3.outOffset = l2, (l2 += r3.origLength) % 4 != 0 && (l2 += 4 - l2 % 4);
      }), c2.forEach(function(e3) {
        var n4, t4 = r2.slice(e3.offset, e3.offset + e3.compLength);
        if (e3.compLength != e3.origLength) {
          var a3 = new Uint8Array(e3.origLength);
          n4 = new Uint8Array(t4, 2), O(n4, a3);
        } else
          a3 = new Uint8Array(t4);
        w2.set(a3, e3.outOffset);
        var i3 = 0;
        (l2 = e3.outOffset + e3.origLength) % 4 != 0 && (i3 = 4 - l2 % 4), w2.set(new Uint8Array(i3).buffer, e3.outOffset + e3.origLength), h2 = l2 + i3;
      }), d2.slice(0, h2);
    }, Object.defineProperty(r, "__esModule", { value: true }), r;
  }({}).convert_streams;
}
function parserFactory(Typr, woff2otf) {
  const cmdArgLengths = {
    M: 2,
    L: 2,
    Q: 4,
    C: 6,
    Z: 0
  };
  const joiningTypeRawData = { "C": "18g,ca,368,1kz", "D": "17k,6,2,2+4,5+c,2+6,2+1,10+1,9+f,j+11,2+1,a,2,2+1,15+2,3,j+2,6+3,2+8,2,2,2+1,w+a,4+e,3+3,2,3+2,3+5,23+w,2f+4,3,2+9,2,b,2+3,3,1k+9,6+1,3+1,2+2,2+d,30g,p+y,1,1+1g,f+x,2,sd2+1d,jf3+4,f+3,2+4,2+2,b+3,42,2,4+2,2+1,2,3,t+1,9f+w,2,el+2,2+g,d+2,2l,2+1,5,3+1,2+1,2,3,6,16wm+1v", "R": "17m+3,2,2,6+3,m,15+2,2+2,h+h,13,3+8,2,2,3+1,2,p+1,x,5+4,5,a,2,2,3,u,c+2,g+1,5,2+1,4+1,5j,6+1,2,b,2+2,f,2+1,1s+2,2,3+1,7,1ez0,2,2+1,4+4,b,4,3,b,42,2+2,4,3,2+1,2,o+3,ae,ep,x,2o+2,3+1,3,5+1,6", "L": "x9u,jff,a,fd,jv", "T": "4t,gj+33,7o+4,1+1,7c+18,2,2+1,2+1,2,21+a,2,1b+k,h,2u+6,3+5,3+1,2+3,y,2,v+q,2k+a,1n+8,a,p+3,2+8,2+2,2+4,18+2,3c+e,2+v,1k,2,5+7,5,4+6,b+1,u,1n,5+3,9,l+1,r,3+1,1m,5+1,5+1,3+2,4,v+1,4,c+1,1m,5+4,2+1,5,l+1,n+5,2,1n,3,2+3,9,8+1,c+1,v,1q,d,1f,4,1m+2,6+2,2+3,8+1,c+1,u,1n,3,7,6+1,l+1,t+1,1m+1,5+3,9,l+1,u,21,8+2,2,2j,3+6,d+7,2r,3+8,c+5,23+1,s,2,2,1k+d,2+4,2+1,6+a,2+z,a,2v+3,2+5,2+1,3+1,q+1,5+2,h+3,e,3+1,7,g,jk+2,qb+2,u+2,u+1,v+1,1t+1,2+6,9,3+a,a,1a+2,3c+1,z,3b+2,5+1,a,7+2,64+1,3,1n,2+6,2,2,3+7,7+9,3,1d+d,1,1+1,1s+3,1d,2+4,2,6,15+8,d+1,x+3,3+1,2+2,1l,2+1,4,2+2,1n+7,3+1,49+2,2+c,2+6,5,7,4+1,5j+1l,2+4,ek,3+1,r+4,1e+4,6+5,2p+c,1+3,1,1+2,1+b,2db+2,3y,2p+v,ff+3,30+1,n9x,1+2,2+9,x+1,29+1,7l,4,5,q+1,6,48+1,r+h,e,13+7,q+a,1b+2,1d,3+3,3+1,14,1w+5,3+1,3+1,d,9,1c,1g,2+2,3+1,6+1,2,17+1,9,6n,3,5,fn5,ki+f,h+f,5s,6y+2,ea,6b,46+4,1af+2,2+1,6+3,15+2,5,4m+1,fy+3,as+1,4a+a,4x,1j+e,1l+2,1e+3,3+1,1y+2,11+4,2+7,1r,d+1,1h+8,b+3,3,2o+2,3,2+1,7,4h,4+7,m+1,1m+1,4,12+6,4+4,5g+7,3+2,2,o,2d+5,2,5+1,2+1,6n+3,7+1,2+1,s+1,2e+7,3,2+1,2z,2,3+5,2,2u+2,3+3,2+4,78+8,2+1,75+1,2,5,41+3,3+1,5,x+9,15+5,3+3,9,a+5,3+2,1b+c,2+1,bb+6,2+5,2,2b+l,3+6,2+1,2+1,3f+5,4,2+1,2+6,2,21+1,4,2,9o+1,470+8,at4+4,1o+6,t5,1s+3,2a,f5l+1,2+3,43o+2,a+7,1+7,3+6,v+3,45+2,1j0+1i,5+1d,9,f,n+4,2+e,11t+6,2+g,3+6,2+1,2+4,7a+6,c6+3,15t+6,32+6,1,gzau,v+2n,3l+6n" };
  const JT_LEFT = 1, JT_RIGHT = 2, JT_DUAL = 4, JT_TRANSPARENT = 8, JT_JOIN_CAUSING = 16, JT_NON_JOINING = 32;
  let joiningTypeMap;
  function getCharJoiningType(ch) {
    if (!joiningTypeMap) {
      const m = {
        R: JT_RIGHT,
        L: JT_LEFT,
        D: JT_DUAL,
        C: JT_JOIN_CAUSING,
        U: JT_NON_JOINING,
        T: JT_TRANSPARENT
      };
      joiningTypeMap = /* @__PURE__ */ new Map();
      for (let type in joiningTypeRawData) {
        let lastCode = 0;
        joiningTypeRawData[type].split(",").forEach((range) => {
          let [skip, step] = range.split("+");
          skip = parseInt(skip, 36);
          step = step ? parseInt(step, 36) : 0;
          joiningTypeMap.set(lastCode += skip, m[type]);
          for (let i = step; i--; ) {
            joiningTypeMap.set(++lastCode, m[type]);
          }
        });
      }
    }
    return joiningTypeMap.get(ch) || JT_NON_JOINING;
  }
  const ISOL = 1, INIT = 2, FINA = 3, MEDI = 4;
  const formsToFeatures = [null, "isol", "init", "fina", "medi"];
  function detectJoiningForms(str) {
    const joiningForms = new Uint8Array(str.length);
    let prevJoiningType = JT_NON_JOINING;
    let prevForm = ISOL;
    let prevIndex = -1;
    for (let i = 0; i < str.length; i++) {
      const code = str.codePointAt(i);
      let joiningType = getCharJoiningType(code) | 0;
      let form = ISOL;
      if (joiningType & JT_TRANSPARENT) {
        continue;
      }
      if (prevJoiningType & (JT_LEFT | JT_DUAL | JT_JOIN_CAUSING)) {
        if (joiningType & (JT_RIGHT | JT_DUAL | JT_JOIN_CAUSING)) {
          form = FINA;
          if (prevForm === ISOL || prevForm === FINA) {
            joiningForms[prevIndex]++;
          }
        } else if (joiningType & (JT_LEFT | JT_NON_JOINING)) {
          if (prevForm === INIT || prevForm === MEDI) {
            joiningForms[prevIndex]--;
          }
        }
      } else if (prevJoiningType & (JT_RIGHT | JT_NON_JOINING)) {
        if (prevForm === INIT || prevForm === MEDI) {
          joiningForms[prevIndex]--;
        }
      }
      prevForm = joiningForms[i] = form;
      prevJoiningType = joiningType;
      prevIndex = i;
      if (code > 65535)
        i++;
    }
    return joiningForms;
  }
  function stringToGlyphs(font, str) {
    const glyphIds = [];
    for (let i = 0; i < str.length; i++) {
      const cc = str.codePointAt(i);
      if (cc > 65535)
        i++;
      glyphIds.push(Typr.U.codeToGlyph(font, cc));
    }
    const gsub = font["GSUB"];
    if (gsub) {
      const { lookupList, featureList } = gsub;
      let joiningForms;
      const supportedFeatures = /^(rlig|liga|mset|isol|init|fina|medi|half|pres|blws)$/;
      const usedLookups = [];
      featureList.forEach((feature) => {
        if (supportedFeatures.test(feature.tag)) {
          for (let ti = 0; ti < feature.tab.length; ti++) {
            if (usedLookups[feature.tab[ti]])
              continue;
            usedLookups[feature.tab[ti]] = true;
            const tab = lookupList[feature.tab[ti]];
            const isJoiningFeature = /^(isol|init|fina|medi)$/.test(feature.tag);
            if (isJoiningFeature && !joiningForms) {
              joiningForms = detectJoiningForms(str);
            }
            for (let ci = 0; ci < glyphIds.length; ci++) {
              if (!joiningForms || !isJoiningFeature || formsToFeatures[joiningForms[ci]] === feature.tag) {
                Typr.U._applySubs(glyphIds, ci, tab, lookupList);
              }
            }
          }
        }
      });
    }
    return glyphIds;
  }
  function wrapFontObj(typrFont) {
    const glyphMap = /* @__PURE__ */ Object.create(null);
    const fontObj = {
      unitsPerEm: typrFont.head.unitsPerEm,
      ascender: typrFont.hhea.ascender,
      descender: typrFont.hhea.descender,
      forEachGlyph(text, fontSize, letterSpacing, callback) {
        let glyphX = 0;
        const fontScale = 1 / fontObj.unitsPerEm * fontSize;
        const glyphIndices = stringToGlyphs(typrFont, text);
        let charIndex = 0;
        let prevGlyphIndex = -1;
        glyphIndices.forEach((glyphIndex, i) => {
          if (glyphIndex !== -1) {
            let glyphObj = glyphMap[glyphIndex];
            if (!glyphObj) {
              const { cmds, crds } = Typr.U.glyphToPath(typrFont, glyphIndex);
              let path = "";
              let crdsIdx = 0;
              for (let i2 = 0, len = cmds.length; i2 < len; i2++) {
                const numArgs = cmdArgLengths[cmds[i2]];
                path += cmds[i2];
                for (let j = 1; j <= numArgs; j++) {
                  path += (j > 1 ? "," : "") + crds[crdsIdx++];
                }
              }
              let xMin, yMin, xMax, yMax;
              if (crds.length) {
                xMin = yMin = Infinity;
                xMax = yMax = -Infinity;
                for (let i2 = 0, len = crds.length; i2 < len; i2 += 2) {
                  let x2 = crds[i2];
                  let y = crds[i2 + 1];
                  if (x2 < xMin)
                    xMin = x2;
                  if (y < yMin)
                    yMin = y;
                  if (x2 > xMax)
                    xMax = x2;
                  if (y > yMax)
                    yMax = y;
                }
              } else {
                xMin = xMax = yMin = yMax = 0;
              }
              glyphObj = glyphMap[glyphIndex] = {
                index: glyphIndex,
                advanceWidth: typrFont.hmtx.aWidth[glyphIndex],
                xMin,
                yMin,
                xMax,
                yMax,
                path,
                pathCommandCount: cmds.length
                // forEachPathCommand(callback) {
                //   let argsIndex = 0
                //   const argsArray = []
                //   for (let i = 0, len = cmds.length; i < len; i++) {
                //     const numArgs = cmdArgLengths[cmds[i]]
                //     argsArray.length = 1 + numArgs
                //     argsArray[0] = cmds[i]
                //     for (let j = 1; j <= numArgs; j++) {
                //       argsArray[j] = crds[argsIndex++]
                //     }
                //     callback.apply(null, argsArray)
                //   }
                // }
              };
            }
            if (prevGlyphIndex !== -1) {
              glyphX += Typr.U.getPairAdjustment(typrFont, prevGlyphIndex, glyphIndex) * fontScale;
            }
            callback.call(null, glyphObj, glyphX, charIndex);
            if (glyphObj.advanceWidth) {
              glyphX += glyphObj.advanceWidth * fontScale;
            }
            if (letterSpacing) {
              glyphX += letterSpacing * fontSize;
            }
            prevGlyphIndex = glyphIndex;
          }
          charIndex += text.codePointAt(charIndex) > 65535 ? 2 : 1;
        });
        return glyphX;
      }
    };
    return fontObj;
  }
  return function parse(buffer) {
    const peek = new Uint8Array(buffer, 0, 4);
    const tag = Typr._bin.readASCII(peek, 0, 4);
    if (tag === "wOFF") {
      buffer = woff2otf(buffer);
    } else if (tag === "wOF2") {
      throw new Error("woff2 fonts not supported");
    }
    return wrapFontObj(Typr.parse(buffer)[0]);
  };
}
var workerModule = defineWorkerModule({
  name: "Typr Font Parser",
  dependencies: [typrFactory, woff2otfFactory, parserFactory],
  init(typrFactory2, woff2otfFactory2, parserFactory2) {
    const Typr = typrFactory2();
    const woff2otf = woff2otfFactory2();
    return parserFactory2(Typr, woff2otf);
  }
});
var CONFIG = {
  defaultFontURL: "https://fonts.gstatic.com/s/roboto/v18/KFOmCnqEu92Fr1Mu4mxM.woff",
  //Roboto Regular
  sdfGlyphSize: 64,
  sdfMargin: 1 / 16,
  sdfExponent: 9,
  textureWidth: 2048
};
var tempColor = new Color();
var hasRequested = false;
function now$1() {
  return (self.performance || Date).now();
}
var atlases = /* @__PURE__ */ Object.create(null);
function getTextRenderInfo(args, callback) {
  hasRequested = true;
  args = assign2({}, args);
  const totalStart = now$1();
  args.font = toAbsoluteURL(args.font || CONFIG.defaultFontURL);
  args.text = "" + args.text;
  args.sdfGlyphSize = args.sdfGlyphSize || CONFIG.sdfGlyphSize;
  if (args.colorRanges != null) {
    let colors = {};
    for (let key in args.colorRanges) {
      if (args.colorRanges.hasOwnProperty(key)) {
        let val = args.colorRanges[key];
        if (typeof val !== "number") {
          val = tempColor.set(val).getHex();
        }
        colors[key] = val;
      }
    }
    args.colorRanges = colors;
  }
  Object.freeze(args);
  const { textureWidth, sdfExponent } = CONFIG;
  const { sdfGlyphSize } = args;
  const glyphsPerRow = textureWidth / sdfGlyphSize * 4;
  let atlas = atlases[sdfGlyphSize];
  if (!atlas) {
    const canvas = document.createElement("canvas");
    canvas.width = textureWidth;
    canvas.height = sdfGlyphSize * 256 / glyphsPerRow;
    atlas = atlases[sdfGlyphSize] = {
      glyphCount: 0,
      sdfGlyphSize,
      sdfCanvas: canvas,
      sdfTexture: new Texture(
        canvas,
        void 0,
        void 0,
        void 0,
        LinearFilter,
        LinearFilter
      ),
      contextLost: false,
      glyphsByFont: /* @__PURE__ */ new Map()
    };
    atlas.sdfTexture.generateMipmaps = false;
    initContextLossHandling(atlas);
  }
  const { sdfTexture, sdfCanvas } = atlas;
  let fontGlyphs = atlas.glyphsByFont.get(args.font);
  if (!fontGlyphs) {
    atlas.glyphsByFont.set(args.font, fontGlyphs = /* @__PURE__ */ new Map());
  }
  typesetInWorker(args).then((result) => {
    const { glyphIds, glyphPositions, fontSize, unitsPerEm, timings } = result;
    const neededSDFs = [];
    const glyphBounds = new Float32Array(glyphIds.length * 4);
    const fontSizeMult = fontSize / unitsPerEm;
    let boundsIdx = 0;
    let positionsIdx = 0;
    const quadsStart = now$1();
    glyphIds.forEach((glyphId, i) => {
      let glyphInfo = fontGlyphs.get(glyphId);
      if (!glyphInfo) {
        const { path, pathBounds } = result.glyphData[glyphId];
        const fontUnitsMargin = Math.max(pathBounds[2] - pathBounds[0], pathBounds[3] - pathBounds[1]) / sdfGlyphSize * (CONFIG.sdfMargin * sdfGlyphSize + 0.5);
        const atlasIndex = atlas.glyphCount++;
        const sdfViewBox2 = [
          pathBounds[0] - fontUnitsMargin,
          pathBounds[1] - fontUnitsMargin,
          pathBounds[2] + fontUnitsMargin,
          pathBounds[3] + fontUnitsMargin
        ];
        fontGlyphs.set(glyphId, glyphInfo = { path, atlasIndex, sdfViewBox: sdfViewBox2 });
        neededSDFs.push(glyphInfo);
      }
      const { sdfViewBox } = glyphInfo;
      const posX = glyphPositions[positionsIdx++];
      const posY = glyphPositions[positionsIdx++];
      glyphBounds[boundsIdx++] = posX + sdfViewBox[0] * fontSizeMult;
      glyphBounds[boundsIdx++] = posY + sdfViewBox[1] * fontSizeMult;
      glyphBounds[boundsIdx++] = posX + sdfViewBox[2] * fontSizeMult;
      glyphBounds[boundsIdx++] = posY + sdfViewBox[3] * fontSizeMult;
      glyphIds[i] = glyphInfo.atlasIndex;
    });
    timings.quads = (timings.quads || 0) + (now$1() - quadsStart);
    const sdfStart = now$1();
    timings.sdf = {};
    const currentHeight = sdfCanvas.height;
    const neededRows = Math.ceil(atlas.glyphCount / glyphsPerRow);
    const neededHeight = Math.pow(2, Math.ceil(Math.log2(neededRows * sdfGlyphSize)));
    if (neededHeight > currentHeight) {
      console.info(`Increasing SDF texture size ${currentHeight}->${neededHeight}`);
      resizeWebGLCanvasWithoutClearing(sdfCanvas, textureWidth, neededHeight);
      sdfTexture.dispose();
    }
    DefaultThenable.all(neededSDFs.map(
      (glyphInfo) => generateGlyphSDF(glyphInfo, atlas, args.gpuAccelerateSDF).then(({ timing }) => {
        timings.sdf[glyphInfo.atlasIndex] = timing;
      })
    )).then(() => {
      if (neededSDFs.length && !atlas.contextLost) {
        safariPre15Workaround(atlas);
        sdfTexture.needsUpdate = true;
      }
      timings.sdfTotal = now$1() - sdfStart;
      timings.total = now$1() - totalStart;
      callback(Object.freeze({
        parameters: args,
        sdfTexture,
        sdfGlyphSize,
        sdfExponent,
        glyphBounds,
        glyphAtlasIndices: glyphIds,
        glyphColors: result.glyphColors,
        caretPositions: result.caretPositions,
        caretHeight: result.caretHeight,
        chunkedBounds: result.chunkedBounds,
        ascender: result.ascender,
        descender: result.descender,
        lineHeight: result.lineHeight,
        topBaseline: result.topBaseline,
        blockBounds: result.blockBounds,
        visibleBounds: result.visibleBounds,
        timings: result.timings,
        get totalBounds() {
          console.log("totalBounds deprecated, use blockBounds instead");
          return result.blockBounds;
        },
        get totalBlockSize() {
          console.log("totalBlockSize deprecated, use blockBounds instead");
          const [x0, y0, x1, y1] = result.blockBounds;
          return [x1 - x0, y1 - y0];
        }
      }));
    });
  });
  DefaultThenable.all([]).then(() => {
    if (!atlas.contextLost) {
      warmUpSDFCanvas(sdfCanvas);
    }
  });
}
function generateGlyphSDF({ path, atlasIndex, sdfViewBox }, { sdfGlyphSize, sdfCanvas, contextLost }, useGPU) {
  if (contextLost) {
    return Promise.resolve({ timing: -1 });
  }
  const { textureWidth, sdfExponent } = CONFIG;
  const maxDist = Math.max(sdfViewBox[2] - sdfViewBox[0], sdfViewBox[3] - sdfViewBox[1]);
  const squareIndex = Math.floor(atlasIndex / 4);
  const x2 = squareIndex % (textureWidth / sdfGlyphSize) * sdfGlyphSize;
  const y = Math.floor(squareIndex / (textureWidth / sdfGlyphSize)) * sdfGlyphSize;
  const channel = atlasIndex % 4;
  return generateSDF(sdfGlyphSize, sdfGlyphSize, path, sdfViewBox, maxDist, sdfExponent, sdfCanvas, x2, y, channel, useGPU);
}
function initContextLossHandling(atlas) {
  const canvas = atlas.sdfCanvas;
  canvas.addEventListener("webglcontextlost", (event) => {
    console.log("Context Lost", event);
    event.preventDefault();
    atlas.contextLost = true;
  });
  canvas.addEventListener("webglcontextrestored", (event) => {
    console.log("Context Restored", event);
    atlas.contextLost = false;
    const promises = [];
    atlas.glyphsByFont.forEach((glyphMap) => {
      glyphMap.forEach((glyph) => {
        promises.push(generateGlyphSDF(glyph, atlas, true));
      });
    });
    DefaultThenable.all(promises).then(() => {
      safariPre15Workaround(atlas);
      atlas.sdfTexture.needsUpdate = true;
    });
  });
}
function assign2(toObj, fromObj) {
  for (let key in fromObj) {
    if (fromObj.hasOwnProperty(key)) {
      toObj[key] = fromObj[key];
    }
  }
  return toObj;
}
var linkEl;
function toAbsoluteURL(path) {
  if (!linkEl) {
    linkEl = typeof document === "undefined" ? {} : document.createElement("a");
  }
  linkEl.href = path;
  return linkEl.href;
}
function safariPre15Workaround(atlas) {
  if (typeof createImageBitmap !== "function") {
    console.info("Safari<15: applying SDF canvas workaround");
    const { sdfCanvas, sdfTexture } = atlas;
    const { width, height } = sdfCanvas;
    const gl = atlas.sdfCanvas.getContext("webgl");
    let pixels = sdfTexture.image.data;
    if (!pixels || pixels.length !== width * height * 4) {
      pixels = new Uint8Array(width * height * 4);
      sdfTexture.image = { width, height, data: pixels };
      sdfTexture.flipY = false;
      sdfTexture.isDataTexture = true;
    }
    gl.readPixels(0, 0, width, height, gl.RGBA, gl.UNSIGNED_BYTE, pixels);
  }
}
var typesetterWorkerModule = defineWorkerModule({
  name: "Typesetter",
  dependencies: [
    CONFIG,
    workerModule,
    createTypesetter,
    bidi_default
  ],
  init(config, fontParser, createTypesetter2, bidiFactory2) {
    const { defaultFontURL } = config;
    return createTypesetter2(fontParser, bidiFactory2(), { defaultFontURL });
  }
});
var typesetInWorker = defineWorkerModule({
  name: "Typesetter",
  dependencies: [
    typesetterWorkerModule,
    ThenableWorkerModule
  ],
  init(typesetter, Thenable) {
    return function(args) {
      const thenable = new Thenable();
      typesetter.typeset(args, thenable.resolve);
      return thenable;
    };
  },
  getTransferables(result) {
    const transferables = [
      result.glyphPositions.buffer,
      result.glyphIds.buffer
    ];
    if (result.caretPositions) {
      transferables.push(result.caretPositions.buffer);
    }
    if (result.glyphColors) {
      transferables.push(result.glyphColors.buffer);
    }
    return transferables;
  }
});
var GlyphsGeometry = (() => {
  const templateGeometries = {};
  function getTemplateGeometry(detail) {
    let geom = templateGeometries[detail];
    if (!geom) {
      const front = new PlaneBufferGeometry(1, 1, detail, detail);
      const back = front.clone();
      const frontAttrs = front.attributes;
      const backAttrs = back.attributes;
      const combined = new BufferGeometry();
      const vertCount = frontAttrs.uv.count;
      for (let i = 0; i < vertCount; i++) {
        backAttrs.position.array[i * 3] *= -1;
        backAttrs.normal.array[i * 3 + 2] *= -1;
      }
      ["position", "normal", "uv"].forEach((name) => {
        combined.setAttribute(
          name,
          new Float32BufferAttribute(
            [...frontAttrs[name].array, ...backAttrs[name].array],
            frontAttrs[name].itemSize
          )
        );
      });
      combined.setIndex([...front.index.array, ...back.index.array.map((n2) => n2 + vertCount)]);
      combined.translate(0.5, 0.5, 0);
      geom = templateGeometries[detail] = combined;
    }
    return geom;
  }
  const glyphBoundsAttrName = "aTroikaGlyphBounds";
  const glyphIndexAttrName = "aTroikaGlyphIndex";
  const glyphColorAttrName = "aTroikaGlyphColor";
  class GlyphsGeometry2 extends InstancedBufferGeometry {
    constructor() {
      super();
      this.detail = 1;
      this.curveRadius = 0;
      this.groups = [
        { start: 0, count: Infinity, materialIndex: 0 },
        { start: 0, count: Infinity, materialIndex: 1 }
      ];
      this.boundingSphere = new Sphere();
      this.boundingBox = new Box3();
    }
    computeBoundingSphere() {
    }
    computeBoundingBox() {
    }
    // Since our base geometry contains triangles for both front and back sides, we can emulate
    // the "side" by restricting the draw range.
    setSide(side) {
      const verts = this.getIndex().count;
      this.setDrawRange(side === BackSide ? verts / 2 : 0, side === DoubleSide ? verts : verts / 2);
    }
    set detail(detail) {
      if (detail !== this._detail) {
        this._detail = detail;
        if (typeof detail !== "number" || detail < 1) {
          detail = 1;
        }
        let tpl = getTemplateGeometry(detail);
        ["position", "normal", "uv"].forEach((attr) => {
          this.attributes[attr] = tpl.attributes[attr].clone();
        });
        this.setIndex(tpl.getIndex().clone());
      }
    }
    get detail() {
      return this._detail;
    }
    set curveRadius(r) {
      if (r !== this._curveRadius) {
        this._curveRadius = r;
        this._updateBounds();
      }
    }
    get curveRadius() {
      return this._curveRadius;
    }
    /**
     * Update the geometry for a new set of glyphs.
     * @param {Float32Array} glyphBounds - An array holding the planar bounds for all glyphs
     *        to be rendered, 4 entries for each glyph: x1,x2,y1,y1
     * @param {Float32Array} glyphAtlasIndices - An array holding the index of each glyph within
     *        the SDF atlas texture.
     * @param {Array} blockBounds - An array holding the [minX, minY, maxX, maxY] across all glyphs
     * @param {Array} [chunkedBounds] - An array of objects describing bounds for each chunk of N
     *        consecutive glyphs: `{start:N, end:N, rect:[minX, minY, maxX, maxY]}`. This can be
     *        used with `applyClipRect` to choose an optimized `instanceCount`.
     * @param {Uint8Array} [glyphColors] - An array holding r,g,b values for each glyph.
     */
    updateGlyphs(glyphBounds, glyphAtlasIndices, blockBounds, chunkedBounds, glyphColors) {
      updateBufferAttr(this, glyphBoundsAttrName, glyphBounds, 4);
      updateBufferAttr(this, glyphIndexAttrName, glyphAtlasIndices, 1);
      updateBufferAttr(this, glyphColorAttrName, glyphColors, 3);
      this._blockBounds = blockBounds;
      this._chunkedBounds = chunkedBounds;
      setInstanceCount(this, glyphAtlasIndices.length);
      this._updateBounds();
    }
    _updateBounds() {
      const bounds = this._blockBounds;
      if (bounds) {
        const { curveRadius, boundingBox: bbox } = this;
        if (curveRadius) {
          const { PI, floor, min, max, sin, cos } = Math;
          const halfPi = PI / 2;
          const twoPi = PI * 2;
          const absR = Math.abs(curveRadius);
          const leftAngle = bounds[0] / absR;
          const rightAngle = bounds[2] / absR;
          const minX = floor((leftAngle + halfPi) / twoPi) !== floor((rightAngle + halfPi) / twoPi) ? -absR : min(sin(leftAngle) * absR, sin(rightAngle) * absR);
          const maxX = floor((leftAngle - halfPi) / twoPi) !== floor((rightAngle - halfPi) / twoPi) ? absR : max(sin(leftAngle) * absR, sin(rightAngle) * absR);
          const maxZ = floor((leftAngle + PI) / twoPi) !== floor((rightAngle + PI) / twoPi) ? absR * 2 : max(absR - cos(leftAngle) * absR, absR - cos(rightAngle) * absR);
          bbox.min.set(minX, bounds[1], curveRadius < 0 ? -maxZ : 0);
          bbox.max.set(maxX, bounds[3], curveRadius < 0 ? 0 : maxZ);
        } else {
          bbox.min.set(bounds[0], bounds[1], 0);
          bbox.max.set(bounds[2], bounds[3], 0);
        }
        bbox.getBoundingSphere(this.boundingSphere);
      }
    }
    /**
     * Given a clipping rect, and the chunkedBounds from the last updateGlyphs call, choose the lowest
     * `instanceCount` that will show all glyphs within the clipped view. This is an optimization
     * for long blocks of text that are clipped, to skip vertex shader evaluation for glyphs that would
     * be clipped anyway.
     *
     * Note that since `drawElementsInstanced[ANGLE]` only accepts an instance count and not a starting
     * offset, this optimization becomes less effective as the clipRect moves closer to the end of the
     * text block. We could fix that by switching from instancing to a full geometry with a drawRange,
     * but at the expense of much larger attribute buffers (see classdoc above.)
     *
     * @param {Vector4} clipRect
     */
    applyClipRect(clipRect) {
      let count = this.getAttribute(glyphIndexAttrName).count;
      let chunks = this._chunkedBounds;
      if (chunks) {
        for (let i = chunks.length; i--; ) {
          count = chunks[i].end;
          let rect = chunks[i].rect;
          if (rect[1] < clipRect.w && rect[3] > clipRect.y && rect[0] < clipRect.z && rect[2] > clipRect.x) {
            break;
          }
        }
      }
      setInstanceCount(this, count);
    }
  }
  if (!GlyphsGeometry2.prototype.setAttribute) {
    GlyphsGeometry2.prototype.setAttribute = function(name, attribute) {
      this.attributes[name] = attribute;
      return this;
    };
  }
  function updateBufferAttr(geom, attrName, newArray, itemSize) {
    const attr = geom.getAttribute(attrName);
    if (newArray) {
      if (attr && attr.array.length === newArray.length) {
        attr.array.set(newArray);
        attr.needsUpdate = true;
      } else {
        geom.setAttribute(attrName, new InstancedBufferAttribute(newArray, itemSize));
        delete geom._maxInstanceCount;
        geom.dispose();
      }
    } else if (attr) {
      geom.deleteAttribute(attrName);
    }
  }
  function setInstanceCount(geom, count) {
    geom[geom.hasOwnProperty("instanceCount") ? "instanceCount" : "maxInstancedCount"] = count;
  }
  return GlyphsGeometry2;
})();
var VERTEX_DEFS = `
uniform vec2 uTroikaSDFTextureSize;
uniform float uTroikaSDFGlyphSize;
uniform vec4 uTroikaTotalBounds;
uniform vec4 uTroikaClipRect;
uniform mat3 uTroikaOrient;
uniform bool uTroikaUseGlyphColors;
uniform float uTroikaDistanceOffset;
uniform float uTroikaBlurRadius;
uniform vec2 uTroikaPositionOffset;
uniform float uTroikaCurveRadius;
attribute vec4 aTroikaGlyphBounds;
attribute float aTroikaGlyphIndex;
attribute vec3 aTroikaGlyphColor;
varying vec2 vTroikaGlyphUV;
varying vec4 vTroikaTextureUVBounds;
varying float vTroikaTextureChannel;
varying vec3 vTroikaGlyphColor;
varying vec2 vTroikaGlyphDimensions;
`;
var VERTEX_TRANSFORM = `
vec4 bounds = aTroikaGlyphBounds;
bounds.xz += uTroikaPositionOffset.x;
bounds.yw -= uTroikaPositionOffset.y;

vec4 outlineBounds = vec4(
  bounds.xy - uTroikaDistanceOffset - uTroikaBlurRadius,
  bounds.zw + uTroikaDistanceOffset + uTroikaBlurRadius
);
vec4 clippedBounds = vec4(
  clamp(outlineBounds.xy, uTroikaClipRect.xy, uTroikaClipRect.zw),
  clamp(outlineBounds.zw, uTroikaClipRect.xy, uTroikaClipRect.zw)
);

vec2 clippedXY = (mix(clippedBounds.xy, clippedBounds.zw, position.xy) - bounds.xy) / (bounds.zw - bounds.xy);

position.xy = mix(bounds.xy, bounds.zw, clippedXY);

uv = (position.xy - uTroikaTotalBounds.xy) / (uTroikaTotalBounds.zw - uTroikaTotalBounds.xy);

float rad = uTroikaCurveRadius;
if (rad != 0.0) {
  float angle = position.x / rad;
  position.xz = vec2(sin(angle) * rad, rad - cos(angle) * rad);
  normal.xz = vec2(sin(angle), cos(angle));
}
  
position = uTroikaOrient * position;
normal = uTroikaOrient * normal;

vTroikaGlyphUV = clippedXY.xy;
vTroikaGlyphDimensions = vec2(bounds[2] - bounds[0], bounds[3] - bounds[1]);

${""}
float txCols = uTroikaSDFTextureSize.x / uTroikaSDFGlyphSize;
vec2 txUvPerSquare = uTroikaSDFGlyphSize / uTroikaSDFTextureSize;
vec2 txStartUV = txUvPerSquare * vec2(
  mod(floor(aTroikaGlyphIndex / 4.0), txCols),
  floor(floor(aTroikaGlyphIndex / 4.0) / txCols)
);
vTroikaTextureUVBounds = vec4(txStartUV, vec2(txStartUV) + txUvPerSquare);
vTroikaTextureChannel = mod(aTroikaGlyphIndex, 4.0);
`;
var FRAGMENT_DEFS = `
uniform sampler2D uTroikaSDFTexture;
uniform vec2 uTroikaSDFTextureSize;
uniform float uTroikaSDFGlyphSize;
uniform float uTroikaSDFExponent;
uniform float uTroikaDistanceOffset;
uniform float uTroikaFillOpacity;
uniform float uTroikaOutlineOpacity;
uniform float uTroikaBlurRadius;
uniform vec3 uTroikaStrokeColor;
uniform float uTroikaStrokeWidth;
uniform float uTroikaStrokeOpacity;
uniform bool uTroikaSDFDebug;
varying vec2 vTroikaGlyphUV;
varying vec4 vTroikaTextureUVBounds;
varying float vTroikaTextureChannel;
varying vec2 vTroikaGlyphDimensions;

float troikaSdfValueToSignedDistance(float alpha) {
  // Inverse of exponential encoding in webgl-sdf-generator
  ${""}
  float maxDimension = max(vTroikaGlyphDimensions.x, vTroikaGlyphDimensions.y);
  float absDist = (1.0 - pow(2.0 * (alpha > 0.5 ? 1.0 - alpha : alpha), 1.0 / uTroikaSDFExponent)) * maxDimension;
  float signedDist = absDist * (alpha > 0.5 ? -1.0 : 1.0);
  return signedDist;
}

float troikaGlyphUvToSdfValue(vec2 glyphUV) {
  vec2 textureUV = mix(vTroikaTextureUVBounds.xy, vTroikaTextureUVBounds.zw, glyphUV);
  vec4 rgba = texture2D(uTroikaSDFTexture, textureUV);
  float ch = floor(vTroikaTextureChannel + 0.5); //NOTE: can't use round() in WebGL1
  return ch == 0.0 ? rgba.r : ch == 1.0 ? rgba.g : ch == 2.0 ? rgba.b : rgba.a;
}

float troikaGlyphUvToDistance(vec2 uv) {
  return troikaSdfValueToSignedDistance(troikaGlyphUvToSdfValue(uv));
}

float troikaGetAADist() {
  ${""}
  #if defined(GL_OES_standard_derivatives) || __VERSION__ >= 300
  return length(fwidth(vTroikaGlyphUV * vTroikaGlyphDimensions)) * 0.5;
  #else
  return vTroikaGlyphDimensions.x / 64.0;
  #endif
}

float troikaGetFragDistValue() {
  vec2 clampedGlyphUV = clamp(vTroikaGlyphUV, 0.5 / uTroikaSDFGlyphSize, 1.0 - 0.5 / uTroikaSDFGlyphSize);
  float distance = troikaGlyphUvToDistance(clampedGlyphUV);
 
  // Extrapolate distance when outside bounds:
  distance += clampedGlyphUV == vTroikaGlyphUV ? 0.0 : 
    length((vTroikaGlyphUV - clampedGlyphUV) * vTroikaGlyphDimensions);

  ${""}

  return distance;
}

float troikaGetEdgeAlpha(float distance, float distanceOffset, float aaDist) {
  #if defined(IS_DEPTH_MATERIAL) || defined(IS_DISTANCE_MATERIAL)
  float alpha = step(-distanceOffset, -distance);
  #else

  float alpha = smoothstep(
    distanceOffset + aaDist,
    distanceOffset - aaDist,
    distance
  );
  #endif

  return alpha;
}
`;
var FRAGMENT_TRANSFORM = `
float aaDist = troikaGetAADist();
float fragDistance = troikaGetFragDistValue();
float edgeAlpha = uTroikaSDFDebug ?
  troikaGlyphUvToSdfValue(vTroikaGlyphUV) :
  troikaGetEdgeAlpha(fragDistance, uTroikaDistanceOffset, max(aaDist, uTroikaBlurRadius));

#if !defined(IS_DEPTH_MATERIAL) && !defined(IS_DISTANCE_MATERIAL)
vec4 fillRGBA = gl_FragColor;
fillRGBA.a *= uTroikaFillOpacity;
vec4 strokeRGBA = uTroikaStrokeWidth == 0.0 ? fillRGBA : vec4(uTroikaStrokeColor, uTroikaStrokeOpacity);
if (fillRGBA.a == 0.0) fillRGBA.rgb = strokeRGBA.rgb;
gl_FragColor = mix(fillRGBA, strokeRGBA, smoothstep(
  -uTroikaStrokeWidth - aaDist,
  -uTroikaStrokeWidth + aaDist,
  fragDistance
));
gl_FragColor.a *= edgeAlpha;
#endif

if (edgeAlpha == 0.0) {
  discard;
}
`;
function createTextDerivedMaterial(baseMaterial) {
  const textMaterial = createDerivedMaterial(baseMaterial, {
    chained: true,
    extensions: {
      derivatives: true
    },
    uniforms: {
      uTroikaSDFTexture: { value: null },
      uTroikaSDFTextureSize: { value: new Vector2() },
      uTroikaSDFGlyphSize: { value: 0 },
      uTroikaSDFExponent: { value: 0 },
      uTroikaTotalBounds: { value: new Vector4(0, 0, 0, 0) },
      uTroikaClipRect: { value: new Vector4(0, 0, 0, 0) },
      uTroikaDistanceOffset: { value: 0 },
      uTroikaOutlineOpacity: { value: 0 },
      uTroikaFillOpacity: { value: 1 },
      uTroikaPositionOffset: { value: new Vector2() },
      uTroikaCurveRadius: { value: 0 },
      uTroikaBlurRadius: { value: 0 },
      uTroikaStrokeWidth: { value: 0 },
      uTroikaStrokeColor: { value: new Color() },
      uTroikaStrokeOpacity: { value: 1 },
      uTroikaOrient: { value: new Matrix3() },
      uTroikaUseGlyphColors: { value: true },
      uTroikaSDFDebug: { value: false }
    },
    vertexDefs: VERTEX_DEFS,
    vertexTransform: VERTEX_TRANSFORM,
    fragmentDefs: FRAGMENT_DEFS,
    fragmentColorTransform: FRAGMENT_TRANSFORM,
    customRewriter({ vertexShader, fragmentShader }) {
      let uDiffuseRE = /\buniform\s+vec3\s+diffuse\b/;
      if (uDiffuseRE.test(fragmentShader)) {
        fragmentShader = fragmentShader.replace(uDiffuseRE, "varying vec3 vTroikaGlyphColor").replace(/\bdiffuse\b/g, "vTroikaGlyphColor");
        if (!uDiffuseRE.test(vertexShader)) {
          vertexShader = vertexShader.replace(
            voidMainRegExp,
            "uniform vec3 diffuse;\n$&\nvTroikaGlyphColor = uTroikaUseGlyphColors ? aTroikaGlyphColor / 255.0 : diffuse;\n"
          );
        }
      }
      return { vertexShader, fragmentShader };
    }
  });
  textMaterial.transparent = true;
  Object.defineProperties(textMaterial, {
    isTroikaTextMaterial: { value: true },
    // WebGLShadowMap reverses the side of the shadow material by default, which fails
    // for planes, so here we force the `shadowSide` to always match the main side.
    shadowSide: {
      get() {
        return this.side;
      },
      set() {
      }
    }
  });
  return textMaterial;
}
var Text = (() => {
  const defaultMaterial = new MeshBasicMaterial({
    color: 16777215,
    side: DoubleSide,
    transparent: true
  });
  const defaultStrokeColor = 8421504;
  const tempMat4 = new Matrix4();
  const tempVec3a = new Vector3();
  const tempVec3b = new Vector3();
  const tempArray = [];
  const origin = new Vector3();
  const defaultOrient = "+x+y";
  function first(o) {
    return Array.isArray(o) ? o[0] : o;
  }
  let getFlatRaycastMesh = () => {
    const mesh = new Mesh(
      new PlaneBufferGeometry(1, 1),
      defaultMaterial
    );
    getFlatRaycastMesh = () => mesh;
    return mesh;
  };
  let getCurvedRaycastMesh = () => {
    const mesh = new Mesh(
      new PlaneBufferGeometry(1, 1, 32, 1),
      defaultMaterial
    );
    getCurvedRaycastMesh = () => mesh;
    return mesh;
  };
  const syncStartEvent = { type: "syncstart" };
  const syncCompleteEvent = { type: "synccomplete" };
  const SYNCABLE_PROPS = [
    "font",
    "fontSize",
    "letterSpacing",
    "lineHeight",
    "maxWidth",
    "overflowWrap",
    "text",
    "direction",
    "textAlign",
    "textIndent",
    "whiteSpace",
    "anchorX",
    "anchorY",
    "colorRanges",
    "sdfGlyphSize"
  ];
  const COPYABLE_PROPS = SYNCABLE_PROPS.concat(
    "material",
    "color",
    "depthOffset",
    "clipRect",
    "curveRadius",
    "orientation",
    "glyphGeometryDetail"
  );
  class Text3 extends Mesh {
    constructor() {
      const geometry = new GlyphsGeometry();
      super(geometry, null);
      this.text = "";
      this.anchorX = 0;
      this.anchorY = 0;
      this.curveRadius = 0;
      this.direction = "auto";
      this.font = null;
      this.fontSize = 0.1;
      this.letterSpacing = 0;
      this.lineHeight = "normal";
      this.maxWidth = Infinity;
      this.overflowWrap = "normal";
      this.textAlign = "left";
      this.textIndent = 0;
      this.whiteSpace = "normal";
      this.material = null;
      this.color = null;
      this.colorRanges = null;
      this.outlineWidth = 0;
      this.outlineColor = 0;
      this.outlineOpacity = 1;
      this.outlineBlur = 0;
      this.outlineOffsetX = 0;
      this.outlineOffsetY = 0;
      this.strokeWidth = 0;
      this.strokeColor = defaultStrokeColor;
      this.strokeOpacity = 1;
      this.fillOpacity = 1;
      this.depthOffset = 0;
      this.clipRect = null;
      this.orientation = defaultOrient;
      this.glyphGeometryDetail = 1;
      this.sdfGlyphSize = null;
      this.gpuAccelerateSDF = true;
      this.debugSDF = false;
    }
    /**
     * Updates the text rendering according to the current text-related configuration properties.
     * This is an async process, so you can pass in a callback function to be executed when it
     * finishes.
     * @param {function} [callback]
     */
    sync(callback) {
      if (this._needsSync) {
        this._needsSync = false;
        if (this._isSyncing) {
          (this._queuedSyncs || (this._queuedSyncs = [])).push(callback);
        } else {
          this._isSyncing = true;
          this.dispatchEvent(syncStartEvent);
          getTextRenderInfo({
            text: this.text,
            font: this.font,
            fontSize: this.fontSize || 0.1,
            letterSpacing: this.letterSpacing || 0,
            lineHeight: this.lineHeight || "normal",
            maxWidth: this.maxWidth,
            direction: this.direction || "auto",
            textAlign: this.textAlign,
            textIndent: this.textIndent,
            whiteSpace: this.whiteSpace,
            overflowWrap: this.overflowWrap,
            anchorX: this.anchorX,
            anchorY: this.anchorY,
            colorRanges: this.colorRanges,
            includeCaretPositions: true,
            //TODO parameterize
            sdfGlyphSize: this.sdfGlyphSize,
            gpuAccelerateSDF: this.gpuAccelerateSDF
          }, (textRenderInfo) => {
            this._isSyncing = false;
            this._textRenderInfo = textRenderInfo;
            this.geometry.updateGlyphs(
              textRenderInfo.glyphBounds,
              textRenderInfo.glyphAtlasIndices,
              textRenderInfo.blockBounds,
              textRenderInfo.chunkedBounds,
              textRenderInfo.glyphColors
            );
            const queued = this._queuedSyncs;
            if (queued) {
              this._queuedSyncs = null;
              this._needsSync = true;
              this.sync(() => {
                queued.forEach((fn) => fn && fn());
              });
            }
            this.dispatchEvent(syncCompleteEvent);
            if (callback) {
              callback();
            }
          });
        }
      }
    }
    /**
     * Initiate a sync if needed - note it won't complete until next frame at the
     * earliest so if possible it's a good idea to call sync() manually as soon as
     * all the properties have been set.
     * @override
     */
    onBeforeRender(renderer, scene, camera, geometry, material, group) {
      this.sync();
      if (material.isTroikaTextMaterial) {
        this._prepareForRender(material);
      }
      material._hadOwnSide = material.hasOwnProperty("side");
      this.geometry.setSide(material._actualSide = material.side);
      material.side = FrontSide;
    }
    onAfterRender(renderer, scene, camera, geometry, material, group) {
      if (material._hadOwnSide) {
        material.side = material._actualSide;
      } else {
        delete material.side;
      }
    }
    /**
     * Shortcut to dispose the geometry specific to this instance.
     * Note: we don't also dispose the derived material here because if anything else is
     * sharing the same base material it will result in a pause next frame as the program
     * is recompiled. Instead users can dispose the base material manually, like normal,
     * and we'll also dispose the derived material at that time.
     */
    dispose() {
      this.geometry.dispose();
    }
    /**
     * @property {TroikaTextRenderInfo|null} textRenderInfo
     * @readonly
     * The current processed rendering data for this TextMesh, returned by the TextBuilder after
     * a `sync()` call. This will be `null` initially, and may be stale for a short period until
     * the asynchrous `sync()` process completes.
     */
    get textRenderInfo() {
      return this._textRenderInfo || null;
    }
    // Handler for automatically wrapping the base material with our upgrades. We do the wrapping
    // lazily on _read_ rather than write to avoid unnecessary wrapping on transient values.
    get material() {
      let derivedMaterial = this._derivedMaterial;
      const baseMaterial = this._baseMaterial || this._defaultMaterial || (this._defaultMaterial = defaultMaterial.clone());
      if (!derivedMaterial || derivedMaterial.baseMaterial !== baseMaterial) {
        derivedMaterial = this._derivedMaterial = createTextDerivedMaterial(baseMaterial);
        baseMaterial.addEventListener("dispose", function onDispose() {
          baseMaterial.removeEventListener("dispose", onDispose);
          derivedMaterial.dispose();
        });
      }
      if (this.outlineWidth || this.outlineBlur || this.outlineOffsetX || this.outlineOffsetY) {
        let outlineMaterial = derivedMaterial._outlineMtl;
        if (!outlineMaterial) {
          outlineMaterial = derivedMaterial._outlineMtl = Object.create(derivedMaterial, {
            id: { value: derivedMaterial.id + 0.1 }
          });
          outlineMaterial.isTextOutlineMaterial = true;
          outlineMaterial.depthWrite = false;
          outlineMaterial.map = null;
          derivedMaterial.addEventListener("dispose", function onDispose() {
            derivedMaterial.removeEventListener("dispose", onDispose);
            outlineMaterial.dispose();
          });
        }
        return [
          outlineMaterial,
          derivedMaterial
        ];
      } else {
        return derivedMaterial;
      }
    }
    set material(baseMaterial) {
      if (baseMaterial && baseMaterial.isTroikaTextMaterial) {
        this._derivedMaterial = baseMaterial;
        this._baseMaterial = baseMaterial.baseMaterial;
      } else {
        this._baseMaterial = baseMaterial;
      }
    }
    get glyphGeometryDetail() {
      return this.geometry.detail;
    }
    set glyphGeometryDetail(detail) {
      this.geometry.detail = detail;
    }
    get curveRadius() {
      return this.geometry.curveRadius;
    }
    set curveRadius(r) {
      this.geometry.curveRadius = r;
    }
    // Create and update material for shadows upon request:
    get customDepthMaterial() {
      return first(this.material).getDepthMaterial();
    }
    get customDistanceMaterial() {
      return first(this.material).getDistanceMaterial();
    }
    _prepareForRender(material) {
      const isOutline = material.isTextOutlineMaterial;
      const uniforms = material.uniforms;
      const textInfo = this.textRenderInfo;
      if (textInfo) {
        const { sdfTexture, blockBounds } = textInfo;
        uniforms.uTroikaSDFTexture.value = sdfTexture;
        uniforms.uTroikaSDFTextureSize.value.set(sdfTexture.image.width, sdfTexture.image.height);
        uniforms.uTroikaSDFGlyphSize.value = textInfo.sdfGlyphSize;
        uniforms.uTroikaSDFExponent.value = textInfo.sdfExponent;
        uniforms.uTroikaTotalBounds.value.fromArray(blockBounds);
        uniforms.uTroikaUseGlyphColors.value = !isOutline && !!textInfo.glyphColors;
        let distanceOffset = 0;
        let blurRadius = 0;
        let strokeWidth = 0;
        let fillOpacity;
        let strokeOpacity;
        let strokeColor;
        let offsetX = 0;
        let offsetY = 0;
        if (isOutline) {
          let { outlineWidth, outlineOffsetX, outlineOffsetY, outlineBlur, outlineOpacity } = this;
          distanceOffset = this._parsePercent(outlineWidth) || 0;
          blurRadius = Math.max(0, this._parsePercent(outlineBlur) || 0);
          fillOpacity = outlineOpacity;
          offsetX = this._parsePercent(outlineOffsetX) || 0;
          offsetY = this._parsePercent(outlineOffsetY) || 0;
        } else {
          strokeWidth = Math.max(0, this._parsePercent(this.strokeWidth) || 0);
          if (strokeWidth) {
            strokeColor = this.strokeColor;
            uniforms.uTroikaStrokeColor.value.set(strokeColor == null ? defaultStrokeColor : strokeColor);
            strokeOpacity = this.strokeOpacity;
            if (strokeOpacity == null)
              strokeOpacity = 1;
          }
          fillOpacity = this.fillOpacity;
        }
        uniforms.uTroikaDistanceOffset.value = distanceOffset;
        uniforms.uTroikaPositionOffset.value.set(offsetX, offsetY);
        uniforms.uTroikaBlurRadius.value = blurRadius;
        uniforms.uTroikaStrokeWidth.value = strokeWidth;
        uniforms.uTroikaStrokeOpacity.value = strokeOpacity;
        uniforms.uTroikaFillOpacity.value = fillOpacity == null ? 1 : fillOpacity;
        uniforms.uTroikaCurveRadius.value = this.curveRadius || 0;
        let clipRect = this.clipRect;
        if (clipRect && Array.isArray(clipRect) && clipRect.length === 4) {
          uniforms.uTroikaClipRect.value.fromArray(clipRect);
        } else {
          const pad = (this.fontSize || 0.1) * 100;
          uniforms.uTroikaClipRect.value.set(
            blockBounds[0] - pad,
            blockBounds[1] - pad,
            blockBounds[2] + pad,
            blockBounds[3] + pad
          );
        }
        this.geometry.applyClipRect(uniforms.uTroikaClipRect.value);
      }
      uniforms.uTroikaSDFDebug.value = !!this.debugSDF;
      material.polygonOffset = !!this.depthOffset;
      material.polygonOffsetFactor = material.polygonOffsetUnits = this.depthOffset || 0;
      const color = isOutline ? this.outlineColor || 0 : this.color;
      if (color == null) {
        delete material.color;
      } else {
        const colorObj = material.hasOwnProperty("color") ? material.color : material.color = new Color();
        if (color !== colorObj._input || typeof color === "object") {
          colorObj.set(colorObj._input = color);
        }
      }
      let orient = this.orientation || defaultOrient;
      if (orient !== material._orientation) {
        let rotMat = uniforms.uTroikaOrient.value;
        orient = orient.replace(/[^-+xyz]/g, "");
        let match = orient !== defaultOrient && orient.match(/^([-+])([xyz])([-+])([xyz])$/);
        if (match) {
          let [, hSign, hAxis, vSign, vAxis] = match;
          tempVec3a.set(0, 0, 0)[hAxis] = hSign === "-" ? 1 : -1;
          tempVec3b.set(0, 0, 0)[vAxis] = vSign === "-" ? -1 : 1;
          tempMat4.lookAt(origin, tempVec3a.cross(tempVec3b), tempVec3b);
          rotMat.setFromMatrix4(tempMat4);
        } else {
          rotMat.identity();
        }
        material._orientation = orient;
      }
    }
    _parsePercent(value) {
      if (typeof value === "string") {
        let match = value.match(/^(-?[\d.]+)%$/);
        let pct = match ? parseFloat(match[1]) : NaN;
        value = (isNaN(pct) ? 0 : pct / 100) * this.fontSize;
      }
      return value;
    }
    /**
     * Translate a point in local space to an x/y in the text plane.
     */
    localPositionToTextCoords(position, target = new Vector2()) {
      target.copy(position);
      const r = this.curveRadius;
      if (r) {
        target.x = Math.atan2(position.x, Math.abs(r) - Math.abs(position.z)) * Math.abs(r);
      }
      return target;
    }
    /**
     * Translate a point in world space to an x/y in the text plane.
     */
    worldPositionToTextCoords(position, target = new Vector2()) {
      tempVec3a.copy(position);
      return this.localPositionToTextCoords(this.worldToLocal(tempVec3a), target);
    }
    /**
     * @override Custom raycasting to test against the whole text block's max rectangular bounds
     * TODO is there any reason to make this more granular, like within individual line or glyph rects?
     */
    raycast(raycaster, intersects) {
      const { textRenderInfo, curveRadius } = this;
      if (textRenderInfo) {
        const bounds = textRenderInfo.blockBounds;
        const raycastMesh = curveRadius ? getCurvedRaycastMesh() : getFlatRaycastMesh();
        const geom = raycastMesh.geometry;
        const { position, uv } = geom.attributes;
        for (let i = 0; i < uv.count; i++) {
          let x2 = bounds[0] + uv.getX(i) * (bounds[2] - bounds[0]);
          const y = bounds[1] + uv.getY(i) * (bounds[3] - bounds[1]);
          let z = 0;
          if (curveRadius) {
            z = curveRadius - Math.cos(x2 / curveRadius) * curveRadius;
            x2 = Math.sin(x2 / curveRadius) * curveRadius;
          }
          position.setXYZ(i, x2, y, z);
        }
        geom.boundingSphere = this.geometry.boundingSphere;
        geom.boundingBox = this.geometry.boundingBox;
        raycastMesh.matrixWorld = this.matrixWorld;
        raycastMesh.material.side = this.material.side;
        tempArray.length = 0;
        raycastMesh.raycast(raycaster, tempArray);
        for (let i = 0; i < tempArray.length; i++) {
          tempArray[i].object = this;
          intersects.push(tempArray[i]);
        }
      }
    }
    copy(source) {
      const geom = this.geometry;
      super.copy(source);
      this.geometry = geom;
      COPYABLE_PROPS.forEach((prop) => {
        this[prop] = source[prop];
      });
      return this;
    }
    clone() {
      return new this.constructor().copy(this);
    }
  }
  SYNCABLE_PROPS.forEach((prop) => {
    const privateKey = "_private_" + prop;
    Object.defineProperty(Text3.prototype, prop, {
      get() {
        return this[privateKey];
      },
      set(value) {
        if (value !== this[privateKey]) {
          this[privateKey] = value;
          this._needsSync = true;
        }
      }
    });
  });
  let deprMsgShown = false;
  Object.defineProperty(Text3.prototype, "anchor", {
    get() {
      return this._deprecated_anchor;
    },
    set(val) {
      this._deprecated_anchor = val;
      if (!deprMsgShown) {
        console.warn("TextMesh: `anchor` has been deprecated; use `anchorX` and `anchorY` instead.");
        deprMsgShown = true;
      }
      if (Array.isArray(val)) {
        this.anchorX = `${(+val[0] || 0) * 100}%`;
        this.anchorY = `${(+val[1] || 0) * 100}%`;
      } else {
        this.anchorX = this.anchorY = 0;
      }
    }
  });
  return Text3;
})();

// node_modules/threlte/text/Text.svelte
function create_default_slot26(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[43].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[54],
    null
  );
  const block = {
    c: function create() {
      if (default_slot)
        default_slot.c();
    },
    l: function claim(nodes) {
      if (default_slot)
        default_slot.l(nodes);
    },
    m: function mount(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty[1] & /*$$scope*/
        8388608)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[54],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[54]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[54],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot26.name,
    type: "slot",
    source: "(123:0) <MeshInstance   mesh={textObject}   {lookAt}   {position}   {scale}   {rotation}   {castShadow}   {receiveShadow}   {frustumCulled}   {renderOrder}   {visible}   {interactive}   {ignorePointer}   on:click   on:contextmenu   on:pointerup   on:pointerdown   on:pointerenter   on:pointerleave   on:pointermove   {viewportAware}   bind:inViewport   on:viewportenter   on:viewportleave >",
    ctx
  });
  return block;
}
function create_fragment40(ctx) {
  let meshinstance;
  let updating_inViewport;
  let current;
  function meshinstance_inViewport_binding(value) {
    ctx[44](value);
  }
  let meshinstance_props = {
    mesh: (
      /*textObject*/
      ctx[13]
    ),
    lookAt: (
      /*lookAt*/
      ctx[12]
    ),
    position: (
      /*position*/
      ctx[1]
    ),
    scale: (
      /*scale*/
      ctx[2]
    ),
    rotation: (
      /*rotation*/
      ctx[3]
    ),
    castShadow: (
      /*castShadow*/
      ctx[5]
    ),
    receiveShadow: (
      /*receiveShadow*/
      ctx[6]
    ),
    frustumCulled: (
      /*frustumCulled*/
      ctx[7]
    ),
    renderOrder: (
      /*renderOrder*/
      ctx[8]
    ),
    visible: (
      /*visible*/
      ctx[9]
    ),
    interactive: (
      /*interactive*/
      ctx[10]
    ),
    ignorePointer: (
      /*ignorePointer*/
      ctx[11]
    ),
    viewportAware: (
      /*viewportAware*/
      ctx[4]
    ),
    $$slots: { default: [create_default_slot26] },
    $$scope: { ctx }
  };
  if (
    /*inViewport*/
    ctx[0] !== void 0
  ) {
    meshinstance_props.inViewport = /*inViewport*/
    ctx[0];
  }
  meshinstance = new MeshInstance_default({
    props: meshinstance_props,
    $$inline: true
  });
  binding_callbacks.push(() => bind(meshinstance, "inViewport", meshinstance_inViewport_binding));
  meshinstance.$on(
    "click",
    /*click_handler*/
    ctx[45]
  );
  meshinstance.$on(
    "contextmenu",
    /*contextmenu_handler*/
    ctx[46]
  );
  meshinstance.$on(
    "pointerup",
    /*pointerup_handler*/
    ctx[47]
  );
  meshinstance.$on(
    "pointerdown",
    /*pointerdown_handler*/
    ctx[48]
  );
  meshinstance.$on(
    "pointerenter",
    /*pointerenter_handler*/
    ctx[49]
  );
  meshinstance.$on(
    "pointerleave",
    /*pointerleave_handler*/
    ctx[50]
  );
  meshinstance.$on(
    "pointermove",
    /*pointermove_handler*/
    ctx[51]
  );
  meshinstance.$on(
    "viewportenter",
    /*viewportenter_handler*/
    ctx[52]
  );
  meshinstance.$on(
    "viewportleave",
    /*viewportleave_handler*/
    ctx[53]
  );
  const block = {
    c: function create() {
      create_component(meshinstance.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(meshinstance.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(meshinstance, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const meshinstance_changes = {};
      if (dirty[0] & /*lookAt*/
      4096)
        meshinstance_changes.lookAt = /*lookAt*/
        ctx2[12];
      if (dirty[0] & /*position*/
      2)
        meshinstance_changes.position = /*position*/
        ctx2[1];
      if (dirty[0] & /*scale*/
      4)
        meshinstance_changes.scale = /*scale*/
        ctx2[2];
      if (dirty[0] & /*rotation*/
      8)
        meshinstance_changes.rotation = /*rotation*/
        ctx2[3];
      if (dirty[0] & /*castShadow*/
      32)
        meshinstance_changes.castShadow = /*castShadow*/
        ctx2[5];
      if (dirty[0] & /*receiveShadow*/
      64)
        meshinstance_changes.receiveShadow = /*receiveShadow*/
        ctx2[6];
      if (dirty[0] & /*frustumCulled*/
      128)
        meshinstance_changes.frustumCulled = /*frustumCulled*/
        ctx2[7];
      if (dirty[0] & /*renderOrder*/
      256)
        meshinstance_changes.renderOrder = /*renderOrder*/
        ctx2[8];
      if (dirty[0] & /*visible*/
      512)
        meshinstance_changes.visible = /*visible*/
        ctx2[9];
      if (dirty[0] & /*interactive*/
      1024)
        meshinstance_changes.interactive = /*interactive*/
        ctx2[10];
      if (dirty[0] & /*ignorePointer*/
      2048)
        meshinstance_changes.ignorePointer = /*ignorePointer*/
        ctx2[11];
      if (dirty[0] & /*viewportAware*/
      16)
        meshinstance_changes.viewportAware = /*viewportAware*/
        ctx2[4];
      if (dirty[1] & /*$$scope*/
      8388608) {
        meshinstance_changes.$$scope = { dirty, ctx: ctx2 };
      }
      if (!updating_inViewport && dirty[0] & /*inViewport*/
      1) {
        updating_inViewport = true;
        meshinstance_changes.inViewport = /*inViewport*/
        ctx2[0];
        add_flush_callback(() => updating_inViewport = false);
      }
      meshinstance.$set(meshinstance_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(meshinstance.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(meshinstance.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(meshinstance, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment40.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance39($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Text", slots, ["default"]);
  let { position = void 0 } = $$props;
  let { scale = void 0 } = $$props;
  let { rotation = void 0 } = $$props;
  let { viewportAware = false } = $$props;
  let { inViewport = false } = $$props;
  let { castShadow = void 0 } = $$props;
  let { receiveShadow = void 0 } = $$props;
  let { frustumCulled = void 0 } = $$props;
  let { renderOrder = void 0 } = $$props;
  let { visible = void 0 } = $$props;
  let { interactive = false } = $$props;
  let { ignorePointer = false } = $$props;
  let { lookAt = void 0 } = $$props;
  let { text = void 0 } = $$props;
  let { anchorX = void 0 } = $$props;
  let { anchorY = void 0 } = $$props;
  let { curveRadius = void 0 } = $$props;
  let { font = void 0 } = $$props;
  let { fontSize = void 0 } = $$props;
  let { letterSpacing = void 0 } = $$props;
  let { lineHeight = void 0 } = $$props;
  let { maxWidth = void 0 } = $$props;
  let { overflowWrap = void 0 } = $$props;
  let { textAlign = void 0 } = $$props;
  let { textIndent = void 0 } = $$props;
  let { whiteSpace = void 0 } = $$props;
  let { material = void 0 } = $$props;
  let { color = void 0 } = $$props;
  let { depthOffset = void 0 } = $$props;
  let { clipRect = void 0 } = $$props;
  let { glyphGeometryDetail = void 0 } = $$props;
  let { sdfGlyphSize = void 0 } = $$props;
  let { outlineWidth = void 0 } = $$props;
  let { outlineColor = void 0 } = $$props;
  let { outlineOpacity = void 0 } = $$props;
  let { outlineBlur = void 0 } = $$props;
  let { outlineOffsetX = void 0 } = $$props;
  let { outlineOffsetY = void 0 } = $$props;
  let { strokeWidth = void 0 } = $$props;
  let { strokeColor = void 0 } = $$props;
  let { strokeOpacity = void 0 } = $$props;
  let { fillOpacity = void 0 } = $$props;
  const textObject = new Text();
  const getTextObject = () => textObject;
  const { invalidate } = useThrelte();
  const dispatch = createEventDispatcher();
  onDestroy(() => {
    textObject.dispose();
  });
  const writable_props = [
    "position",
    "scale",
    "rotation",
    "viewportAware",
    "inViewport",
    "castShadow",
    "receiveShadow",
    "frustumCulled",
    "renderOrder",
    "visible",
    "interactive",
    "ignorePointer",
    "lookAt",
    "text",
    "anchorX",
    "anchorY",
    "curveRadius",
    "font",
    "fontSize",
    "letterSpacing",
    "lineHeight",
    "maxWidth",
    "overflowWrap",
    "textAlign",
    "textIndent",
    "whiteSpace",
    "material",
    "color",
    "depthOffset",
    "clipRect",
    "glyphGeometryDetail",
    "sdfGlyphSize",
    "outlineWidth",
    "outlineColor",
    "outlineOpacity",
    "outlineBlur",
    "outlineOffsetX",
    "outlineOffsetY",
    "strokeWidth",
    "strokeColor",
    "strokeOpacity",
    "fillOpacity"
  ];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<Text> was created with unknown prop '${key}'`);
  });
  function meshinstance_inViewport_binding(value) {
    inViewport = value;
    $$invalidate(0, inViewport);
  }
  function click_handler(event) {
    bubble.call(this, $$self, event);
  }
  function contextmenu_handler(event) {
    bubble.call(this, $$self, event);
  }
  function pointerup_handler(event) {
    bubble.call(this, $$self, event);
  }
  function pointerdown_handler(event) {
    bubble.call(this, $$self, event);
  }
  function pointerenter_handler(event) {
    bubble.call(this, $$self, event);
  }
  function pointerleave_handler(event) {
    bubble.call(this, $$self, event);
  }
  function pointermove_handler(event) {
    bubble.call(this, $$self, event);
  }
  function viewportenter_handler(event) {
    bubble.call(this, $$self, event);
  }
  function viewportleave_handler(event) {
    bubble.call(this, $$self, event);
  }
  $$self.$$set = ($$props2) => {
    if ("position" in $$props2)
      $$invalidate(1, position = $$props2.position);
    if ("scale" in $$props2)
      $$invalidate(2, scale = $$props2.scale);
    if ("rotation" in $$props2)
      $$invalidate(3, rotation = $$props2.rotation);
    if ("viewportAware" in $$props2)
      $$invalidate(4, viewportAware = $$props2.viewportAware);
    if ("inViewport" in $$props2)
      $$invalidate(0, inViewport = $$props2.inViewport);
    if ("castShadow" in $$props2)
      $$invalidate(5, castShadow = $$props2.castShadow);
    if ("receiveShadow" in $$props2)
      $$invalidate(6, receiveShadow = $$props2.receiveShadow);
    if ("frustumCulled" in $$props2)
      $$invalidate(7, frustumCulled = $$props2.frustumCulled);
    if ("renderOrder" in $$props2)
      $$invalidate(8, renderOrder = $$props2.renderOrder);
    if ("visible" in $$props2)
      $$invalidate(9, visible = $$props2.visible);
    if ("interactive" in $$props2)
      $$invalidate(10, interactive = $$props2.interactive);
    if ("ignorePointer" in $$props2)
      $$invalidate(11, ignorePointer = $$props2.ignorePointer);
    if ("lookAt" in $$props2)
      $$invalidate(12, lookAt = $$props2.lookAt);
    if ("text" in $$props2)
      $$invalidate(14, text = $$props2.text);
    if ("anchorX" in $$props2)
      $$invalidate(15, anchorX = $$props2.anchorX);
    if ("anchorY" in $$props2)
      $$invalidate(16, anchorY = $$props2.anchorY);
    if ("curveRadius" in $$props2)
      $$invalidate(17, curveRadius = $$props2.curveRadius);
    if ("font" in $$props2)
      $$invalidate(18, font = $$props2.font);
    if ("fontSize" in $$props2)
      $$invalidate(19, fontSize = $$props2.fontSize);
    if ("letterSpacing" in $$props2)
      $$invalidate(20, letterSpacing = $$props2.letterSpacing);
    if ("lineHeight" in $$props2)
      $$invalidate(21, lineHeight = $$props2.lineHeight);
    if ("maxWidth" in $$props2)
      $$invalidate(22, maxWidth = $$props2.maxWidth);
    if ("overflowWrap" in $$props2)
      $$invalidate(23, overflowWrap = $$props2.overflowWrap);
    if ("textAlign" in $$props2)
      $$invalidate(24, textAlign = $$props2.textAlign);
    if ("textIndent" in $$props2)
      $$invalidate(25, textIndent = $$props2.textIndent);
    if ("whiteSpace" in $$props2)
      $$invalidate(26, whiteSpace = $$props2.whiteSpace);
    if ("material" in $$props2)
      $$invalidate(27, material = $$props2.material);
    if ("color" in $$props2)
      $$invalidate(28, color = $$props2.color);
    if ("depthOffset" in $$props2)
      $$invalidate(29, depthOffset = $$props2.depthOffset);
    if ("clipRect" in $$props2)
      $$invalidate(30, clipRect = $$props2.clipRect);
    if ("glyphGeometryDetail" in $$props2)
      $$invalidate(31, glyphGeometryDetail = $$props2.glyphGeometryDetail);
    if ("sdfGlyphSize" in $$props2)
      $$invalidate(32, sdfGlyphSize = $$props2.sdfGlyphSize);
    if ("outlineWidth" in $$props2)
      $$invalidate(33, outlineWidth = $$props2.outlineWidth);
    if ("outlineColor" in $$props2)
      $$invalidate(34, outlineColor = $$props2.outlineColor);
    if ("outlineOpacity" in $$props2)
      $$invalidate(35, outlineOpacity = $$props2.outlineOpacity);
    if ("outlineBlur" in $$props2)
      $$invalidate(36, outlineBlur = $$props2.outlineBlur);
    if ("outlineOffsetX" in $$props2)
      $$invalidate(37, outlineOffsetX = $$props2.outlineOffsetX);
    if ("outlineOffsetY" in $$props2)
      $$invalidate(38, outlineOffsetY = $$props2.outlineOffsetY);
    if ("strokeWidth" in $$props2)
      $$invalidate(39, strokeWidth = $$props2.strokeWidth);
    if ("strokeColor" in $$props2)
      $$invalidate(40, strokeColor = $$props2.strokeColor);
    if ("strokeOpacity" in $$props2)
      $$invalidate(41, strokeOpacity = $$props2.strokeOpacity);
    if ("fillOpacity" in $$props2)
      $$invalidate(42, fillOpacity = $$props2.fillOpacity);
    if ("$$scope" in $$props2)
      $$invalidate(54, $$scope = $$props2.$$scope);
  };
  $$self.$capture_state = () => ({
    createEventDispatcher,
    onDestroy,
    ThreeText: Text,
    useThrelte,
    MeshInstance: MeshInstance_default,
    position,
    scale,
    rotation,
    viewportAware,
    inViewport,
    castShadow,
    receiveShadow,
    frustumCulled,
    renderOrder,
    visible,
    interactive,
    ignorePointer,
    lookAt,
    text,
    anchorX,
    anchorY,
    curveRadius,
    font,
    fontSize,
    letterSpacing,
    lineHeight,
    maxWidth,
    overflowWrap,
    textAlign,
    textIndent,
    whiteSpace,
    material,
    color,
    depthOffset,
    clipRect,
    glyphGeometryDetail,
    sdfGlyphSize,
    outlineWidth,
    outlineColor,
    outlineOpacity,
    outlineBlur,
    outlineOffsetX,
    outlineOffsetY,
    strokeWidth,
    strokeColor,
    strokeOpacity,
    fillOpacity,
    textObject,
    getTextObject,
    invalidate,
    dispatch
  });
  $$self.$inject_state = ($$props2) => {
    if ("position" in $$props2)
      $$invalidate(1, position = $$props2.position);
    if ("scale" in $$props2)
      $$invalidate(2, scale = $$props2.scale);
    if ("rotation" in $$props2)
      $$invalidate(3, rotation = $$props2.rotation);
    if ("viewportAware" in $$props2)
      $$invalidate(4, viewportAware = $$props2.viewportAware);
    if ("inViewport" in $$props2)
      $$invalidate(0, inViewport = $$props2.inViewport);
    if ("castShadow" in $$props2)
      $$invalidate(5, castShadow = $$props2.castShadow);
    if ("receiveShadow" in $$props2)
      $$invalidate(6, receiveShadow = $$props2.receiveShadow);
    if ("frustumCulled" in $$props2)
      $$invalidate(7, frustumCulled = $$props2.frustumCulled);
    if ("renderOrder" in $$props2)
      $$invalidate(8, renderOrder = $$props2.renderOrder);
    if ("visible" in $$props2)
      $$invalidate(9, visible = $$props2.visible);
    if ("interactive" in $$props2)
      $$invalidate(10, interactive = $$props2.interactive);
    if ("ignorePointer" in $$props2)
      $$invalidate(11, ignorePointer = $$props2.ignorePointer);
    if ("lookAt" in $$props2)
      $$invalidate(12, lookAt = $$props2.lookAt);
    if ("text" in $$props2)
      $$invalidate(14, text = $$props2.text);
    if ("anchorX" in $$props2)
      $$invalidate(15, anchorX = $$props2.anchorX);
    if ("anchorY" in $$props2)
      $$invalidate(16, anchorY = $$props2.anchorY);
    if ("curveRadius" in $$props2)
      $$invalidate(17, curveRadius = $$props2.curveRadius);
    if ("font" in $$props2)
      $$invalidate(18, font = $$props2.font);
    if ("fontSize" in $$props2)
      $$invalidate(19, fontSize = $$props2.fontSize);
    if ("letterSpacing" in $$props2)
      $$invalidate(20, letterSpacing = $$props2.letterSpacing);
    if ("lineHeight" in $$props2)
      $$invalidate(21, lineHeight = $$props2.lineHeight);
    if ("maxWidth" in $$props2)
      $$invalidate(22, maxWidth = $$props2.maxWidth);
    if ("overflowWrap" in $$props2)
      $$invalidate(23, overflowWrap = $$props2.overflowWrap);
    if ("textAlign" in $$props2)
      $$invalidate(24, textAlign = $$props2.textAlign);
    if ("textIndent" in $$props2)
      $$invalidate(25, textIndent = $$props2.textIndent);
    if ("whiteSpace" in $$props2)
      $$invalidate(26, whiteSpace = $$props2.whiteSpace);
    if ("material" in $$props2)
      $$invalidate(27, material = $$props2.material);
    if ("color" in $$props2)
      $$invalidate(28, color = $$props2.color);
    if ("depthOffset" in $$props2)
      $$invalidate(29, depthOffset = $$props2.depthOffset);
    if ("clipRect" in $$props2)
      $$invalidate(30, clipRect = $$props2.clipRect);
    if ("glyphGeometryDetail" in $$props2)
      $$invalidate(31, glyphGeometryDetail = $$props2.glyphGeometryDetail);
    if ("sdfGlyphSize" in $$props2)
      $$invalidate(32, sdfGlyphSize = $$props2.sdfGlyphSize);
    if ("outlineWidth" in $$props2)
      $$invalidate(33, outlineWidth = $$props2.outlineWidth);
    if ("outlineColor" in $$props2)
      $$invalidate(34, outlineColor = $$props2.outlineColor);
    if ("outlineOpacity" in $$props2)
      $$invalidate(35, outlineOpacity = $$props2.outlineOpacity);
    if ("outlineBlur" in $$props2)
      $$invalidate(36, outlineBlur = $$props2.outlineBlur);
    if ("outlineOffsetX" in $$props2)
      $$invalidate(37, outlineOffsetX = $$props2.outlineOffsetX);
    if ("outlineOffsetY" in $$props2)
      $$invalidate(38, outlineOffsetY = $$props2.outlineOffsetY);
    if ("strokeWidth" in $$props2)
      $$invalidate(39, strokeWidth = $$props2.strokeWidth);
    if ("strokeColor" in $$props2)
      $$invalidate(40, strokeColor = $$props2.strokeColor);
    if ("strokeOpacity" in $$props2)
      $$invalidate(41, strokeOpacity = $$props2.strokeOpacity);
    if ("fillOpacity" in $$props2)
      $$invalidate(42, fillOpacity = $$props2.fillOpacity);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty[0] & /*text, anchorX, anchorY, curveRadius, font, fontSize, letterSpacing, lineHeight, maxWidth, overflowWrap, textAlign, textIndent, whiteSpace, material, color, depthOffset, clipRect*/
    2147467264 | $$self.$$.dirty[1] & /*glyphGeometryDetail, sdfGlyphSize, outlineWidth, outlineColor, outlineOpacity, outlineBlur, outlineOffsetX, outlineOffsetY, strokeWidth, strokeColor, strokeOpacity, fillOpacity*/
    4095) {
      $: {
        const to = getTextObject();
        if (text !== void 0)
          to.text = text;
        if (anchorX !== void 0)
          to.anchorX = anchorX;
        if (anchorY !== void 0)
          to.anchorY = anchorY;
        if (curveRadius !== void 0)
          to.curveRadius = curveRadius;
        if (font !== void 0)
          to.font = font;
        if (fontSize !== void 0)
          to.fontSize = fontSize;
        if (letterSpacing !== void 0)
          to.letterSpacing = letterSpacing;
        if (lineHeight !== void 0)
          to.lineHeight = lineHeight;
        if (maxWidth !== void 0)
          to.maxWidth = maxWidth;
        if (overflowWrap !== void 0)
          to.overflowWrap = overflowWrap;
        if (textAlign !== void 0)
          to.textAlign = textAlign;
        if (textIndent !== void 0)
          to.textIndent = textIndent;
        if (whiteSpace !== void 0)
          to.whiteSpace = whiteSpace;
        if (material)
          to.material = material;
        if (color !== void 0)
          to.color = color;
        if (depthOffset !== void 0)
          to.depthOffset = depthOffset;
        if (clipRect !== void 0)
          to.clipRect = clipRect;
        if (glyphGeometryDetail !== void 0)
          to.glyphGeometryDetail = glyphGeometryDetail;
        if (sdfGlyphSize !== void 0)
          to.sdfGlyphSize = sdfGlyphSize;
        if (outlineWidth !== void 0)
          to.outlineWidth = outlineWidth;
        if (outlineColor !== void 0)
          to.outlineColor = outlineColor;
        if (outlineOpacity !== void 0)
          to.outlineOpacity = outlineOpacity;
        if (outlineBlur !== void 0)
          to.outlineBlur = outlineBlur;
        if (outlineOffsetX !== void 0)
          to.outlineOffsetX = outlineOffsetX;
        if (outlineOffsetY !== void 0)
          to.outlineOffsetY = outlineOffsetY;
        if (strokeWidth !== void 0)
          to.strokeWidth = strokeWidth;
        if (strokeColor !== void 0)
          to.strokeColor = strokeColor;
        if (strokeOpacity !== void 0)
          to.strokeOpacity = strokeOpacity;
        if (fillOpacity !== void 0)
          to.fillOpacity = fillOpacity;
        to.sync(() => {
          invalidate("Text: sync finished");
          dispatch("sync");
        });
      }
    }
  };
  return [
    inViewport,
    position,
    scale,
    rotation,
    viewportAware,
    castShadow,
    receiveShadow,
    frustumCulled,
    renderOrder,
    visible,
    interactive,
    ignorePointer,
    lookAt,
    textObject,
    text,
    anchorX,
    anchorY,
    curveRadius,
    font,
    fontSize,
    letterSpacing,
    lineHeight,
    maxWidth,
    overflowWrap,
    textAlign,
    textIndent,
    whiteSpace,
    material,
    color,
    depthOffset,
    clipRect,
    glyphGeometryDetail,
    sdfGlyphSize,
    outlineWidth,
    outlineColor,
    outlineOpacity,
    outlineBlur,
    outlineOffsetX,
    outlineOffsetY,
    strokeWidth,
    strokeColor,
    strokeOpacity,
    fillOpacity,
    slots,
    meshinstance_inViewport_binding,
    click_handler,
    contextmenu_handler,
    pointerup_handler,
    pointerdown_handler,
    pointerenter_handler,
    pointerleave_handler,
    pointermove_handler,
    viewportenter_handler,
    viewportleave_handler,
    $$scope
  ];
}
var Text2 = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(
      this,
      options,
      instance39,
      create_fragment40,
      safe_not_equal,
      {
        position: 1,
        scale: 2,
        rotation: 3,
        viewportAware: 4,
        inViewport: 0,
        castShadow: 5,
        receiveShadow: 6,
        frustumCulled: 7,
        renderOrder: 8,
        visible: 9,
        interactive: 10,
        ignorePointer: 11,
        lookAt: 12,
        text: 14,
        anchorX: 15,
        anchorY: 16,
        curveRadius: 17,
        font: 18,
        fontSize: 19,
        letterSpacing: 20,
        lineHeight: 21,
        maxWidth: 22,
        overflowWrap: 23,
        textAlign: 24,
        textIndent: 25,
        whiteSpace: 26,
        material: 27,
        color: 28,
        depthOffset: 29,
        clipRect: 30,
        glyphGeometryDetail: 31,
        sdfGlyphSize: 32,
        outlineWidth: 33,
        outlineColor: 34,
        outlineOpacity: 35,
        outlineBlur: 36,
        outlineOffsetX: 37,
        outlineOffsetY: 38,
        strokeWidth: 39,
        strokeColor: 40,
        strokeOpacity: 41,
        fillOpacity: 42,
        textObject: 13
      },
      null,
      [-1, -1]
    );
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Text",
      options,
      id: create_fragment40.name
    });
  }
  get position() {
    throw new Error("<Text>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set position(value) {
    throw new Error("<Text>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get scale() {
    throw new Error("<Text>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set scale(value) {
    throw new Error("<Text>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get rotation() {
    throw new Error("<Text>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set rotation(value) {
    throw new Error("<Text>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get viewportAware() {
    throw new Error("<Text>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set viewportAware(value) {
    throw new Error("<Text>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get inViewport() {
    throw new Error("<Text>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set inViewport(value) {
    throw new Error("<Text>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get castShadow() {
    throw new Error("<Text>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set castShadow(value) {
    throw new Error("<Text>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get receiveShadow() {
    throw new Error("<Text>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set receiveShadow(value) {
    throw new Error("<Text>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get frustumCulled() {
    throw new Error("<Text>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set frustumCulled(value) {
    throw new Error("<Text>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get renderOrder() {
    throw new Error("<Text>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set renderOrder(value) {
    throw new Error("<Text>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get visible() {
    throw new Error("<Text>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set visible(value) {
    throw new Error("<Text>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get interactive() {
    throw new Error("<Text>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set interactive(value) {
    throw new Error("<Text>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get ignorePointer() {
    throw new Error("<Text>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set ignorePointer(value) {
    throw new Error("<Text>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get lookAt() {
    throw new Error("<Text>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set lookAt(value) {
    throw new Error("<Text>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get text() {
    throw new Error("<Text>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set text(value) {
    throw new Error("<Text>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get anchorX() {
    throw new Error("<Text>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set anchorX(value) {
    throw new Error("<Text>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get anchorY() {
    throw new Error("<Text>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set anchorY(value) {
    throw new Error("<Text>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get curveRadius() {
    throw new Error("<Text>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set curveRadius(value) {
    throw new Error("<Text>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get font() {
    throw new Error("<Text>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set font(value) {
    throw new Error("<Text>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get fontSize() {
    throw new Error("<Text>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set fontSize(value) {
    throw new Error("<Text>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get letterSpacing() {
    throw new Error("<Text>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set letterSpacing(value) {
    throw new Error("<Text>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get lineHeight() {
    throw new Error("<Text>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set lineHeight(value) {
    throw new Error("<Text>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get maxWidth() {
    throw new Error("<Text>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set maxWidth(value) {
    throw new Error("<Text>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get overflowWrap() {
    throw new Error("<Text>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set overflowWrap(value) {
    throw new Error("<Text>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get textAlign() {
    throw new Error("<Text>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set textAlign(value) {
    throw new Error("<Text>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get textIndent() {
    throw new Error("<Text>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set textIndent(value) {
    throw new Error("<Text>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get whiteSpace() {
    throw new Error("<Text>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set whiteSpace(value) {
    throw new Error("<Text>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get material() {
    throw new Error("<Text>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set material(value) {
    throw new Error("<Text>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get color() {
    throw new Error("<Text>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set color(value) {
    throw new Error("<Text>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get depthOffset() {
    throw new Error("<Text>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set depthOffset(value) {
    throw new Error("<Text>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get clipRect() {
    throw new Error("<Text>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set clipRect(value) {
    throw new Error("<Text>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get glyphGeometryDetail() {
    throw new Error("<Text>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set glyphGeometryDetail(value) {
    throw new Error("<Text>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get sdfGlyphSize() {
    throw new Error("<Text>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set sdfGlyphSize(value) {
    throw new Error("<Text>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get outlineWidth() {
    throw new Error("<Text>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set outlineWidth(value) {
    throw new Error("<Text>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get outlineColor() {
    throw new Error("<Text>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set outlineColor(value) {
    throw new Error("<Text>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get outlineOpacity() {
    throw new Error("<Text>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set outlineOpacity(value) {
    throw new Error("<Text>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get outlineBlur() {
    throw new Error("<Text>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set outlineBlur(value) {
    throw new Error("<Text>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get outlineOffsetX() {
    throw new Error("<Text>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set outlineOffsetX(value) {
    throw new Error("<Text>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get outlineOffsetY() {
    throw new Error("<Text>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set outlineOffsetY(value) {
    throw new Error("<Text>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get strokeWidth() {
    throw new Error("<Text>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set strokeWidth(value) {
    throw new Error("<Text>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get strokeColor() {
    throw new Error("<Text>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set strokeColor(value) {
    throw new Error("<Text>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get strokeOpacity() {
    throw new Error("<Text>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set strokeOpacity(value) {
    throw new Error("<Text>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get fillOpacity() {
    throw new Error("<Text>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set fillOpacity(value) {
    throw new Error("<Text>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get textObject() {
    return this.$$.ctx[13];
  }
  set textObject(value) {
    throw new Error("<Text>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Text_default = Text2;

// node_modules/threlte/hooks/useTexture.js
var loader = useLoader(TextureLoader, () => new TextureLoader());
var loadTexture = (path, options) => {
  return loader.load(path, (t2) => {
    var _a;
    invalidateGlobally("useTexture");
    (_a = options == null ? void 0 : options.onLoad) == null ? void 0 : _a.call(options, t2);
  }, (e) => {
    var _a;
    (_a = options == null ? void 0 : options.onProgress) == null ? void 0 : _a.call(options, e);
  }, (e) => {
    var _a;
    (_a = options == null ? void 0 : options.onError) == null ? void 0 : _a.call(options, e);
  });
};
var pathsIsString = (paths) => {
  return typeof paths === "string";
};
var pathsIsArray = (paths) => {
  return Array.isArray(paths);
};
var convertTextureColor = (texture) => {
  try {
    const rootCtx = useThrelteRoot();
    if (!rootCtx)
      return texture;
    if (!get_store_value(rootCtx.linear))
      texture.encoding = sRGBEncoding;
  } catch (error) {
    console.warn("Calling useTexture outside component initialization does not support color correction.");
  }
  return texture;
};
function useTexture(paths, options) {
  if (pathsIsString(paths)) {
    if (!browser)
      return new Texture();
    return convertTextureColor(loadTexture(paths, options));
  } else if (pathsIsArray(paths)) {
    if (!browser) {
      return paths.map(() => new Texture());
    }
    return paths.map((path) => convertTextureColor(loadTexture(path, options)));
  } else {
    const entries = Object.entries(paths);
    const map = entries.reduce((acc, [key, value]) => {
      acc[key] = browser ? loadTexture(value, options) : new Texture();
      return acc;
    }, {});
    return map;
  }
}

// node_modules/threlte/hooks/useAudioListener.js
function useAudioListener(callbackOrId, id) {
  const audioCtx = useThrelteAudio();
  if (!audioCtx) {
    throw new Error('No threlte audio context found, "useAudioListener" can only be used in a child component of <Canvas>');
  }
  if (callbackOrId && typeof callbackOrId === "string") {
    const listener = audioCtx.getAudioListener(callbackOrId);
    if (!listener)
      throw new Error("No AudioListener found.");
    return {
      listener,
      context: listener.context
    };
  } else if (callbackOrId && typeof callbackOrId === "function") {
    const listener = audioCtx.getAudioListener(id);
    if (!listener)
      throw new Error("No AudioListener found.");
    return callbackOrId({
      listener,
      context: listener.context
    });
  } else {
    const listener = audioCtx.getAudioListener();
    if (!listener)
      throw new Error("No AudioListener found.");
    return {
      listener,
      context: listener.context
    };
  }
}
export {
  AmbientLight_default as AmbientLight,
  Audio_default as Audio,
  AudioListener_default as AudioListener,
  CameraInstance_default as CameraInstance,
  Canvas_default as Canvas,
  ContextBridge_default as ContextBridge,
  DirectionalLight_default as DirectionalLight,
  Fog_default as Fog,
  FogExp2_default as FogExp2,
  GLTF_default as GLTF,
  Group_default as Group,
  HemisphereLight_default as HemisphereLight,
  Instance_default as Instance,
  InstancedMesh_default as InstancedMesh,
  Layers_default as Layers,
  LightInstance_default as LightInstance,
  Line_default as Line,
  Line2_default as Line2,
  LineInstance_default as LineInstance,
  LineSegments_default as LineSegments,
  Mesh_default as Mesh,
  MeshInstance_default as MeshInstance,
  Object3D_default as Object3D,
  Object3DInstance_default as Object3DInstance,
  OrbitControls_default as OrbitControls,
  OrthographicCamera_default as OrthographicCamera,
  Pass_default as Pass,
  PerspectiveCamera_default as PerspectiveCamera,
  PointLight_default as PointLight,
  PositionalAudio_default as PositionalAudio,
  PositionalAudioHelper_default as PositionalAudioHelper,
  SpotLight_default as SpotLight,
  Text_default as Text,
  TransformControls_default as TransformControls,
  useAudioListener,
  useFrame,
  useLoader,
  useTexture,
  useThrelte,
  useThrelteAudio,
  useThrelteRoot
};
/*! Bundled license information:

troika-three-text/dist/troika-three-text.esm.js:
  (*!
  Custom build of Typr.ts (https://github.com/fredli74/Typr.ts) for use in Troika text rendering.
  Original MIT license applies: https://github.com/fredli74/Typr.ts/blob/master/LICENSE
  *)
  (*!
  Custom bundle of woff2otf (https://github.com/arty-name/woff2otf) with fflate
  (https://github.com/101arrowz/fflate) for use in Troika text rendering. 
  Original licenses apply: 
  - fflate: https://github.com/101arrowz/fflate/blob/master/LICENSE (MIT)
  - woff2otf.js: https://github.com/arty-name/woff2otf/blob/master/woff2otf.js (Apache2)
  *)
*/
//# sourceMappingURL=threlte.js.map
